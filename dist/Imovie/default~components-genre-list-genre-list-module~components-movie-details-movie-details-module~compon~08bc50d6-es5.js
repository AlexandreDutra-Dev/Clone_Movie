var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~components-genre-list-genre-list-module~components-movie-details-movie-details-module~compon~08bc50d6"], {
        /***/ "./node_modules/@angular/cdk/esm2015/accordion.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/accordion.js ***!
          \********************************************************/
        /*! exports provided: CdkAccordionItem, CdkAccordion, CdkAccordionModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordionItem", function () { return CdkAccordionItem; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordion", function () { return CdkAccordion; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkAccordionModule", function () { return CdkAccordionModule; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each accordion.
             * @type {?}
             */
            var nextId = 0;
            /**
             * Directive whose purpose is to manage the expanded state of CdkAccordionItem children.
             */
            var CdkAccordion = /** @class */ (function () {
                function CdkAccordion() {
                    /**
                     * Emits when the state of the accordion changes
                     */
                    this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * Stream that emits true/false when openAll/closeAll is triggered.
                     */
                    this._openCloseAllActions = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * A readonly id value to use for unique selection coordination.
                     */
                    this.id = "cdk-accordion-" + nextId++;
                    this._multi = false;
                }
                Object.defineProperty(CdkAccordion.prototype, "multi", {
                    /**
                     * Whether the accordion should allow multiple expanded accordion items simultaneously.
                     * @return {?}
                     */
                    get: function () { return this._multi; },
                    /**
                     * @param {?} multi
                     * @return {?}
                     */
                    set: function (multi) { this._multi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(multi); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens all enabled accordion items in an accordion where multi is enabled.
                 * @return {?}
                 */
                CdkAccordion.prototype.openAll = function () {
                    this._openCloseAll(true);
                };
                /**
                 * Closes all enabled accordion items in an accordion where multi is enabled.
                 * @return {?}
                 */
                CdkAccordion.prototype.closeAll = function () {
                    this._openCloseAll(false);
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkAccordion.prototype.ngOnChanges = function (changes) {
                    this._stateChanges.next(changes);
                };
                /**
                 * @return {?}
                 */
                CdkAccordion.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                /**
                 * @private
                 * @param {?} expanded
                 * @return {?}
                 */
                CdkAccordion.prototype._openCloseAll = function (expanded) {
                    if (this.multi) {
                        this._openCloseAllActions.next(expanded);
                    }
                };
                return CdkAccordion;
            }());
            CdkAccordion.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-accordion, [cdkAccordion]',
                            exportAs: 'cdkAccordion',
                        },] },
            ];
            CdkAccordion.propDecorators = {
                multi: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each accordion item.
             * @type {?}
             */
            var nextId$1 = 0;
            var ɵ0 = undefined;
            /**
             * An basic directive expected to be extended and decorated as a component.  Sets up all
             * events and attributes needed to be managed by a CdkAccordion parent.
             */
            var CdkAccordionItem = /** @class */ (function () {
                /**
                 * @param {?} accordion
                 * @param {?} _changeDetectorRef
                 * @param {?} _expansionDispatcher
                 */
                function CdkAccordionItem(accordion, _changeDetectorRef, _expansionDispatcher) {
                    var _this = this;
                    this.accordion = accordion;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._expansionDispatcher = _expansionDispatcher;
                    /**
                     * Subscription to openAll/closeAll events.
                     */
                    this._openCloseAllSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
                    /**
                     * Event emitted every time the AccordionItem is closed.
                     */
                    this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Event emitted every time the AccordionItem is opened.
                     */
                    this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Event emitted when the AccordionItem is destroyed.
                     */
                    this.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * Emits whenever the expanded state of the accordion changes.
                     * Primarily used to facilitate two-way binding.
                     * \@docs-private
                     */
                    this.expandedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    /**
                     * The unique AccordionItem id.
                     */
                    this.id = "cdk-accordion-child-" + nextId$1++;
                    this._expanded = false;
                    this._disabled = false;
                    /**
                     * Unregister function for _expansionDispatcher.
                     */
                    this._removeUniqueSelectionListener = ( /**
                     * @return {?}
                     */function () { });
                    this._removeUniqueSelectionListener =
                        _expansionDispatcher.listen(( /**
                         * @param {?} id
                         * @param {?} accordionId
                         * @return {?}
                         */function (id, accordionId) {
                            if (_this.accordion && !_this.accordion.multi &&
                                _this.accordion.id === accordionId && _this.id !== id) {
                                _this.expanded = false;
                            }
                        }));
                    // When an accordion item is hosted in an accordion, subscribe to open/close events.
                    if (this.accordion) {
                        this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();
                    }
                }
                Object.defineProperty(CdkAccordionItem.prototype, "expanded", {
                    /**
                     * Whether the AccordionItem is expanded.
                     * @return {?}
                     */
                    get: function () { return this._expanded; },
                    /**
                     * @param {?} expanded
                     * @return {?}
                     */
                    set: function (expanded) {
                        expanded = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(expanded);
                        // Only emit events and update the internal value if the value changes.
                        if (this._expanded !== expanded) {
                            this._expanded = expanded;
                            this.expandedChange.emit(expanded);
                            if (expanded) {
                                this.opened.emit();
                                /**
                                 * In the unique selection dispatcher, the id parameter is the id of the CdkAccordionItem,
                                 * the name value is the id of the accordion.
                                 * @type {?}
                                 */
                                var accordionId = this.accordion ? this.accordion.id : this.id;
                                this._expansionDispatcher.notify(this.id, accordionId);
                            }
                            else {
                                this.closed.emit();
                            }
                            // Ensures that the animation will run when the value is set outside of an `@Input`.
                            // This includes cases like the open, close and toggle methods.
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkAccordionItem.prototype, "disabled", {
                    /**
                     * Whether the AccordionItem is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} disabled
                     * @return {?}
                     */
                    set: function (disabled) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(disabled); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Emits an event for the accordion item being destroyed.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.ngOnDestroy = function () {
                    this.opened.complete();
                    this.closed.complete();
                    this.destroyed.emit();
                    this.destroyed.complete();
                    this._removeUniqueSelectionListener();
                    this._openCloseAllSubscription.unsubscribe();
                };
                /**
                 * Toggles the expanded state of the accordion item.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.toggle = function () {
                    if (!this.disabled) {
                        this.expanded = !this.expanded;
                    }
                };
                /**
                 * Sets the expanded state of the accordion item to false.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.close = function () {
                    if (!this.disabled) {
                        this.expanded = false;
                    }
                };
                /**
                 * Sets the expanded state of the accordion item to true.
                 * @return {?}
                 */
                CdkAccordionItem.prototype.open = function () {
                    if (!this.disabled) {
                        this.expanded = true;
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                CdkAccordionItem.prototype._subscribeToOpenCloseAllActions = function () {
                    var _this = this;
                    return this.accordion._openCloseAllActions.subscribe(( /**
                     * @param {?} expanded
                     * @return {?}
                     */function (/**
                     * @param {?} expanded
                     * @return {?}
                     */ expanded) {
                        // Only change expanded state if item is enabled
                        if (!_this.disabled) {
                            _this.expanded = expanded;
                        }
                    }));
                };
                return CdkAccordionItem;
            }());
            CdkAccordionItem.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-accordion-item, [cdkAccordionItem]',
                            exportAs: 'cdkAccordionItem',
                            providers: [
                                // Provide CdkAccordion as undefined to prevent nested accordion items from registering
                                // to the same accordion.
                                { provide: CdkAccordion, useValue: ɵ0 },
                            ],
                        },] },
            ];
            /** @nocollapse */
            CdkAccordionItem.ctorParameters = function () { return [
                { type: CdkAccordion, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["UniqueSelectionDispatcher"] }
            ]; };
            CdkAccordionItem.propDecorators = {
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                destroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                expandedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"] }],
                expanded: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkAccordionModule = /** @class */ (function () {
                function CdkAccordionModule() {
                }
                return CdkAccordionModule;
            }());
            CdkAccordionModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            exports: [CdkAccordion, CdkAccordionItem],
                            declarations: [CdkAccordion, CdkAccordionItem],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=accordion.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/stepper.js": 
        /*!******************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/stepper.js ***!
          \******************************************************/
        /*! exports provided: StepperSelectionEvent, STEP_STATE, STEPPER_GLOBAL_OPTIONS, MAT_STEPPER_GLOBAL_OPTIONS, CdkStep, CdkStepper, CdkStepLabel, CdkStepperNext, CdkStepperPrevious, CdkStepperModule, CdkStepHeader */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StepperSelectionEvent", function () { return StepperSelectionEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEP_STATE", function () { return STEP_STATE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STEPPER_GLOBAL_OPTIONS", function () { return STEPPER_GLOBAL_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_GLOBAL_OPTIONS", function () { return MAT_STEPPER_GLOBAL_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStep", function () { return CdkStep; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepper", function () { return CdkStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepLabel", function () { return CdkStepLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperNext", function () { return CdkStepperNext; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperPrevious", function () { return CdkStepperPrevious; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepperModule", function () { return CdkStepperModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkStepHeader", function () { return CdkStepHeader; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepHeader = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function CdkStepHeader(_elementRef) {
                    this._elementRef = _elementRef;
                }
                /**
                 * Focuses the step header.
                 * @return {?}
                 */
                CdkStepHeader.prototype.focus = function () {
                    this._elementRef.nativeElement.focus();
                };
                return CdkStepHeader;
            }());
            CdkStepHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepHeader]',
                            host: {
                                'role': 'tab',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkStepHeader.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepLabel = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkStepLabel(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkStepLabel;
            }());
            CdkStepLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepLabel]',
                        },] },
            ];
            /** @nocollapse */
            CdkStepLabel.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate unique ID for each stepper component.
             * @type {?}
             */
            var nextId = 0;
            /**
             * Change event emitted on selection changes.
             */
            var StepperSelectionEvent = /** @class */ (function () {
                function StepperSelectionEvent() {
                }
                return StepperSelectionEvent;
            }());
            /**
             * Enum to represent the different states of the steps.
             * @type {?}
             */
            var STEP_STATE = {
                NUMBER: 'number',
                EDIT: 'edit',
                DONE: 'done',
                ERROR: 'error'
            };
            /**
             * InjectionToken that can be used to specify the global stepper options.
             * @type {?}
             */
            var STEPPER_GLOBAL_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('STEPPER_GLOBAL_OPTIONS');
            /**
             * InjectionToken that can be used to specify the global stepper options.
             * @deprecated Use `STEPPER_GLOBAL_OPTIONS` instead.
             * \@breaking-change 8.0.0.
             * @type {?}
             */
            var MAT_STEPPER_GLOBAL_OPTIONS = STEPPER_GLOBAL_OPTIONS;
            var CdkStep = /** @class */ (function () {
                /**
                 * \@breaking-change 8.0.0 remove the `?` after `stepperOptions`
                 * @param {?} _stepper
                 * @param {?=} stepperOptions
                 */
                function CdkStep(_stepper, stepperOptions) {
                    this._stepper = _stepper;
                    /**
                     * Whether user has seen the expanded step content or not.
                     */
                    this.interacted = false;
                    this._editable = true;
                    this._optional = false;
                    this._completedOverride = null;
                    this._customError = null;
                    this._stepperOptions = stepperOptions ? stepperOptions : {};
                    this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
                    this._showError = !!this._stepperOptions.showError;
                }
                Object.defineProperty(CdkStep.prototype, "editable", {
                    /**
                     * Whether the user can return to this step once it has been marked as completed.
                     * @return {?}
                     */
                    get: function () {
                        return this._editable;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._editable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStep.prototype, "optional", {
                    /**
                     * Whether the completion of step is optional.
                     * @return {?}
                     */
                    get: function () {
                        return this._optional;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._optional = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStep.prototype, "completed", {
                    /**
                     * Whether step is marked as completed.
                     * @return {?}
                     */
                    get: function () {
                        return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._completedOverride = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 * @return {?}
                 */
                CdkStep.prototype._getDefaultCompleted = function () {
                    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
                };
                Object.defineProperty(CdkStep.prototype, "hasError", {
                    /**
                     * Whether step has an error.
                     * @return {?}
                     */
                    get: function () {
                        return this._customError == null ? this._getDefaultError() : this._customError;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._customError = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @private
                 * @return {?}
                 */
                CdkStep.prototype._getDefaultError = function () {
                    return this.stepControl && this.stepControl.invalid && this.interacted;
                };
                /**
                 * Selects this step component.
                 * @return {?}
                 */
                CdkStep.prototype.select = function () {
                    this._stepper.selected = this;
                };
                /**
                 * Resets the step to its initial state. Note that this includes resetting form data.
                 * @return {?}
                 */
                CdkStep.prototype.reset = function () {
                    this.interacted = false;
                    if (this._completedOverride != null) {
                        this._completedOverride = false;
                    }
                    if (this._customError != null) {
                        this._customError = false;
                    }
                    if (this.stepControl) {
                        this.stepControl.reset();
                    }
                };
                /**
                 * @return {?}
                 */
                CdkStep.prototype.ngOnChanges = function () {
                    // Since basically all inputs of the MatStep get proxied through the view down to the
                    // underlying MatStepHeader, we have to make sure that change detection runs correctly.
                    this._stepper._stateChanged();
                };
                return CdkStep;
            }());
            CdkStep.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'cdk-step',
                            exportAs: 'cdkStep',
                            template: '<ng-template><ng-content></ng-content></ng-template>',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            CdkStep.ctorParameters = function () { return [
                { type: CdkStepper, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return CdkStepper; })),] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [STEPPER_GLOBAL_OPTIONS,] }] }
            ]; };
            CdkStep.propDecorators = {
                stepLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [CdkStepLabel, { static: false },] }],
                content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"], { static: true },] }],
                stepControl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                errorMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                state: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                editable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                optional: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                completed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                hasError: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var CdkStepper = /** @class */ (function () {
                /**
                 * @param {?} _dir
                 * @param {?} _changeDetectorRef
                 * @param {?=} _elementRef
                 * @param {?=} _document
                 */
                function CdkStepper(_dir, _changeDetectorRef, _elementRef, _document) {
                    this._dir = _dir;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._elementRef = _elementRef;
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    this._linear = false;
                    this._selectedIndex = 0;
                    /**
                     * Event emitted when the selected step has changed.
                     */
                    this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._orientation = 'horizontal';
                    this._groupId = nextId++;
                    this._document = _document;
                }
                Object.defineProperty(CdkStepper.prototype, "steps", {
                    /**
                     * The list of step components that the stepper is holding.
                     * @return {?}
                     */
                    get: function () {
                        return this._steps;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "linear", {
                    /**
                     * Whether the validity of previous steps should be checked or not.
                     * @return {?}
                     */
                    get: function () {
                        return this._linear;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._linear = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "selectedIndex", {
                    /**
                     * The index of the selected step.
                     * @return {?}
                     */
                    get: function () {
                        return this._selectedIndex;
                    },
                    /**
                     * @param {?} index
                     * @return {?}
                     */
                    set: function (index) {
                        /** @type {?} */
                        var newIndex = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceNumberProperty"])(index);
                        if (this.steps) {
                            // Ensure that the index can't be out of bounds.
                            if (newIndex < 0 || newIndex > this.steps.length - 1) {
                                throw Error('cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.');
                            }
                            if (this._selectedIndex != newIndex && !this._anyControlsInvalidOrPending(newIndex) &&
                                (newIndex >= this._selectedIndex || this.steps.toArray()[newIndex].editable)) {
                                this._updateSelectedItemIndex(index);
                            }
                        }
                        else {
                            this._selectedIndex = newIndex;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkStepper.prototype, "selected", {
                    /**
                     * The step that is selected.
                     * @return {?}
                     */
                    get: function () {
                        // @breaking-change 8.0.0 Change return type to `CdkStep | undefined`.
                        return this.steps ? this.steps.toArray()[this.selectedIndex] : ( /** @type {?} */(undefined));
                    },
                    /**
                     * @param {?} step
                     * @return {?}
                     */
                    set: function (step) {
                        this.selectedIndex = this.steps ? this.steps.toArray().indexOf(step) : -1;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkStepper.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    // Note that while the step headers are content children by default, any components that
                    // extend this one might have them as view chidren. We initialize the keyboard handling in
                    // AfterViewInit so we're guaranteed for both view and content children to be defined.
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusKeyManager"](this._stepHeader)
                        .withWrap()
                        .withVerticalOrientation(this._orientation === 'vertical');
                    (this._dir ? (( /** @type {?} */(this._dir.change))) : Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])())
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(this._layoutDirection()), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @param {?} direction
                 * @return {?}
                 */function (/**
                 * @param {?} direction
                 * @return {?}
                 */ direction) { return _this._keyManager.withHorizontalOrientation(direction); }));
                    this._keyManager.updateActiveItemIndex(this._selectedIndex);
                    this.steps.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (!_this.selected) {
                            _this._selectedIndex = Math.max(_this._selectedIndex - 1, 0);
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                CdkStepper.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Selects and focuses the next step in list.
                 * @return {?}
                 */
                CdkStepper.prototype.next = function () {
                    this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
                };
                /**
                 * Selects and focuses the previous step in list.
                 * @return {?}
                 */
                CdkStepper.prototype.previous = function () {
                    this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
                };
                /**
                 * Resets the stepper to its initial state. Note that this includes clearing form data.
                 * @return {?}
                 */
                CdkStepper.prototype.reset = function () {
                    this._updateSelectedItemIndex(0);
                    this.steps.forEach(( /**
                     * @param {?} step
                     * @return {?}
                     */function (/**
                     * @param {?} step
                     * @return {?}
                     */ step) { return step.reset(); }));
                    this._stateChanged();
                };
                /**
                 * Returns a unique id for each step label element.
                 * @param {?} i
                 * @return {?}
                 */
                CdkStepper.prototype._getStepLabelId = function (i) {
                    return "cdk-step-label-" + this._groupId + "-" + i;
                };
                /**
                 * Returns unique id for each step content element.
                 * @param {?} i
                 * @return {?}
                 */
                CdkStepper.prototype._getStepContentId = function (i) {
                    return "cdk-step-content-" + this._groupId + "-" + i;
                };
                /**
                 * Marks the component to be change detected.
                 * @return {?}
                 */
                CdkStepper.prototype._stateChanged = function () {
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Returns position state of the step with the given index.
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._getAnimationDirection = function (index) {
                    /** @type {?} */
                    var position = index - this._selectedIndex;
                    if (position < 0) {
                        return this._layoutDirection() === 'rtl' ? 'next' : 'previous';
                    }
                    else if (position > 0) {
                        return this._layoutDirection() === 'rtl' ? 'previous' : 'next';
                    }
                    return 'current';
                };
                /**
                 * Returns the type of icon to be displayed.
                 * @param {?} index
                 * @param {?=} state
                 * @return {?}
                 */
                CdkStepper.prototype._getIndicatorType = function (index, state) {
                    if (state === void 0) { state = STEP_STATE.NUMBER; }
                    /** @type {?} */
                    var step = this.steps.toArray()[index];
                    /** @type {?} */
                    var isCurrentStep = this._isCurrentStep(index);
                    return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) :
                        this._getGuidelineLogic(step, isCurrentStep, state);
                };
                /**
                 * @private
                 * @param {?} step
                 * @param {?} isCurrentStep
                 * @return {?}
                 */
                CdkStepper.prototype._getDefaultIndicatorLogic = function (step, isCurrentStep) {
                    if (step._showError && step.hasError && !isCurrentStep) {
                        return STEP_STATE.ERROR;
                    }
                    else if (!step.completed || isCurrentStep) {
                        return STEP_STATE.NUMBER;
                    }
                    else {
                        return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
                    }
                };
                /**
                 * @private
                 * @param {?} step
                 * @param {?} isCurrentStep
                 * @param {?=} state
                 * @return {?}
                 */
                CdkStepper.prototype._getGuidelineLogic = function (step, isCurrentStep, state) {
                    if (state === void 0) { state = STEP_STATE.NUMBER; }
                    if (step._showError && step.hasError && !isCurrentStep) {
                        return STEP_STATE.ERROR;
                    }
                    else if (step.completed && !isCurrentStep) {
                        return STEP_STATE.DONE;
                    }
                    else if (step.completed && isCurrentStep) {
                        return state;
                    }
                    else if (step.editable && isCurrentStep) {
                        return STEP_STATE.EDIT;
                    }
                    else {
                        return state;
                    }
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._isCurrentStep = function (index) {
                    return this._selectedIndex === index;
                };
                /**
                 * Returns the index of the currently-focused step header.
                 * @return {?}
                 */
                CdkStepper.prototype._getFocusIndex = function () {
                    return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
                };
                /**
                 * @private
                 * @param {?} newIndex
                 * @return {?}
                 */
                CdkStepper.prototype._updateSelectedItemIndex = function (newIndex) {
                    /** @type {?} */
                    var stepsArray = this.steps.toArray();
                    this.selectionChange.emit({
                        selectedIndex: newIndex,
                        previouslySelectedIndex: this._selectedIndex,
                        selectedStep: stepsArray[newIndex],
                        previouslySelectedStep: stepsArray[this._selectedIndex],
                    });
                    // If focus is inside the stepper, move it to the next header, otherwise it may become
                    // lost when the active step content is hidden. We can't be more granular with the check
                    // (e.g. checking whether focus is inside the active step), because we don't have a
                    // reference to the elements that are rendering out the content.
                    this._containsFocus() ? this._keyManager.setActiveItem(newIndex) :
                        this._keyManager.updateActiveItemIndex(newIndex);
                    this._selectedIndex = newIndex;
                    this._stateChanged();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                CdkStepper.prototype._onKeydown = function (event) {
                    /** @type {?} */
                    var hasModifier = Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["hasModifierKey"])(event);
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    if (manager.activeItemIndex != null && !hasModifier &&
                        (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["SPACE"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ENTER"])) {
                        this.selectedIndex = manager.activeItemIndex;
                        event.preventDefault();
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["HOME"]) {
                        manager.setFirstItemActive();
                        event.preventDefault();
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["END"]) {
                        manager.setLastItemActive();
                        event.preventDefault();
                    }
                    else {
                        manager.onKeydown(event);
                    }
                };
                /**
                 * @private
                 * @param {?} index
                 * @return {?}
                 */
                CdkStepper.prototype._anyControlsInvalidOrPending = function (index) {
                    /** @type {?} */
                    var steps = this.steps.toArray();
                    steps[this._selectedIndex].interacted = true;
                    if (this._linear && index >= 0) {
                        return steps.slice(0, index).some(( /**
                         * @param {?} step
                         * @return {?}
                         */function (/**
                         * @param {?} step
                         * @return {?}
                         */ step) {
                            /** @type {?} */
                            var control = step.stepControl;
                            /** @type {?} */
                            var isIncomplete = control ? (control.invalid || control.pending || !step.interacted) : !step.completed;
                            return isIncomplete && !step.optional && !step._completedOverride;
                        }));
                    }
                    return false;
                };
                /**
                 * @private
                 * @return {?}
                 */
                CdkStepper.prototype._layoutDirection = function () {
                    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                };
                /**
                 * Checks whether the stepper contains the focused element.
                 * @private
                 * @return {?}
                 */
                CdkStepper.prototype._containsFocus = function () {
                    if (!this._document || !this._elementRef) {
                        return false;
                    }
                    /** @type {?} */
                    var stepperElement = this._elementRef.nativeElement;
                    /** @type {?} */
                    var focusedElement = this._document.activeElement;
                    return stepperElement === focusedElement || stepperElement.contains(focusedElement);
                };
                return CdkStepper;
            }());
            CdkStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[cdkStepper]',
                            exportAs: 'cdkStepper',
                        },] },
            ];
            /** @nocollapse */
            CdkStepper.ctorParameters = function () { return [
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"],] }] }
            ]; };
            CdkStepper.propDecorators = {
                _steps: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [CdkStep,] }],
                _stepHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [CdkStepHeader,] }],
                linear: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Button that moves to the next step in a stepper workflow.
             */
            var CdkStepperNext = /** @class */ (function () {
                /**
                 * @param {?} _stepper
                 */
                function CdkStepperNext(_stepper) {
                    this._stepper = _stepper;
                    /**
                     * Type of the next button. Defaults to "submit" if not specified.
                     */
                    this.type = 'submit';
                }
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @return {?}
                 */
                CdkStepperNext.prototype._handleClick = function () {
                    this._stepper.next();
                };
                return CdkStepperNext;
            }());
            CdkStepperNext.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[cdkStepperNext]',
                            host: {
                                '[type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            CdkStepperNext.ctorParameters = function () { return [
                { type: CdkStepper }
            ]; };
            CdkStepperNext.propDecorators = {
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _handleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"], args: ['click',] }]
            };
            /**
             * Button that moves to the previous step in a stepper workflow.
             */
            var CdkStepperPrevious = /** @class */ (function () {
                /**
                 * @param {?} _stepper
                 */
                function CdkStepperPrevious(_stepper) {
                    this._stepper = _stepper;
                    /**
                     * Type of the previous button. Defaults to "button" if not specified.
                     */
                    this.type = 'button';
                }
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @return {?}
                 */
                CdkStepperPrevious.prototype._handleClick = function () {
                    this._stepper.previous();
                };
                return CdkStepperPrevious;
            }());
            CdkStepperPrevious.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[cdkStepperPrevious]',
                            host: {
                                '[type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            CdkStepperPrevious.ctorParameters = function () { return [
                { type: CdkStepper }
            ]; };
            CdkStepperPrevious.propDecorators = {
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _handleClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"], args: ['click',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var CdkStepperModule = /** @class */ (function () {
                function CdkStepperModule() {
                }
                return CdkStepperModule;
            }());
            CdkStepperModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["BidiModule"], _angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
                            exports: [
                                CdkStep,
                                CdkStepper,
                                CdkStepHeader,
                                CdkStepLabel,
                                CdkStepperNext,
                                CdkStepperPrevious,
                            ],
                            declarations: [
                                CdkStep,
                                CdkStepper,
                                CdkStepHeader,
                                CdkStepLabel,
                                CdkStepperNext,
                                CdkStepperPrevious,
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=stepper.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/table.js": 
        /*!****************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/table.js ***!
          \****************************************************/
        /*! exports provided: DataSource, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CDK_TABLE_TEMPLATE, CdkTable, CdkCellDef, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, BaseCdkCell, CdkHeaderCell, CdkFooterCell, CdkCell, CDK_ROW_TEMPLATE, BaseRowDef, CdkHeaderRowDef, CdkFooterRowDef, CdkRowDef, CdkCellOutlet, CdkHeaderRow, CdkFooterRow, CdkRow, CdkTableModule, STICKY_DIRECTIONS, StickyStyler, mixinHasStickyInput, TEXT_COLUMN_OPTIONS, CdkTextColumn */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataRowOutlet", function () { return DataRowOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HeaderRowOutlet", function () { return HeaderRowOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FooterRowOutlet", function () { return FooterRowOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CDK_TABLE_TEMPLATE", function () { return CDK_TABLE_TEMPLATE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTable", function () { return CdkTable; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkCellDef", function () { return CdkCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderCellDef", function () { return CdkHeaderCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterCellDef", function () { return CdkFooterCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkColumnDef", function () { return CdkColumnDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseCdkCell", function () { return BaseCdkCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderCell", function () { return CdkHeaderCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterCell", function () { return CdkFooterCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkCell", function () { return CdkCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CDK_ROW_TEMPLATE", function () { return CDK_ROW_TEMPLATE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseRowDef", function () { return BaseRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderRowDef", function () { return CdkHeaderRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterRowDef", function () { return CdkFooterRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkRowDef", function () { return CdkRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkCellOutlet", function () { return CdkCellOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkHeaderRow", function () { return CdkHeaderRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkFooterRow", function () { return CdkFooterRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkRow", function () { return CdkRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTableModule", function () { return CdkTableModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STICKY_DIRECTIONS", function () { return STICKY_DIRECTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StickyStyler", function () { return StickyStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mixinHasStickyInput", function () { return mixinHasStickyInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_COLUMN_OPTIONS", function () { return TEXT_COLUMN_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTextColumn", function () { return CdkTextColumn; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataSource", function () { return _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["DataSource"]; });
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Mixin to provide a directive with a function that checks if the sticky input has been
             * changed since the last time the function was called. Essentially adds a dirty-check to the
             * sticky value.
             * \@docs-private
             * @template T
             * @param {?} base
             * @return {?}
             */
            function mixinHasStickyInput(base) {
                return /** @class */ (function (_super) {
                    __extends(class_1, _super);
                    /**
                     * @param {...?} args
                     */
                    function class_1() {
                        var args = [];
                        for (var _a = 0; _a < arguments.length; _a++) {
                            args[_a] = arguments[_a];
                        }
                        var _this = _super.apply(this, __spread(args)) || this;
                        _this._sticky = false;
                        /**
                         * Whether the sticky input has changed since it was last checked.
                         */
                        _this._hasStickyChanged = false;
                        return _this;
                    }
                    Object.defineProperty(class_1.prototype, "sticky", {
                        /**
                         * Whether sticky positioning should be applied.
                         * @return {?}
                         */
                        get: function () { return this._sticky; },
                        /**
                         * @param {?} v
                         * @return {?}
                         */
                        set: function (v) {
                            /** @type {?} */
                            var prevValue = this._sticky;
                            this._sticky = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
                            this._hasStickyChanged = prevValue !== this._sticky;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Whether the sticky value has changed since this was last called.
                     * @return {?}
                     */
                    class_1.prototype.hasStickyChanged = function () {
                        /** @type {?} */
                        var hasStickyChanged = this._hasStickyChanged;
                        this._hasStickyChanged = false;
                        return hasStickyChanged;
                    };
                    /**
                     * Resets the dirty check for cases where the sticky state has been used without checking.
                     * @return {?}
                     */
                    class_1.prototype.resetStickyChanged = function () {
                        this._hasStickyChanged = false;
                    };
                    return class_1;
                }(base));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Cell definition for a CDK table.
             * Captures the template of a column's data row cell as well as cell-specific properties.
             */
            var CdkCellDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkCellDef(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkCellDef;
            }());
            CdkCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkCellDef]' },] },
            ];
            /** @nocollapse */
            CdkCellDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
            ]; };
            /**
             * Header cell definition for a CDK table.
             * Captures the template of a column's header cell and as well as cell-specific properties.
             */
            var CdkHeaderCellDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkHeaderCellDef(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkHeaderCellDef;
            }());
            CdkHeaderCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkHeaderCellDef]' },] },
            ];
            /** @nocollapse */
            CdkHeaderCellDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
            ]; };
            /**
             * Footer cell definition for a CDK table.
             * Captures the template of a column's footer cell and as well as cell-specific properties.
             */
            var CdkFooterCellDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 */
                function CdkFooterCellDef(/** @docs-private */ template) {
                    this.template = template;
                }
                return CdkFooterCellDef;
            }());
            CdkFooterCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkFooterCellDef]' },] },
            ];
            /** @nocollapse */
            CdkFooterCellDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] }
            ]; };
            // Boilerplate for applying mixins to CdkColumnDef.
            /**
             * \@docs-private
             */
            var CdkColumnDefBase = /** @class */ (function () {
                function CdkColumnDefBase() {
                }
                return CdkColumnDefBase;
            }());
            /** @type {?} */
            var _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);
            /**
             * Column definition for the CDK table.
             * Defines a set of cells available for a table column.
             */
            var CdkColumnDef = /** @class */ (function (_super) {
                __extends(CdkColumnDef, _super);
                function CdkColumnDef() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    _this._stickyEnd = false;
                    return _this;
                }
                Object.defineProperty(CdkColumnDef.prototype, "name", {
                    /**
                     * Unique name for this column.
                     * @return {?}
                     */
                    get: function () {
                        return this._name;
                    },
                    /**
                     * @param {?} name
                     * @return {?}
                     */
                    set: function (name) {
                        // If the directive is set without a name (updated programatically), then this setter will
                        // trigger with an empty string and should not overwrite the programatically set value.
                        if (!name) {
                            return;
                        }
                        this._name = name;
                        this.cssClassFriendlyName = name.replace(/[^a-z0-9_-]/ig, '-');
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkColumnDef.prototype, "stickyEnd", {
                    /**
                     * Whether this column should be sticky positioned on the end of the row. Should make sure
                     * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
                     * has been changed.
                     * @return {?}
                     */
                    get: function () {
                        return this._stickyEnd;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        /** @type {?} */
                        var prevValue = this._stickyEnd;
                        this._stickyEnd = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
                        this._hasStickyChanged = prevValue !== this._stickyEnd;
                    },
                    enumerable: true,
                    configurable: true
                });
                return CdkColumnDef;
            }(_CdkColumnDefBase));
            CdkColumnDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkColumnDef]',
                            inputs: ['sticky'],
                            providers: [{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }],
                        },] },
            ];
            CdkColumnDef.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['cdkColumnDef',] }],
                stickyEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['stickyEnd',] }],
                cell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [CdkCellDef, { static: false },] }],
                headerCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [CdkHeaderCellDef, { static: false },] }],
                footerCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChild"], args: [CdkFooterCellDef, { static: false },] }]
            };
            /**
             * Base class for the cells. Adds a CSS classname that identifies the column it renders in.
             */
            var BaseCdkCell = /** @class */ (function () {
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function BaseCdkCell(columnDef, elementRef) {
                    /** @type {?} */
                    var columnClassName = "cdk-column-" + columnDef.cssClassFriendlyName;
                    elementRef.nativeElement.classList.add(columnClassName);
                }
                return BaseCdkCell;
            }());
            /**
             * Header cell template container that adds the right classes and role.
             */
            var CdkHeaderCell = /** @class */ (function (_super) {
                __extends(CdkHeaderCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function CdkHeaderCell(columnDef, elementRef) {
                    return _super.call(this, columnDef, elementRef) || this;
                }
                return CdkHeaderCell;
            }(BaseCdkCell));
            CdkHeaderCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-header-cell, th[cdk-header-cell]',
                            host: {
                                'class': 'cdk-header-cell',
                                'role': 'columnheader',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkHeaderCell.ctorParameters = function () { return [
                { type: CdkColumnDef },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Footer cell template container that adds the right classes and role.
             */
            var CdkFooterCell = /** @class */ (function (_super) {
                __extends(CdkFooterCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function CdkFooterCell(columnDef, elementRef) {
                    return _super.call(this, columnDef, elementRef) || this;
                }
                return CdkFooterCell;
            }(BaseCdkCell));
            CdkFooterCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-footer-cell, td[cdk-footer-cell]',
                            host: {
                                'class': 'cdk-footer-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkFooterCell.ctorParameters = function () { return [
                { type: CdkColumnDef },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Cell template container that adds the right classes and role.
             */
            var CdkCell = /** @class */ (function (_super) {
                __extends(CdkCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function CdkCell(columnDef, elementRef) {
                    return _super.call(this, columnDef, elementRef) || this;
                }
                return CdkCell;
            }(BaseCdkCell));
            CdkCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'cdk-cell, td[cdk-cell]',
                            host: {
                                'class': 'cdk-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkCell.ctorParameters = function () { return [
                { type: CdkColumnDef },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The row template that can be used by the mat-table. Should not be used outside of the
             * material library.
             * @type {?}
             */
            var CDK_ROW_TEMPLATE = "<ng-container cdkCellOutlet></ng-container>";
            /**
             * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs
             * for changes and notifying the table.
             * @abstract
             */
            var BaseRowDef = /** @class */ (function () {
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function BaseRowDef(template, _differs) {
                    this.template = template;
                    this._differs = _differs;
                }
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                BaseRowDef.prototype.ngOnChanges = function (changes) {
                    // Create a new columns differ if one does not yet exist. Initialize it based on initial value
                    // of the columns property or an empty array if none is provided.
                    if (!this._columnsDiffer) {
                        /** @type {?} */
                        var columns = (changes['columns'] && changes['columns'].currentValue) || [];
                        this._columnsDiffer = this._differs.find(columns).create();
                        this._columnsDiffer.diff(columns);
                    }
                };
                /**
                 * Returns the difference between the current columns and the columns from the last diff, or null
                 * if there is no difference.
                 * @return {?}
                 */
                BaseRowDef.prototype.getColumnsDiff = function () {
                    return this._columnsDiffer.diff(this.columns);
                };
                /**
                 * Gets this row def's relevant cell template from the provided column def.
                 * @param {?} column
                 * @return {?}
                 */
                BaseRowDef.prototype.extractCellTemplate = function (column) {
                    if (this instanceof CdkHeaderRowDef) {
                        return column.headerCell.template;
                    }
                    if (this instanceof CdkFooterRowDef) {
                        return column.footerCell.template;
                    }
                    else {
                        return column.cell.template;
                    }
                };
                return BaseRowDef;
            }());
            // Boilerplate for applying mixins to CdkHeaderRowDef.
            /**
             * \@docs-private
             */
            var CdkHeaderRowDefBase = /** @class */ (function (_super) {
                __extends(CdkHeaderRowDefBase, _super);
                function CdkHeaderRowDefBase() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return CdkHeaderRowDefBase;
            }(BaseRowDef));
            /** @type {?} */
            var _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);
            /**
             * Header row definition for the CDK table.
             * Captures the header row's template and other header properties such as the columns to display.
             */
            var CdkHeaderRowDef = /** @class */ (function (_super) {
                __extends(CdkHeaderRowDef, _super);
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function CdkHeaderRowDef(template, _differs) {
                    return _super.call(this, template, _differs) || this;
                }
                // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
                // Explicitly define it so that the method is called as part of the Angular lifecycle.
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkHeaderRowDef.prototype.ngOnChanges = function (changes) {
                    _super.prototype.ngOnChanges.call(this, changes);
                };
                return CdkHeaderRowDef;
            }(_CdkHeaderRowDefBase));
            CdkHeaderRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkHeaderRowDef]',
                            inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky'],
                        },] },
            ];
            /** @nocollapse */
            CdkHeaderRowDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] }
            ]; };
            // Boilerplate for applying mixins to CdkFooterRowDef.
            /**
             * \@docs-private
             */
            var CdkFooterRowDefBase = /** @class */ (function (_super) {
                __extends(CdkFooterRowDefBase, _super);
                function CdkFooterRowDefBase() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return CdkFooterRowDefBase;
            }(BaseRowDef));
            /** @type {?} */
            var _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);
            /**
             * Footer row definition for the CDK table.
             * Captures the footer row's template and other footer properties such as the columns to display.
             */
            var CdkFooterRowDef = /** @class */ (function (_super) {
                __extends(CdkFooterRowDef, _super);
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function CdkFooterRowDef(template, _differs) {
                    return _super.call(this, template, _differs) || this;
                }
                // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
                // Explicitly define it so that the method is called as part of the Angular lifecycle.
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                CdkFooterRowDef.prototype.ngOnChanges = function (changes) {
                    _super.prototype.ngOnChanges.call(this, changes);
                };
                return CdkFooterRowDef;
            }(_CdkFooterRowDefBase));
            CdkFooterRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkFooterRowDef]',
                            inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky'],
                        },] },
            ];
            /** @nocollapse */
            CdkFooterRowDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] }
            ]; };
            /**
             * Data row definition for the CDK table.
             * Captures the header row's template and other row properties such as the columns to display and
             * a when predicate that describes when this row should be used.
             * @template T
             */
            var CdkRowDef = /** @class */ (function (_super) {
                __extends(CdkRowDef, _super);
                // TODO(andrewseguin): Add an input for providing a switch function to determine
                //   if this template should be used.
                /**
                 * @param {?} template
                 * @param {?} _differs
                 */
                function CdkRowDef(template, _differs) {
                    return _super.call(this, template, _differs) || this;
                }
                return CdkRowDef;
            }(BaseRowDef));
            CdkRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[cdkRowDef]',
                            inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen'],
                        },] },
            ];
            /** @nocollapse */
            CdkRowDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] }
            ]; };
            /**
             * Outlet for rendering cells inside of a row or header row.
             * \@docs-private
             */
            var CdkCellOutlet = /** @class */ (function () {
                /**
                 * @param {?} _viewContainer
                 */
                function CdkCellOutlet(_viewContainer) {
                    this._viewContainer = _viewContainer;
                    CdkCellOutlet.mostRecentCellOutlet = this;
                }
                /**
                 * @return {?}
                 */
                CdkCellOutlet.prototype.ngOnDestroy = function () {
                    // If this was the last outlet being rendered in the view, remove the reference
                    // from the static property after it has been destroyed to avoid leaking memory.
                    if (CdkCellOutlet.mostRecentCellOutlet === this) {
                        CdkCellOutlet.mostRecentCellOutlet = null;
                    }
                };
                return CdkCellOutlet;
            }());
            /**
             * Static property containing the latest constructed instance of this class.
             * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using
             * createEmbeddedView. After one of these components are created, this property will provide
             * a handle to provide that component's cells and context. After init, the CdkCellOutlet will
             * construct the cells with the provided context.
             */
            CdkCellOutlet.mostRecentCellOutlet = null;
            CdkCellOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[cdkCellOutlet]' },] },
            ];
            /** @nocollapse */
            CdkCellOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] }
            ]; };
            /**
             * Header template container that contains the cell outlet. Adds the right class and role.
             */
            var CdkHeaderRow = /** @class */ (function () {
                function CdkHeaderRow() {
                }
                return CdkHeaderRow;
            }());
            CdkHeaderRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-header-row, tr[cdk-header-row]',
                            template: CDK_ROW_TEMPLATE,
                            host: {
                                'class': 'cdk-header-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                        },] },
            ];
            /**
             * Footer template container that contains the cell outlet. Adds the right class and role.
             */
            var CdkFooterRow = /** @class */ (function () {
                function CdkFooterRow() {
                }
                return CdkFooterRow;
            }());
            CdkFooterRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-footer-row, tr[cdk-footer-row]',
                            template: CDK_ROW_TEMPLATE,
                            host: {
                                'class': 'cdk-footer-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                        },] },
            ];
            /**
             * Data row template container that contains the cell outlet. Adds the right class and role.
             */
            var CdkRow = /** @class */ (function () {
                function CdkRow() {
                }
                return CdkRow;
            }());
            CdkRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-row, tr[cdk-row]',
                            template: CDK_ROW_TEMPLATE,
                            host: {
                                'class': 'cdk-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * List of all possible directions that can be used for sticky positioning.
             * \@docs-private
             * @type {?}
             */
            var STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];
            /**
             * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.
             * \@docs-private
             */
            var StickyStyler = /** @class */ (function () {
                /**
                 * @param {?} _isNativeHtmlTable Whether the sticky logic should be based on a table
                 *     that uses the native `<table>` element.
                 * @param {?} _stickCellCss The CSS class that will be applied to every row/cell that has
                 *     sticky positioning applied.
                 * @param {?} direction The directionality context of the table (ltr/rtl); affects column positioning
                 *     by reversing left/right positions.
                 * @param {?=} _isBrowser Whether the table is currently being rendered on the server or the client.
                 */
                function StickyStyler(_isNativeHtmlTable, _stickCellCss, direction, _isBrowser) {
                    if (_isBrowser === void 0) { _isBrowser = true; }
                    this._isNativeHtmlTable = _isNativeHtmlTable;
                    this._stickCellCss = _stickCellCss;
                    this.direction = direction;
                    this._isBrowser = _isBrowser;
                }
                /**
                 * Clears the sticky positioning styles from the row and its cells by resetting the `position`
                 * style, setting the zIndex to 0, and unsetting each provided sticky direction.
                 * @param {?} rows The list of rows that should be cleared from sticking in the provided directions
                 * @param {?} stickyDirections The directions that should no longer be set as sticky on the rows.
                 * @return {?}
                 */
                StickyStyler.prototype.clearStickyPositioning = function (rows, stickyDirections) {
                    var e_1, _a;
                    try {
                        for (var rows_1 = __values(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {
                            var row = rows_1_1.value;
                            // If the row isn't an element (e.g. if it's an `ng-container`),
                            // it won't have inline styles or `children` so we skip it.
                            if (row.nodeType !== row.ELEMENT_NODE) {
                                continue;
                            }
                            this._removeStickyStyle(row, stickyDirections);
                            for (var i = 0; i < row.children.length; i++) {
                                /** @type {?} */
                                var cell = ( /** @type {?} */(row.children[i]));
                                this._removeStickyStyle(cell, stickyDirections);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return)) _a.call(rows_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                };
                /**
                 * Applies sticky left and right positions to the cells of each row according to the sticky
                 * states of the rendered column definitions.
                 * @param {?} rows The rows that should have its set of cells stuck according to the sticky states.
                 * @param {?} stickyStartStates A list of boolean states where each state represents whether the cell
                 *     in this index position should be stuck to the start of the row.
                 * @param {?} stickyEndStates A list of boolean states where each state represents whether the cell
                 *     in this index position should be stuck to the end of the row.
                 * @return {?}
                 */
                StickyStyler.prototype.updateStickyColumns = function (rows, stickyStartStates, stickyEndStates) {
                    var e_2, _a;
                    /** @type {?} */
                    var hasStickyColumns = stickyStartStates.some(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state) { return state; })) || stickyEndStates.some(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state) { return state; }));
                    if (!rows.length || !hasStickyColumns || !this._isBrowser) {
                        return;
                    }
                    /** @type {?} */
                    var firstRow = rows[0];
                    /** @type {?} */
                    var numCells = firstRow.children.length;
                    /** @type {?} */
                    var cellWidths = this._getCellWidths(firstRow);
                    /** @type {?} */
                    var startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
                    /** @type {?} */
                    var endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
                    /** @type {?} */
                    var isRtl = this.direction === 'rtl';
                    try {
                        for (var rows_2 = __values(rows), rows_2_1 = rows_2.next(); !rows_2_1.done; rows_2_1 = rows_2.next()) {
                            var row = rows_2_1.value;
                            for (var i = 0; i < numCells; i++) {
                                /** @type {?} */
                                var cell = ( /** @type {?} */(row.children[i]));
                                if (stickyStartStates[i]) {
                                    this._addStickyStyle(cell, isRtl ? 'right' : 'left', startPositions[i]);
                                }
                                if (stickyEndStates[i]) {
                                    this._addStickyStyle(cell, isRtl ? 'left' : 'right', endPositions[i]);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (rows_2_1 && !rows_2_1.done && (_a = rows_2.return)) _a.call(rows_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                };
                /**
                 * Applies sticky positioning to the row's cells if using the native table layout, and to the
                 * row itself otherwise.
                 * @param {?} rowsToStick The list of rows that should be stuck according to their corresponding
                 *     sticky state and to the provided top or bottom position.
                 * @param {?} stickyStates A list of boolean states where each state represents whether the row
                 *     should be stuck in the particular top or bottom position.
                 * @param {?} position The position direction in which the row should be stuck if that row should be
                 *     sticky.
                 *
                 * @return {?}
                 */
                StickyStyler.prototype.stickRows = function (rowsToStick, stickyStates, position) {
                    // Since we can't measure the rows on the server, we can't stick the rows properly.
                    if (!this._isBrowser) {
                        return;
                    }
                    // If positioning the rows to the bottom, reverse their order when evaluating the sticky
                    // position such that the last row stuck will be "bottom: 0px" and so on.
                    /** @type {?} */
                    var rows = position === 'bottom' ? rowsToStick.reverse() : rowsToStick;
                    /** @type {?} */
                    var stickyHeight = 0;
                    for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                        if (!stickyStates[rowIndex]) {
                            continue;
                        }
                        /** @type {?} */
                        var row = rows[rowIndex];
                        if (this._isNativeHtmlTable) {
                            for (var j = 0; j < row.children.length; j++) {
                                /** @type {?} */
                                var cell = ( /** @type {?} */(row.children[j]));
                                this._addStickyStyle(cell, position, stickyHeight);
                            }
                        }
                        else {
                            // Flex does not respect the stick positioning on the cells, needs to be applied to the row.
                            // If this is applied on a native table, Safari causes the header to fly in wrong direction.
                            this._addStickyStyle(row, position, stickyHeight);
                        }
                        if (rowIndex === rows.length - 1) {
                            // prevent unnecessary reflow from getBoundingClientRect()
                            return;
                        }
                        stickyHeight += row.getBoundingClientRect().height;
                    }
                };
                /**
                 * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
                 * footer rows is to apply sticky styling to the tfoot container. This should only be done if
                 * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
                 * the tfoot element.
                 * @param {?} tableElement
                 * @param {?} stickyStates
                 * @return {?}
                 */
                StickyStyler.prototype.updateStickyFooterContainer = function (tableElement, stickyStates) {
                    if (!this._isNativeHtmlTable) {
                        return;
                    }
                    /** @type {?} */
                    var tfoot = ( /** @type {?} */(tableElement.querySelector('tfoot')));
                    if (stickyStates.some(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state) { return !state; }))) {
                        this._removeStickyStyle(tfoot, ['bottom']);
                    }
                    else {
                        this._addStickyStyle(tfoot, 'bottom', 0);
                    }
                };
                /**
                 * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
                 * the zIndex, removing each of the provided sticky directions, and removing the
                 * sticky position if there are no more directions.
                 * @param {?} element
                 * @param {?} stickyDirections
                 * @return {?}
                 */
                StickyStyler.prototype._removeStickyStyle = function (element, stickyDirections) {
                    var e_3, _a;
                    try {
                        for (var stickyDirections_1 = __values(stickyDirections), stickyDirections_1_1 = stickyDirections_1.next(); !stickyDirections_1_1.done; stickyDirections_1_1 = stickyDirections_1.next()) {
                            var dir = stickyDirections_1_1.value;
                            element.style[dir] = '';
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (stickyDirections_1_1 && !stickyDirections_1_1.done && (_a = stickyDirections_1.return)) _a.call(stickyDirections_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    element.style.zIndex = this._getCalculatedZIndex(element);
                    // If the element no longer has any more sticky directions, remove sticky positioning and
                    // the sticky CSS class.
                    /** @type {?} */
                    var hasDirection = STICKY_DIRECTIONS.some(( /**
                     * @param {?} dir
                     * @return {?}
                     */function (/**
                     * @param {?} dir
                     * @return {?}
                     */ dir) { return !!element.style[dir]; }));
                    if (!hasDirection) {
                        element.style.position = '';
                        element.classList.remove(this._stickCellCss);
                    }
                };
                /**
                 * Adds the sticky styling to the element by adding the sticky style class, changing position
                 * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
                 * direction and value.
                 * @param {?} element
                 * @param {?} dir
                 * @param {?} dirValue
                 * @return {?}
                 */
                StickyStyler.prototype._addStickyStyle = function (element, dir, dirValue) {
                    element.classList.add(this._stickCellCss);
                    element.style[dir] = dirValue + "px";
                    element.style.cssText += 'position: -webkit-sticky; position: sticky; ';
                    element.style.zIndex = this._getCalculatedZIndex(element);
                };
                /**
                 * Calculate what the z-index should be for the element, depending on what directions (top,
                 * bottom, left, right) have been set. It should be true that elements with a top direction
                 * should have the highest index since these are elements like a table header. If any of those
                 * elements are also sticky in another direction, then they should appear above other elements
                 * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
                 * (e.g. footer rows) should then be next in the ordering such that they are below the header
                 * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
                 * should minimally increment so that they are above non-sticky elements but below top and bottom
                 * elements.
                 * @param {?} element
                 * @return {?}
                 */
                StickyStyler.prototype._getCalculatedZIndex = function (element) {
                    var e_4, _a;
                    /** @type {?} */
                    var zIndexIncrements = {
                        top: 100,
                        bottom: 10,
                        left: 1,
                        right: 1,
                    };
                    /** @type {?} */
                    var zIndex = 0;
                    try {
                        for (var STICKY_DIRECTIONS_1 = __values(STICKY_DIRECTIONS), STICKY_DIRECTIONS_1_1 = STICKY_DIRECTIONS_1.next(); !STICKY_DIRECTIONS_1_1.done; STICKY_DIRECTIONS_1_1 = STICKY_DIRECTIONS_1.next()) {
                            var dir = STICKY_DIRECTIONS_1_1.value;
                            if (element.style[dir]) {
                                zIndex += zIndexIncrements[dir];
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (STICKY_DIRECTIONS_1_1 && !STICKY_DIRECTIONS_1_1.done && (_a = STICKY_DIRECTIONS_1.return)) _a.call(STICKY_DIRECTIONS_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    return zIndex ? "" + zIndex : '';
                };
                /**
                 * Gets the widths for each cell in the provided row.
                 * @param {?} row
                 * @return {?}
                 */
                StickyStyler.prototype._getCellWidths = function (row) {
                    /** @type {?} */
                    var cellWidths = [];
                    /** @type {?} */
                    var firstRowCells = row.children;
                    for (var i = 0; i < firstRowCells.length; i++) {
                        /** @type {?} */
                        var cell = ( /** @type {?} */(firstRowCells[i]));
                        cellWidths.push(cell.getBoundingClientRect().width);
                    }
                    return cellWidths;
                };
                /**
                 * Determines the left and right positions of each sticky column cell, which will be the
                 * accumulation of all sticky column cell widths to the left and right, respectively.
                 * Non-sticky cells do not need to have a value set since their positions will not be applied.
                 * @param {?} widths
                 * @param {?} stickyStates
                 * @return {?}
                 */
                StickyStyler.prototype._getStickyStartColumnPositions = function (widths, stickyStates) {
                    /** @type {?} */
                    var positions = [];
                    /** @type {?} */
                    var nextPosition = 0;
                    for (var i = 0; i < widths.length; i++) {
                        if (stickyStates[i]) {
                            positions[i] = nextPosition;
                            nextPosition += widths[i];
                        }
                    }
                    return positions;
                };
                /**
                 * Determines the left and right positions of each sticky column cell, which will be the
                 * accumulation of all sticky column cell widths to the left and right, respectively.
                 * Non-sticky cells do not need to have a value set since their positions will not be applied.
                 * @param {?} widths
                 * @param {?} stickyStates
                 * @return {?}
                 */
                StickyStyler.prototype._getStickyEndColumnPositions = function (widths, stickyStates) {
                    /** @type {?} */
                    var positions = [];
                    /** @type {?} */
                    var nextPosition = 0;
                    for (var i = widths.length; i > 0; i--) {
                        if (stickyStates[i]) {
                            positions[i] = nextPosition;
                            nextPosition += widths[i];
                        }
                    }
                    return positions;
                };
                return StickyStyler;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Returns an error to be thrown when attempting to find an unexisting column.
             * \@docs-private
             * @param {?} id Id whose lookup failed.
             * @return {?}
             */
            function getTableUnknownColumnError(id) {
                return Error("Could not find column with id \"" + id + "\".");
            }
            /**
             * Returns an error to be thrown when two column definitions have the same name.
             * \@docs-private
             * @param {?} name
             * @return {?}
             */
            function getTableDuplicateColumnNameError(name) {
                return Error("Duplicate column definition name provided: \"" + name + "\".");
            }
            /**
             * Returns an error to be thrown when there are multiple rows that are missing a when function.
             * \@docs-private
             * @return {?}
             */
            function getTableMultipleDefaultRowDefsError() {
                return Error("There can only be one default row without a when predicate function.");
            }
            /**
             * Returns an error to be thrown when there are no matching row defs for a particular set of data.
             * \@docs-private
             * @param {?} data
             * @return {?}
             */
            function getTableMissingMatchingRowDefError(data) {
                return Error("Could not find a matching row definition for the" +
                    ("provided row data: " + JSON.stringify(data)));
            }
            /**
             * Returns an error to be thrown when there is no row definitions present in the content.
             * \@docs-private
             * @return {?}
             */
            function getTableMissingRowDefsError() {
                return Error('Missing definitions for header, footer, and row; ' +
                    'cannot determine which columns should be rendered.');
            }
            /**
             * Returns an error to be thrown when the data source does not match the compatible types.
             * \@docs-private
             * @return {?}
             */
            function getTableUnknownDataSourceError() {
                return Error("Provided data source did not match an array, Observable, or DataSource");
            }
            /**
             * Returns an error to be thrown when the text column cannot find a parent table to inject.
             * \@docs-private
             * @return {?}
             */
            function getTableTextColumnMissingParentTableError() {
                return Error("Text column could not find a parent table for registration.");
            }
            /**
             * Returns an error to be thrown when a table text column doesn't have a name.
             * \@docs-private
             * @return {?}
             */
            function getTableTextColumnMissingNameError() {
                return Error("Table text column must have a name.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Provides a handle for the table to grab the view container's ng-container to insert data rows.
             * \@docs-private
             */
            var DataRowOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?} elementRef
                 */
                function DataRowOutlet(viewContainer, elementRef) {
                    this.viewContainer = viewContainer;
                    this.elementRef = elementRef;
                }
                return DataRowOutlet;
            }());
            DataRowOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[rowOutlet]' },] },
            ];
            /** @nocollapse */
            DataRowOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Provides a handle for the table to grab the view container's ng-container to insert the header.
             * \@docs-private
             */
            var HeaderRowOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?} elementRef
                 */
                function HeaderRowOutlet(viewContainer, elementRef) {
                    this.viewContainer = viewContainer;
                    this.elementRef = elementRef;
                }
                return HeaderRowOutlet;
            }());
            HeaderRowOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[headerRowOutlet]' },] },
            ];
            /** @nocollapse */
            HeaderRowOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Provides a handle for the table to grab the view container's ng-container to insert the footer.
             * \@docs-private
             */
            var FooterRowOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?} elementRef
                 */
                function FooterRowOutlet(viewContainer, elementRef) {
                    this.viewContainer = viewContainer;
                    this.elementRef = elementRef;
                }
                return FooterRowOutlet;
            }());
            FooterRowOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{ selector: '[footerRowOutlet]' },] },
            ];
            /** @nocollapse */
            FooterRowOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * The table template that can be used by the mat-table. Should not be used outside of the
             * material library.
             * \@docs-private
             * @type {?}
             */
            var CDK_TABLE_TEMPLATE = 
            // Note that according to MDN, the `caption` element has to be projected as the **first**
            // element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
            "\n  <ng-content select=\"caption\"></ng-content>\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>\n";
            /**
             * A data table that can render a header row, data rows, and a footer row.
             * Uses the dataSource input to determine the data to be rendered. The data can be provided either
             * as a data array, an Observable stream that emits the data array to render, or a DataSource with a
             * connect function that will return an Observable stream that emits the data array to render.
             * @template T
             */
            var CdkTable = /** @class */ (function () {
                /**
                 * @param {?} _differs
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} role
                 * @param {?} _dir
                 * @param {?} _document
                 * @param {?} _platform
                 */
                function CdkTable(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform) {
                    this._differs = _differs;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._elementRef = _elementRef;
                    this._dir = _dir;
                    this._platform = _platform;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    this._onDestroy = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Map of all the user's defined columns (header, data, and footer cell template) identified by
                     * name. Collection populated by the column definitions gathered by `ContentChildren` as well as
                     * any custom column definitions added to `_customColumnDefs`.
                     */
                    this._columnDefsByName = new Map();
                    /**
                     * Column definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has
                     * column definitions as *its* content child.
                     */
                    this._customColumnDefs = new Set();
                    /**
                     * Data row definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has
                     * built-in data rows as *its* content child.
                     */
                    this._customRowDefs = new Set();
                    /**
                     * Header row definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has
                     * built-in header rows as *its* content child.
                     */
                    this._customHeaderRowDefs = new Set();
                    /**
                     * Footer row definitions that were defined outside of the direct content children of the table.
                     * These will be defined when, e.g., creating a wrapper around the cdkTable that has a
                     * built-in footer row as *its* content child.
                     */
                    this._customFooterRowDefs = new Set();
                    /**
                     * Whether the header row definition has been changed. Triggers an update to the header row after
                     * content is checked. Initialized as true so that the table renders the initial set of rows.
                     */
                    this._headerRowDefChanged = true;
                    /**
                     * Whether the footer row definition has been changed. Triggers an update to the footer row after
                     * content is checked. Initialized as true so that the table renders the initial set of rows.
                     */
                    this._footerRowDefChanged = true;
                    /**
                     * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing
                     * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with
                     * the cached `RenderRow` objects when possible, the row identity is preserved when the data
                     * and row template matches, which allows the `IterableDiffer` to check rows by reference
                     * and understand which rows are added/moved/removed.
                     *
                     * Implemented as a map of maps where the first key is the `data: T` object and the second is the
                     * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that
                     * contains an array of created pairs. The array is necessary to handle cases where the data
                     * array contains multiple duplicate data objects and each instantiated `RenderRow` must be
                     * stored.
                     */
                    this._cachedRenderRowsMap = new Map();
                    /**
                     * CSS class added to any row or cell that has sticky positioning applied. May be overriden by
                     * table subclasses.
                     */
                    this.stickyCssClass = 'cdk-table-sticky';
                    this._multiTemplateDataRows = false;
                    // TODO(andrewseguin): Remove max value as the end index
                    //   and instead calculate the view on init and scroll.
                    /**
                     * Stream containing the latest information on what rows are being displayed on screen.
                     * Can be used by the data source to as a heuristic of what data should be provided.
                     *
                     * \@docs-private
                     */
                    this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_6__["BehaviorSubject"]({ start: 0, end: Number.MAX_VALUE });
                    if (!role) {
                        this._elementRef.nativeElement.setAttribute('role', 'grid');
                    }
                    this._document = _document;
                    this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';
                }
                Object.defineProperty(CdkTable.prototype, "trackBy", {
                    /**
                     * Tracking function that will be used to check the differences in data changes. Used similarly
                     * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
                     * relative to the function to know if a row should be added/removed/moved.
                     * Accepts a function that takes two parameters, `index` and `item`.
                     * @return {?}
                     */
                    get: function () {
                        return this._trackByFn;
                    },
                    /**
                     * @param {?} fn
                     * @return {?}
                     */
                    set: function (fn) {
                        if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && fn != null && typeof fn !== 'function' && ( /** @type {?} */(console)) &&
                            ( /** @type {?} */(console.warn))) {
                            console.warn("trackBy must be a function, but received " + JSON.stringify(fn) + ".");
                        }
                        this._trackByFn = fn;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTable.prototype, "dataSource", {
                    /**
                     * The table's source of data, which can be provided in three ways (in order of complexity):
                     *   - Simple data array (each object represents one table row)
                     *   - Stream that emits a data array each time the array changes
                     *   - `DataSource` object that implements the connect/disconnect interface.
                     *
                     * If a data array is provided, the table must be notified when the array's objects are
                     * added, removed, or moved. This can be done by calling the `renderRows()` function which will
                     * render the diff since the last table render. If the data array reference is changed, the table
                     * will automatically trigger an update to the rows.
                     *
                     * When providing an Observable stream, the table will trigger an update automatically when the
                     * stream emits a new array of data.
                     *
                     * Finally, when providing a `DataSource` object, the table will use the Observable stream
                     * provided by the connect function and trigger updates when that stream emits new data array
                     * values. During the table's ngOnDestroy or when the data source is removed from the table, the
                     * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
                     * subscriptions registered during the connect process).
                     * @return {?}
                     */
                    get: function () {
                        return this._dataSource;
                    },
                    /**
                     * @param {?} dataSource
                     * @return {?}
                     */
                    set: function (dataSource) {
                        if (this._dataSource !== dataSource) {
                            this._switchDataSource(dataSource);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTable.prototype, "multiTemplateDataRows", {
                    /**
                     * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
                     * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
                     * dataobject will render the first row that evaluates its when predicate to true, in the order
                     * defined in the table, or otherwise the default row which does not have a when predicate.
                     * @return {?}
                     */
                    get: function () {
                        return this._multiTemplateDataRows;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._multiTemplateDataRows = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v);
                        // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),
                        // this setter will be invoked before the row outlet has been defined hence the null check.
                        if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
                            this._forceRenderDataRows();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkTable.prototype.ngOnInit = function () {
                    var _this = this;
                    this._setupStickyStyler();
                    if (this._isNativeHtmlTable) {
                        this._applyNativeTableSections();
                    }
                    // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If
                    // the user has provided a custom trackBy, return the result of that function as evaluated
                    // with the values of the `RenderRow`'s data and index.
                    this._dataDiffer = this._differs.find([]).create(( /**
                     * @param {?} _i
                     * @param {?} dataRow
                     * @return {?}
                     */function (_i, dataRow) {
                        return _this.trackBy ? _this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
                    }));
                };
                /**
                 * @return {?}
                 */
                CdkTable.prototype.ngAfterContentChecked = function () {
                    // Cache the row and column definitions gathered by ContentChildren and programmatic injection.
                    this._cacheRowDefs();
                    this._cacheColumnDefs();
                    // Make sure that the user has at least added header, footer, or data row def.
                    if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length) {
                        throw getTableMissingRowDefsError();
                    }
                    // Render updates if the list of columns have been changed for the header, row, or footer defs.
                    this._renderUpdatedColumns();
                    // If the header row definition has been changed, trigger a render to the header row.
                    if (this._headerRowDefChanged) {
                        this._forceRenderHeaderRows();
                        this._headerRowDefChanged = false;
                    }
                    // If the footer row definition has been changed, trigger a render to the footer row.
                    if (this._footerRowDefChanged) {
                        this._forceRenderFooterRows();
                        this._footerRowDefChanged = false;
                    }
                    // If there is a data source and row definitions, connect to the data source unless a
                    // connection has already been made.
                    if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
                        this._observeRenderChanges();
                    }
                    this._checkStickyStates();
                };
                /**
                 * @return {?}
                 */
                CdkTable.prototype.ngOnDestroy = function () {
                    this._rowOutlet.viewContainer.clear();
                    this._headerRowOutlet.viewContainer.clear();
                    this._footerRowOutlet.viewContainer.clear();
                    this._cachedRenderRowsMap.clear();
                    this._onDestroy.next();
                    this._onDestroy.complete();
                    if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
                        this.dataSource.disconnect(this);
                    }
                };
                /**
                 * Renders rows based on the table's latest set of data, which was either provided directly as an
                 * input or retrieved through an Observable stream (directly or from a DataSource).
                 * Checks for differences in the data since the last diff to perform only the necessary
                 * changes (add/remove/move rows).
                 *
                 * If the table's data source is a DataSource or Observable, this will be invoked automatically
                 * each time the provided Observable stream emits a new data array. Otherwise if your data is
                 * an array, this function will need to be called to render any changes.
                 * @return {?}
                 */
                CdkTable.prototype.renderRows = function () {
                    var _this = this;
                    this._renderRows = this._getAllRenderRows();
                    /** @type {?} */
                    var changes = this._dataDiffer.diff(this._renderRows);
                    if (!changes) {
                        return;
                    }
                    /** @type {?} */
                    var viewContainer = this._rowOutlet.viewContainer;
                    changes.forEachOperation(( /**
                     * @param {?} record
                     * @param {?} prevIndex
                     * @param {?} currentIndex
                     * @return {?}
                     */function (record, prevIndex, currentIndex) {
                        if (record.previousIndex == null) {
                            _this._insertRow(record.item, ( /** @type {?} */(currentIndex)));
                        }
                        else if (currentIndex == null) {
                            viewContainer.remove(( /** @type {?} */(prevIndex)));
                        }
                        else {
                            /** @type {?} */
                            var view = ( /** @type {?} */(viewContainer.get(( /** @type {?} */(prevIndex)))));
                            viewContainer.move(( /** @type {?} */(view)), currentIndex);
                        }
                    }));
                    // Update the meta context of a row's context data (index, count, first, last, ...)
                    this._updateRowIndexContext();
                    // Update rows that did not get added/removed/moved but may have had their identity changed,
                    // e.g. if trackBy matched data on some property but the actual data reference changed.
                    changes.forEachIdentityChange(( /**
                     * @param {?} record
                     * @return {?}
                     */function (record) {
                        /** @type {?} */
                        var rowView = ( /** @type {?} */(viewContainer.get(( /** @type {?} */(record.currentIndex)))));
                        rowView.context.$implicit = record.item.data;
                    }));
                    this.updateStickyColumnStyles();
                };
                /**
                 * Sets the header row definition to be used. Overrides the header row definition gathered by
                 * using `ContentChild`, if one exists. Sets a flag that will re-render the header row after the
                 * table's content is checked.
                 * \@docs-private
                 * @deprecated Use `addHeaderRowDef` and `removeHeaderRowDef` instead
                 * \@breaking-change 8.0.0
                 * @param {?} headerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.setHeaderRowDef = function (headerRowDef) {
                    this._customHeaderRowDefs = new Set([headerRowDef]);
                    this._headerRowDefChanged = true;
                };
                /**
                 * Sets the footer row definition to be used. Overrides the footer row definition gathered by
                 * using `ContentChild`, if one exists. Sets a flag that will re-render the footer row after the
                 * table's content is checked.
                 * \@docs-private
                 * @deprecated Use `addFooterRowDef` and `removeFooterRowDef` instead
                 * \@breaking-change 8.0.0
                 * @param {?} footerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.setFooterRowDef = function (footerRowDef) {
                    this._customFooterRowDefs = new Set([footerRowDef]);
                    this._footerRowDefChanged = true;
                };
                /**
                 * Adds a column definition that was not included as part of the content children.
                 * @param {?} columnDef
                 * @return {?}
                 */
                CdkTable.prototype.addColumnDef = function (columnDef) {
                    this._customColumnDefs.add(columnDef);
                };
                /**
                 * Removes a column definition that was not included as part of the content children.
                 * @param {?} columnDef
                 * @return {?}
                 */
                CdkTable.prototype.removeColumnDef = function (columnDef) {
                    this._customColumnDefs.delete(columnDef);
                };
                /**
                 * Adds a row definition that was not included as part of the content children.
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype.addRowDef = function (rowDef) {
                    this._customRowDefs.add(rowDef);
                };
                /**
                 * Removes a row definition that was not included as part of the content children.
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype.removeRowDef = function (rowDef) {
                    this._customRowDefs.delete(rowDef);
                };
                /**
                 * Adds a header row definition that was not included as part of the content children.
                 * @param {?} headerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.addHeaderRowDef = function (headerRowDef) {
                    this._customHeaderRowDefs.add(headerRowDef);
                    this._headerRowDefChanged = true;
                };
                /**
                 * Removes a header row definition that was not included as part of the content children.
                 * @param {?} headerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.removeHeaderRowDef = function (headerRowDef) {
                    this._customHeaderRowDefs.delete(headerRowDef);
                    this._headerRowDefChanged = true;
                };
                /**
                 * Adds a footer row definition that was not included as part of the content children.
                 * @param {?} footerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.addFooterRowDef = function (footerRowDef) {
                    this._customFooterRowDefs.add(footerRowDef);
                    this._footerRowDefChanged = true;
                };
                /**
                 * Removes a footer row definition that was not included as part of the content children.
                 * @param {?} footerRowDef
                 * @return {?}
                 */
                CdkTable.prototype.removeFooterRowDef = function (footerRowDef) {
                    this._customFooterRowDefs.delete(footerRowDef);
                    this._footerRowDefChanged = true;
                };
                /**
                 * Updates the header sticky styles. First resets all applied styles with respect to the cells
                 * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
                 * automatically called when the header row changes its displayed set of columns, or if its
                 * sticky input changes. May be called manually for cases where the cell content changes outside
                 * of these events.
                 * @return {?}
                 */
                CdkTable.prototype.updateStickyHeaderRowStyles = function () {
                    /** @type {?} */
                    var headerRows = this._getRenderedRows(this._headerRowOutlet);
                    /** @type {?} */
                    var tableElement = ( /** @type {?} */(this._elementRef.nativeElement));
                    // Hide the thead element if there are no header rows. This is necessary to satisfy
                    // overzealous a11y checkers that fail because the `rowgroup` element does not contain
                    // required child `row`.
                    /** @type {?} */
                    var thead = tableElement.querySelector('thead');
                    if (thead) {
                        thead.style.display = headerRows.length ? '' : 'none';
                    }
                    /** @type {?} */
                    var stickyStates = this._headerRowDefs.map(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.sticky; }));
                    this._stickyStyler.clearStickyPositioning(headerRows, ['top']);
                    this._stickyStyler.stickRows(headerRows, stickyStates, 'top');
                    // Reset the dirty state of the sticky input change since it has been used.
                    this._headerRowDefs.forEach(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.resetStickyChanged(); }));
                };
                /**
                 * Updates the footer sticky styles. First resets all applied styles with respect to the cells
                 * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
                 * automatically called when the footer row changes its displayed set of columns, or if its
                 * sticky input changes. May be called manually for cases where the cell content changes outside
                 * of these events.
                 * @return {?}
                 */
                CdkTable.prototype.updateStickyFooterRowStyles = function () {
                    /** @type {?} */
                    var footerRows = this._getRenderedRows(this._footerRowOutlet);
                    /** @type {?} */
                    var tableElement = ( /** @type {?} */(this._elementRef.nativeElement));
                    // Hide the tfoot element if there are no footer rows. This is necessary to satisfy
                    // overzealous a11y checkers that fail because the `rowgroup` element does not contain
                    // required child `row`.
                    /** @type {?} */
                    var tfoot = tableElement.querySelector('tfoot');
                    if (tfoot) {
                        tfoot.style.display = footerRows.length ? '' : 'none';
                    }
                    /** @type {?} */
                    var stickyStates = this._footerRowDefs.map(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.sticky; }));
                    this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);
                    this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');
                    this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
                    // Reset the dirty state of the sticky input change since it has been used.
                    this._footerRowDefs.forEach(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.resetStickyChanged(); }));
                };
                /**
                 * Updates the column sticky styles. First resets all applied styles with respect to the cells
                 * sticking to the left and right. Then sticky styles are added for the left and right according
                 * to the column definitions for each cell in each row. This is automatically called when
                 * the data source provides a new set of data or when a column definition changes its sticky
                 * input. May be called manually for cases where the cell content changes outside of these events.
                 * @return {?}
                 */
                CdkTable.prototype.updateStickyColumnStyles = function () {
                    var _this = this;
                    /** @type {?} */
                    var headerRows = this._getRenderedRows(this._headerRowOutlet);
                    /** @type {?} */
                    var dataRows = this._getRenderedRows(this._rowOutlet);
                    /** @type {?} */
                    var footerRows = this._getRenderedRows(this._footerRowOutlet);
                    // Clear the left and right positioning from all columns in the table across all rows since
                    // sticky columns span across all table sections (header, data, footer)
                    this._stickyStyler.clearStickyPositioning(__spread(headerRows, dataRows, footerRows), ['left', 'right']);
                    // Update the sticky styles for each header row depending on the def's sticky state
                    headerRows.forEach(( /**
                     * @param {?} headerRow
                     * @param {?} i
                     * @return {?}
                     */function (headerRow, i) {
                        _this._addStickyColumnStyles([headerRow], _this._headerRowDefs[i]);
                    }));
                    // Update the sticky styles for each data row depending on its def's sticky state
                    this._rowDefs.forEach(( /**
                     * @param {?} rowDef
                     * @return {?}
                     */function (/**
                     * @param {?} rowDef
                     * @return {?}
                     */ rowDef) {
                        // Collect all the rows rendered with this row definition.
                        /** @type {?} */
                        var rows = [];
                        for (var i = 0; i < dataRows.length; i++) {
                            if (_this._renderRows[i].rowDef === rowDef) {
                                rows.push(dataRows[i]);
                            }
                        }
                        _this._addStickyColumnStyles(rows, rowDef);
                    }));
                    // Update the sticky styles for each footer row depending on the def's sticky state
                    footerRows.forEach(( /**
                     * @param {?} footerRow
                     * @param {?} i
                     * @return {?}
                     */function (footerRow, i) {
                        _this._addStickyColumnStyles([footerRow], _this._footerRowDefs[i]);
                    }));
                    // Reset the dirty state of the sticky input change since it has been used.
                    Array.from(this._columnDefsByName.values()).forEach(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.resetStickyChanged(); }));
                };
                /**
                 * Get the list of RenderRow objects to render according to the current list of data and defined
                 * row definitions. If the previous list already contained a particular pair, it should be reused
                 * so that the differ equates their references.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._getAllRenderRows = function () {
                    /** @type {?} */
                    var renderRows = [];
                    // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the
                    // new cache while unused ones can be picked up by garbage collection.
                    /** @type {?} */
                    var prevCachedRenderRows = this._cachedRenderRowsMap;
                    this._cachedRenderRowsMap = new Map();
                    // For each data object, get the list of rows that should be rendered, represented by the
                    // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.
                    for (var i = 0; i < this._data.length; i++) {
                        /** @type {?} */
                        var data = this._data[i];
                        /** @type {?} */
                        var renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));
                        if (!this._cachedRenderRowsMap.has(data)) {
                            this._cachedRenderRowsMap.set(data, new WeakMap());
                        }
                        for (var j = 0; j < renderRowsForData.length; j++) {
                            /** @type {?} */
                            var renderRow = renderRowsForData[j];
                            /** @type {?} */
                            var cache = ( /** @type {?} */(this._cachedRenderRowsMap.get(renderRow.data)));
                            if (cache.has(renderRow.rowDef)) {
                                ( /** @type {?} */(cache.get(renderRow.rowDef))).push(renderRow);
                            }
                            else {
                                cache.set(renderRow.rowDef, [renderRow]);
                            }
                            renderRows.push(renderRow);
                        }
                    }
                    return renderRows;
                };
                /**
                 * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
                 * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
                 * `(T, CdkRowDef)` pair.
                 * @private
                 * @param {?} data
                 * @param {?} dataIndex
                 * @param {?=} cache
                 * @return {?}
                 */
                CdkTable.prototype._getRenderRowsForData = function (data, dataIndex, cache) {
                    /** @type {?} */
                    var rowDefs = this._getRowDefs(data, dataIndex);
                    return rowDefs.map(( /**
                     * @param {?} rowDef
                     * @return {?}
                     */function (/**
                     * @param {?} rowDef
                     * @return {?}
                     */ rowDef) {
                        /** @type {?} */
                        var cachedRenderRows = (cache && cache.has(rowDef)) ? ( /** @type {?} */(cache.get(rowDef))) : [];
                        if (cachedRenderRows.length) {
                            /** @type {?} */
                            var dataRow = ( /** @type {?} */(cachedRenderRows.shift()));
                            dataRow.dataIndex = dataIndex;
                            return dataRow;
                        }
                        else {
                            return { data: data, rowDef: rowDef, dataIndex: dataIndex };
                        }
                    }));
                };
                /**
                 * Update the map containing the content's column definitions.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._cacheColumnDefs = function () {
                    var _this = this;
                    this._columnDefsByName.clear();
                    /** @type {?} */
                    var columnDefs = mergeQueryListAndSet(this._contentColumnDefs, this._customColumnDefs);
                    columnDefs.forEach(( /**
                     * @param {?} columnDef
                     * @return {?}
                     */function (/**
                     * @param {?} columnDef
                     * @return {?}
                     */ columnDef) {
                        if (_this._columnDefsByName.has(columnDef.name)) {
                            throw getTableDuplicateColumnNameError(columnDef.name);
                        }
                        _this._columnDefsByName.set(columnDef.name, columnDef);
                    }));
                };
                /**
                 * Update the list of all available row definitions that can be used.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._cacheRowDefs = function () {
                    this._headerRowDefs =
                        mergeQueryListAndSet(this._contentHeaderRowDefs, this._customHeaderRowDefs);
                    this._footerRowDefs =
                        mergeQueryListAndSet(this._contentFooterRowDefs, this._customFooterRowDefs);
                    this._rowDefs = mergeQueryListAndSet(this._contentRowDefs, this._customRowDefs);
                    // After all row definitions are determined, find the row definition to be considered default.
                    /** @type {?} */
                    var defaultRowDefs = this._rowDefs.filter(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return !def.when; }));
                    if (!this.multiTemplateDataRows && defaultRowDefs.length > 1) {
                        throw getTableMultipleDefaultRowDefsError();
                    }
                    this._defaultRowDef = defaultRowDefs[0];
                };
                /**
                 * Check if the header, data, or footer rows have changed what columns they want to display or
                 * whether the sticky states have changed for the header or footer. If there is a diff, then
                 * re-render that section.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._renderUpdatedColumns = function () {
                    /** @type {?} */
                    var columnsDiffReducer = ( /**
                     * @param {?} acc
                     * @param {?} def
                     * @return {?}
                     */function (acc, def) { return acc || !!def.getColumnsDiff(); });
                    // Force re-render data rows if the list of column definitions have changed.
                    if (this._rowDefs.reduce(columnsDiffReducer, false)) {
                        this._forceRenderDataRows();
                    }
                    // Force re-render header/footer rows if the list of column definitions have changed..
                    if (this._headerRowDefs.reduce(columnsDiffReducer, false)) {
                        this._forceRenderHeaderRows();
                    }
                    if (this._footerRowDefs.reduce(columnsDiffReducer, false)) {
                        this._forceRenderFooterRows();
                    }
                };
                /**
                 * Switch to the provided data source by resetting the data and unsubscribing from the current
                 * render change subscription if one exists. If the data source is null, interpret this by
                 * clearing the row outlet. Otherwise start listening for new data.
                 * @private
                 * @param {?} dataSource
                 * @return {?}
                 */
                CdkTable.prototype._switchDataSource = function (dataSource) {
                    this._data = [];
                    if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
                        this.dataSource.disconnect(this);
                    }
                    // Stop listening for data from the previous data source.
                    if (this._renderChangeSubscription) {
                        this._renderChangeSubscription.unsubscribe();
                        this._renderChangeSubscription = null;
                    }
                    if (!dataSource) {
                        if (this._dataDiffer) {
                            this._dataDiffer.diff([]);
                        }
                        this._rowOutlet.viewContainer.clear();
                    }
                    this._dataSource = dataSource;
                };
                /**
                 * Set up a subscription for the data provided by the data source.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._observeRenderChanges = function () {
                    var _this = this;
                    // If no data source has been set, there is nothing to observe for changes.
                    if (!this.dataSource) {
                        return;
                    }
                    /** @type {?} */
                    var dataStream;
                    if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__["isDataSource"])(this.dataSource)) {
                        dataStream = this.dataSource.connect(this);
                    }
                    else if (this.dataSource instanceof rxjs__WEBPACK_IMPORTED_MODULE_6__["Observable"]) {
                        dataStream = this.dataSource;
                    }
                    else if (Array.isArray(this.dataSource)) {
                        dataStream = Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])(this.dataSource);
                    }
                    if (dataStream === undefined) {
                        throw getTableUnknownDataSourceError();
                    }
                    this._renderChangeSubscription = dataStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._onDestroy)).subscribe(( /**
                     * @param {?} data
                     * @return {?}
                     */function (/**
                     * @param {?} data
                     * @return {?}
                     */ data) {
                        _this._data = data || [];
                        _this.renderRows();
                    }));
                };
                /**
                 * Clears any existing content in the header row outlet and creates a new embedded view
                 * in the outlet using the header row definition.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._forceRenderHeaderRows = function () {
                    var _this = this;
                    // Clear the header row outlet if any content exists.
                    if (this._headerRowOutlet.viewContainer.length > 0) {
                        this._headerRowOutlet.viewContainer.clear();
                    }
                    this._headerRowDefs.forEach(( /**
                     * @param {?} def
                     * @param {?} i
                     * @return {?}
                     */function (def, i) { return _this._renderRow(_this._headerRowOutlet, def, i); }));
                    this.updateStickyHeaderRowStyles();
                    this.updateStickyColumnStyles();
                };
                /**
                 * Clears any existing content in the footer row outlet and creates a new embedded view
                 * in the outlet using the footer row definition.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._forceRenderFooterRows = function () {
                    var _this = this;
                    // Clear the footer row outlet if any content exists.
                    if (this._footerRowOutlet.viewContainer.length > 0) {
                        this._footerRowOutlet.viewContainer.clear();
                    }
                    this._footerRowDefs.forEach(( /**
                     * @param {?} def
                     * @param {?} i
                     * @return {?}
                     */function (def, i) { return _this._renderRow(_this._footerRowOutlet, def, i); }));
                    this.updateStickyFooterRowStyles();
                    this.updateStickyColumnStyles();
                };
                /**
                 * Adds the sticky column styles for the rows according to the columns' stick states.
                 * @private
                 * @param {?} rows
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype._addStickyColumnStyles = function (rows, rowDef) {
                    var _this = this;
                    /** @type {?} */
                    var columnDefs = Array.from(rowDef.columns || []).map(( /**
                     * @param {?} columnName
                     * @return {?}
                     */function (/**
                     * @param {?} columnName
                     * @return {?}
                     */ columnName) {
                        /** @type {?} */
                        var columnDef = _this._columnDefsByName.get(columnName);
                        if (!columnDef) {
                            throw getTableUnknownColumnError(columnName);
                        }
                        return ( /** @type {?} */(columnDef));
                    }));
                    /** @type {?} */
                    var stickyStartStates = columnDefs.map(( /**
                     * @param {?} columnDef
                     * @return {?}
                     */function (/**
                     * @param {?} columnDef
                     * @return {?}
                     */ columnDef) { return columnDef.sticky; }));
                    /** @type {?} */
                    var stickyEndStates = columnDefs.map(( /**
                     * @param {?} columnDef
                     * @return {?}
                     */function (/**
                     * @param {?} columnDef
                     * @return {?}
                     */ columnDef) { return columnDef.stickyEnd; }));
                    this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates);
                };
                /**
                 * Gets the list of rows that have been rendered in the row outlet.
                 * @param {?} rowOutlet
                 * @return {?}
                 */
                CdkTable.prototype._getRenderedRows = function (rowOutlet) {
                    /** @type {?} */
                    var renderedRows = [];
                    for (var i = 0; i < rowOutlet.viewContainer.length; i++) {
                        /** @type {?} */
                        var viewRef = (( /** @type {?} */(( /** @type {?} */(rowOutlet.viewContainer.get(i))))));
                        renderedRows.push(viewRef.rootNodes[0]);
                    }
                    return renderedRows;
                };
                /**
                 * Get the matching row definitions that should be used for this row data. If there is only
                 * one row definition, it is returned. Otherwise, find the row definitions that has a when
                 * predicate that returns true with the data. If none return true, return the default row
                 * definition.
                 * @param {?} data
                 * @param {?} dataIndex
                 * @return {?}
                 */
                CdkTable.prototype._getRowDefs = function (data, dataIndex) {
                    if (this._rowDefs.length == 1) {
                        return [this._rowDefs[0]];
                    }
                    /** @type {?} */
                    var rowDefs = [];
                    if (this.multiTemplateDataRows) {
                        rowDefs = this._rowDefs.filter(( /**
                         * @param {?} def
                         * @return {?}
                         */function (/**
                         * @param {?} def
                         * @return {?}
                         */ def) { return !def.when || def.when(dataIndex, data); }));
                    }
                    else {
                        /** @type {?} */
                        var rowDef = this._rowDefs.find(( /**
                         * @param {?} def
                         * @return {?}
                         */function (/**
                         * @param {?} def
                         * @return {?}
                         */ def) { return def.when && def.when(dataIndex, data); })) || this._defaultRowDef;
                        if (rowDef) {
                            rowDefs.push(rowDef);
                        }
                    }
                    if (!rowDefs.length) {
                        throw getTableMissingMatchingRowDefError(data);
                    }
                    return rowDefs;
                };
                /**
                 * Create the embedded view for the data row template and place it in the correct index location
                 * within the data row view container.
                 * @private
                 * @param {?} renderRow
                 * @param {?} renderIndex
                 * @return {?}
                 */
                CdkTable.prototype._insertRow = function (renderRow, renderIndex) {
                    /** @type {?} */
                    var rowDef = renderRow.rowDef;
                    /** @type {?} */
                    var context = { $implicit: renderRow.data };
                    this._renderRow(this._rowOutlet, rowDef, renderIndex, context);
                };
                /**
                 * Creates a new row template in the outlet and fills it with the set of cell templates.
                 * Optionally takes a context to provide to the row and cells, as well as an optional index
                 * of where to place the new row template in the outlet.
                 * @private
                 * @param {?} outlet
                 * @param {?} rowDef
                 * @param {?} index
                 * @param {?=} context
                 * @return {?}
                 */
                CdkTable.prototype._renderRow = function (outlet, rowDef, index, context) {
                    var e_5, _a;
                    if (context === void 0) { context = {}; }
                    // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView
                    outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
                    try {
                        for (var _b = __values(this._getCellTemplates(rowDef)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var cellTemplate = _c.value;
                            if (CdkCellOutlet.mostRecentCellOutlet) {
                                CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Updates the index-related context for each row to reflect any changes in the index of the rows,
                 * e.g. first/last/even/odd.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._updateRowIndexContext = function () {
                    /** @type {?} */
                    var viewContainer = this._rowOutlet.viewContainer;
                    for (var renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
                        /** @type {?} */
                        var viewRef = ( /** @type {?} */(viewContainer.get(renderIndex)));
                        /** @type {?} */
                        var context = ( /** @type {?} */(viewRef.context));
                        context.count = count;
                        context.first = renderIndex === 0;
                        context.last = renderIndex === count - 1;
                        context.even = renderIndex % 2 === 0;
                        context.odd = !context.even;
                        if (this.multiTemplateDataRows) {
                            context.dataIndex = this._renderRows[renderIndex].dataIndex;
                            context.renderIndex = renderIndex;
                        }
                        else {
                            context.index = this._renderRows[renderIndex].dataIndex;
                        }
                    }
                };
                /**
                 * Gets the column definitions for the provided row def.
                 * @private
                 * @param {?} rowDef
                 * @return {?}
                 */
                CdkTable.prototype._getCellTemplates = function (rowDef) {
                    var _this = this;
                    if (!rowDef || !rowDef.columns) {
                        return [];
                    }
                    return Array.from(rowDef.columns, ( /**
                     * @param {?} columnId
                     * @return {?}
                     */function (/**
                     * @param {?} columnId
                     * @return {?}
                     */ columnId) {
                        /** @type {?} */
                        var column = _this._columnDefsByName.get(columnId);
                        if (!column) {
                            throw getTableUnknownColumnError(columnId);
                        }
                        return rowDef.extractCellTemplate(column);
                    }));
                };
                /**
                 * Adds native table sections (e.g. tbody) and moves the row outlets into them.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._applyNativeTableSections = function () {
                    var e_6, _a;
                    /** @type {?} */
                    var documentFragment = this._document.createDocumentFragment();
                    /** @type {?} */
                    var sections = [
                        { tag: 'thead', outlet: this._headerRowOutlet },
                        { tag: 'tbody', outlet: this._rowOutlet },
                        { tag: 'tfoot', outlet: this._footerRowOutlet },
                    ];
                    try {
                        for (var sections_1 = __values(sections), sections_1_1 = sections_1.next(); !sections_1_1.done; sections_1_1 = sections_1.next()) {
                            var section = sections_1_1.value;
                            /** @type {?} */
                            var element = this._document.createElement(section.tag);
                            element.setAttribute('role', 'rowgroup');
                            element.appendChild(section.outlet.elementRef.nativeElement);
                            documentFragment.appendChild(element);
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (sections_1_1 && !sections_1_1.done && (_a = sections_1.return)) _a.call(sections_1);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                    // Use a DocumentFragment so we don't hit the DOM on each iteration.
                    this._elementRef.nativeElement.appendChild(documentFragment);
                };
                /**
                 * Forces a re-render of the data rows. Should be called in cases where there has been an input
                 * change that affects the evaluation of which rows should be rendered, e.g. toggling
                 * `multiTemplateDataRows` or adding/removing row definitions.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._forceRenderDataRows = function () {
                    this._dataDiffer.diff([]);
                    this._rowOutlet.viewContainer.clear();
                    this.renderRows();
                    this.updateStickyColumnStyles();
                };
                /**
                 * Checks if there has been a change in sticky states since last check and applies the correct
                 * sticky styles. Since checking resets the "dirty" state, this should only be performed once
                 * during a change detection and after the inputs are settled (after content check).
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._checkStickyStates = function () {
                    /** @type {?} */
                    var stickyCheckReducer = ( /**
                     * @param {?} acc
                     * @param {?} d
                     * @return {?}
                     */function (acc, d) {
                        return acc || d.hasStickyChanged();
                    });
                    // Note that the check needs to occur for every definition since it notifies the definition
                    // that it can reset its dirty state. Using another operator like `some` may short-circuit
                    // remaining definitions and leave them in an unchecked state.
                    if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
                        this.updateStickyHeaderRowStyles();
                    }
                    if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
                        this.updateStickyFooterRowStyles();
                    }
                    if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
                        this.updateStickyColumnStyles();
                    }
                };
                /**
                 * Creates the sticky styler that will be used for sticky rows and columns. Listens
                 * for directionality changes and provides the latest direction to the styler. Re-applies column
                 * stickiness when directionality changes.
                 * @private
                 * @return {?}
                 */
                CdkTable.prototype._setupStickyStyler = function () {
                    var _this = this;
                    /** @type {?} */
                    var direction = this._dir ? this._dir.value : 'ltr';
                    this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._platform.isBrowser);
                    (this._dir ? this._dir.change : Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])())
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["takeUntil"])(this._onDestroy))
                        .subscribe(( /**
                 * @param {?} value
                 * @return {?}
                 */function (/**
                 * @param {?} value
                 * @return {?}
                 */ value) {
                        _this._stickyStyler.direction = value;
                        _this.updateStickyColumnStyles();
                    }));
                };
                return CdkTable;
            }());
            CdkTable.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-table, table[cdk-table]',
                            exportAs: 'cdkTable',
                            template: CDK_TABLE_TEMPLATE,
                            host: {
                                'class': 'cdk-table',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // The "OnPush" status for the `MatTable` component is effectively a noop, so we are removing it.
                            // The view for `MatTable` consists entirely of templates declared in other views. As they are
                            // declared elsewhere, they are checked when their declaration points are checked.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /** @nocollapse */
            CdkTable.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"], args: ['role',] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"],] }] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__["Platform"] }
            ]; };
            CdkTable.propDecorators = {
                trackBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                dataSource: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                multiTemplateDataRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                _rowOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [DataRowOutlet, { static: true },] }],
                _headerRowOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [HeaderRowOutlet, { static: true },] }],
                _footerRowOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [FooterRowOutlet, { static: true },] }],
                _contentColumnDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkColumnDef,] }],
                _contentRowDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkRowDef,] }],
                _contentHeaderRowDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkHeaderRowDef,] }],
                _contentFooterRowDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ContentChildren"], args: [CdkFooterRowDef,] }]
            };
            /**
             * Utility function that gets a merged list of the entries in a QueryList and values of a Set.
             * @template T
             * @param {?} queryList
             * @param {?} set
             * @return {?}
             */
            function mergeQueryListAndSet(queryList, set) {
                return queryList.toArray().concat(Array.from(set));
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify the text column options.
             * @type {?}
             */
            var TEXT_COLUMN_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('text-column-options');
            /**
             * Column that simply shows text content for the header and row cells. Assumes that the table
             * is using the native table implementation (`<table>`).
             *
             * By default, the name of this column will be the header text and data property accessor.
             * The header text can be overridden with the `headerText` input. Cell values can be overridden with
             * the `dataAccessor` input. Change the text justification to the start or end using the `justify`
             * input.
             * @template T
             */
            var CdkTextColumn = /** @class */ (function () {
                /**
                 * @param {?} _table
                 * @param {?} _options
                 */
                function CdkTextColumn(_table, _options) {
                    this._table = _table;
                    this._options = _options;
                    /**
                     * Alignment of the cell values.
                     */
                    this.justify = 'start';
                    this._options = _options || {};
                }
                Object.defineProperty(CdkTextColumn.prototype, "name", {
                    /**
                     * Column name that should be used to reference this column.
                     * @return {?}
                     */
                    get: function () {
                        return this._name;
                    },
                    /**
                     * @param {?} name
                     * @return {?}
                     */
                    set: function (name) {
                        this._name = name;
                        // With Ivy, inputs can be initialized before static query results are
                        // available. In that case, we defer the synchronization until "ngOnInit" fires.
                        this._syncColumnDefName();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkTextColumn.prototype.ngOnInit = function () {
                    this._syncColumnDefName();
                    if (this.headerText === undefined) {
                        this.headerText = this._createDefaultHeaderText();
                    }
                    if (!this.dataAccessor) {
                        this.dataAccessor =
                            this._options.defaultDataAccessor || (( /**
                             * @param {?} data
                             * @param {?} name
                             * @return {?}
                             */function (data, name) { return (( /** @type {?} */(data)))[name]; }));
                    }
                    if (this._table) {
                        // Provide the cell and headerCell directly to the table with the static `ViewChild` query,
                        // since the columnDef will not pick up its content by the time the table finishes checking
                        // its content and initializing the rows.
                        this.columnDef.cell = this.cell;
                        this.columnDef.headerCell = this.headerCell;
                        this._table.addColumnDef(this.columnDef);
                    }
                    else {
                        throw getTableTextColumnMissingParentTableError();
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTextColumn.prototype.ngOnDestroy = function () {
                    if (this._table) {
                        this._table.removeColumnDef(this.columnDef);
                    }
                };
                /**
                 * Creates a default header text. Use the options' header text transformation function if one
                 * has been provided. Otherwise simply capitalize the column name.
                 * @return {?}
                 */
                CdkTextColumn.prototype._createDefaultHeaderText = function () {
                    /** @type {?} */
                    var name = this.name;
                    if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && !name) {
                        throw getTableTextColumnMissingNameError();
                    }
                    if (this._options && this._options.defaultHeaderTextTransform) {
                        return this._options.defaultHeaderTextTransform(name);
                    }
                    return name[0].toUpperCase() + name.slice(1);
                };
                /**
                 * Synchronizes the column definition name with the text column name.
                 * @private
                 * @return {?}
                 */
                CdkTextColumn.prototype._syncColumnDefName = function () {
                    if (this.columnDef) {
                        this.columnDef.name = this.name;
                    }
                };
                return CdkTextColumn;
            }());
            CdkTextColumn.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'cdk-text-column',
                            template: "\n    <ng-container cdkColumnDef>\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  ",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // Change detection is intentionally not set to OnPush. This component's template will be provided
                            // to the table to be inserted into its view. This is problematic when change detection runs since
                            // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
                            // mean's the template in the table's view will not have the updated value (and in fact will cause
                            // an ExpressionChangedAfterItHasBeenCheckedError).
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /** @nocollapse */
            CdkTextColumn.ctorParameters = function () { return [
                { type: CdkTable, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [TEXT_COLUMN_OPTIONS,] }] }
            ]; };
            CdkTextColumn.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                headerText: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                dataAccessor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                justify: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                columnDef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [CdkColumnDef, { static: true },] }],
                cell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [CdkCellDef, { static: true },] }],
                headerCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [CdkHeaderCellDef, { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var EXPORTED_DECLARATIONS = [
                CdkTable,
                CdkRowDef,
                CdkCellDef,
                CdkCellOutlet,
                CdkHeaderCellDef,
                CdkFooterCellDef,
                CdkColumnDef,
                CdkCell,
                CdkRow,
                CdkHeaderCell,
                CdkFooterCell,
                CdkHeaderRow,
                CdkHeaderRowDef,
                CdkFooterRow,
                CdkFooterRowDef,
                DataRowOutlet,
                HeaderRowOutlet,
                FooterRowOutlet,
                CdkTextColumn,
            ];
            var CdkTableModule = /** @class */ (function () {
                function CdkTableModule() {
                }
                return CdkTableModule;
            }());
            CdkTableModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
                            exports: EXPORTED_DECLARATIONS,
                            declarations: EXPORTED_DECLARATIONS
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=table.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/cdk/esm2015/tree.js": 
        /*!***************************************************!*\
          !*** ./node_modules/@angular/cdk/esm2015/tree.js ***!
          \***************************************************/
        /*! exports provided: BaseTreeControl, FlatTreeControl, NestedTreeControl, CdkNestedTreeNode, CdkTreeNodeOutletContext, CdkTreeNodeDef, CdkTreeNodePadding, CDK_TREE_NODE_OUTLET_NODE, CdkTreeNodeOutlet, CdkTree, CdkTreeNode, getTreeNoValidDataSourceError, getTreeMultipleDefaultNodeDefsError, getTreeMissingMatchingNodeDefError, getTreeControlMissingError, getTreeControlFunctionsMissingError, CdkTreeModule, CdkTreeNodeToggle */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseTreeControl", function () { return BaseTreeControl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatTreeControl", function () { return FlatTreeControl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NestedTreeControl", function () { return NestedTreeControl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkNestedTreeNode", function () { return CdkNestedTreeNode; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTreeNodeOutletContext", function () { return CdkTreeNodeOutletContext; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTreeNodeDef", function () { return CdkTreeNodeDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTreeNodePadding", function () { return CdkTreeNodePadding; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CDK_TREE_NODE_OUTLET_NODE", function () { return CDK_TREE_NODE_OUTLET_NODE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTreeNodeOutlet", function () { return CdkTreeNodeOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTree", function () { return CdkTree; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTreeNode", function () { return CdkTreeNode; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTreeNoValidDataSourceError", function () { return getTreeNoValidDataSourceError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTreeMultipleDefaultNodeDefsError", function () { return getTreeMultipleDefaultNodeDefsError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTreeMissingMatchingNodeDefError", function () { return getTreeMissingMatchingNodeDefError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTreeControlMissingError", function () { return getTreeControlMissingError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTreeControlFunctionsMissingError", function () { return getTreeControlFunctionsMissingError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTreeModule", function () { return CdkTreeModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CdkTreeNodeToggle", function () { return CdkTreeNodeToggle; });
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Base tree control. It has basic toggle/expand/collapse operations on a single data node.
             * @abstract
             * @template T
             */
            var BaseTreeControl = /** @class */ (function () {
                function BaseTreeControl() {
                    /**
                     * A selection model with multi-selection to track expansion status.
                     */
                    this.expansionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__["SelectionModel"](true);
                }
                /**
                 * Toggles one single data node's expanded/collapsed state.
                 * @param {?} dataNode
                 * @return {?}
                 */
                BaseTreeControl.prototype.toggle = function (dataNode) {
                    this.expansionModel.toggle(dataNode);
                };
                /**
                 * Expands one single data node.
                 * @param {?} dataNode
                 * @return {?}
                 */
                BaseTreeControl.prototype.expand = function (dataNode) {
                    this.expansionModel.select(dataNode);
                };
                /**
                 * Collapses one single data node.
                 * @param {?} dataNode
                 * @return {?}
                 */
                BaseTreeControl.prototype.collapse = function (dataNode) {
                    this.expansionModel.deselect(dataNode);
                };
                /**
                 * Whether a given data node is expanded or not. Returns true if the data node is expanded.
                 * @param {?} dataNode
                 * @return {?}
                 */
                BaseTreeControl.prototype.isExpanded = function (dataNode) {
                    return this.expansionModel.isSelected(dataNode);
                };
                /**
                 * Toggles a subtree rooted at `node` recursively.
                 * @param {?} dataNode
                 * @return {?}
                 */
                BaseTreeControl.prototype.toggleDescendants = function (dataNode) {
                    this.expansionModel.isSelected(dataNode)
                        ? this.collapseDescendants(dataNode)
                        : this.expandDescendants(dataNode);
                };
                /**
                 * Collapse all dataNodes in the tree.
                 * @return {?}
                 */
                BaseTreeControl.prototype.collapseAll = function () {
                    this.expansionModel.clear();
                };
                /**
                 * Expands a subtree rooted at given data node recursively.
                 * @param {?} dataNode
                 * @return {?}
                 */
                BaseTreeControl.prototype.expandDescendants = function (dataNode) {
                    var _a;
                    /** @type {?} */
                    var toBeProcessed = [dataNode];
                    toBeProcessed.push.apply(toBeProcessed, __spread(this.getDescendants(dataNode)));
                    (_a = this.expansionModel).select.apply(_a, __spread(toBeProcessed));
                };
                /**
                 * Collapses a subtree rooted at given data node recursively.
                 * @param {?} dataNode
                 * @return {?}
                 */
                BaseTreeControl.prototype.collapseDescendants = function (dataNode) {
                    var _a;
                    /** @type {?} */
                    var toBeProcessed = [dataNode];
                    toBeProcessed.push.apply(toBeProcessed, __spread(this.getDescendants(dataNode)));
                    (_a = this.expansionModel).deselect.apply(_a, __spread(toBeProcessed));
                };
                return BaseTreeControl;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.
             * @template T
             */
            var FlatTreeControl = /** @class */ (function (_super) {
                __extends(FlatTreeControl, _super);
                /**
                 * Construct with flat tree data node functions getLevel and isExpandable.
                 * @param {?} getLevel
                 * @param {?} isExpandable
                 */
                function FlatTreeControl(getLevel, isExpandable) {
                    var _this = _super.call(this) || this;
                    _this.getLevel = getLevel;
                    _this.isExpandable = isExpandable;
                    return _this;
                }
                /**
                 * Gets a list of the data node's subtree of descendent data nodes.
                 *
                 * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes
                 * with correct levels.
                 * @param {?} dataNode
                 * @return {?}
                 */
                FlatTreeControl.prototype.getDescendants = function (dataNode) {
                    /** @type {?} */
                    var startIndex = this.dataNodes.indexOf(dataNode);
                    /** @type {?} */
                    var results = [];
                    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.
                    // The level of descendants of a tree node must be greater than the level of the given
                    // tree node.
                    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.
                    // If we reach a node whose level is greater than the level of the tree node, we hit a
                    // sibling of an ancestor.
                    for (var i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {
                        results.push(this.dataNodes[i]);
                    }
                    return results;
                };
                /**
                 * Expands all data nodes in the tree.
                 *
                 * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened
                 * data nodes of the tree.
                 * @return {?}
                 */
                FlatTreeControl.prototype.expandAll = function () {
                    var _a;
                    (_a = this.expansionModel).select.apply(_a, __spread(this.dataNodes));
                };
                return FlatTreeControl;
            }(BaseTreeControl));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.
             * @template T
             */
            var NestedTreeControl = /** @class */ (function (_super) {
                __extends(NestedTreeControl, _super);
                /**
                 * Construct with nested tree function getChildren.
                 * @param {?} getChildren
                 */
                function NestedTreeControl(getChildren) {
                    var _this = _super.call(this) || this;
                    _this.getChildren = getChildren;
                    return _this;
                }
                /**
                 * Expands all dataNodes in the tree.
                 *
                 * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level
                 * data nodes of the tree.
                 * @return {?}
                 */
                NestedTreeControl.prototype.expandAll = function () {
                    var _a;
                    var _this = this;
                    this.expansionModel.clear();
                    /** @type {?} */
                    var allNodes = this.dataNodes.reduce(( /**
                     * @param {?} accumulator
                     * @param {?} dataNode
                     * @return {?}
                     */function (accumulator, dataNode) { return __spread(accumulator, _this.getDescendants(dataNode), [dataNode]); }), []);
                    (_a = this.expansionModel).select.apply(_a, __spread(allNodes));
                };
                /**
                 * Gets a list of descendant dataNodes of a subtree rooted at given data node recursively.
                 * @param {?} dataNode
                 * @return {?}
                 */
                NestedTreeControl.prototype.getDescendants = function (dataNode) {
                    /** @type {?} */
                    var descendants = [];
                    this._getDescendants(descendants, dataNode);
                    // Remove the node itself
                    return descendants.splice(1);
                };
                /**
                 * A helper function to get descendants recursively.
                 * @protected
                 * @param {?} descendants
                 * @param {?} dataNode
                 * @return {?}
                 */
                NestedTreeControl.prototype._getDescendants = function (descendants, dataNode) {
                    var _this = this;
                    descendants.push(dataNode);
                    /** @type {?} */
                    var childrenNodes = this.getChildren(dataNode);
                    if (Array.isArray(childrenNodes)) {
                        childrenNodes.forEach(( /**
                         * @param {?} child
                         * @return {?}
                         */function (child) { return _this._getDescendants(descendants, child); }));
                    }
                    else if (childrenNodes instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
                        // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that
                        // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.
                        childrenNodes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["filter"])(( /** @type {?} */(Boolean))))
                            .subscribe(( /**
                     * @param {?} children
                     * @return {?}
                     */function (/**
                     * @param {?} children
                     * @return {?}
                     */ children) {
                            var e_7, _a;
                            try {
                                for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                                    var child = children_1_1.value;
                                    _this._getDescendants(descendants, child);
                                }
                            }
                            catch (e_7_1) { e_7 = { error: e_7_1 }; }
                            finally {
                                try {
                                    if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
                                }
                                finally { if (e_7) throw e_7.error; }
                            }
                        }));
                    }
                };
                return NestedTreeControl;
            }(BaseTreeControl));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token used to provide a `CdkTreeNode` to its outlet.
             * Used primarily to avoid circular imports.
             * \@docs-private
             * @type {?}
             */
            var CDK_TREE_NODE_OUTLET_NODE = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('CDK_TREE_NODE_OUTLET_NODE');
            /**
             * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes
             * inside the outlet.
             */
            var CdkTreeNodeOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?=} _node
                 */
                function CdkTreeNodeOutlet(viewContainer, _node) {
                    this.viewContainer = viewContainer;
                    this._node = _node;
                }
                return CdkTreeNodeOutlet;
            }());
            CdkTreeNodeOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[cdkTreeNodeOutlet]'
                        },] },
            ];
            /** @nocollapse */
            CdkTreeNodeOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [CDK_TREE_NODE_OUTLET_NODE,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Context provided to the tree node component.
             * @template T
             */
            var CdkTreeNodeOutletContext = /** @class */ (function () {
                /**
                 * @param {?} data
                 */
                function CdkTreeNodeOutletContext(data) {
                    this.$implicit = data;
                }
                return CdkTreeNodeOutletContext;
            }());
            /**
             * Data node definition for the CdkTree.
             * Captures the node's template and a when predicate that describes when this node should be used.
             * @template T
             */
            var CdkTreeNodeDef = /** @class */ (function () {
                /**
                 * \@docs-private
                 * @param {?} template
                 */
                function CdkTreeNodeDef(template) {
                    this.template = template;
                }
                return CdkTreeNodeDef;
            }());
            CdkTreeNodeDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[cdkTreeNodeDef]',
                            inputs: [
                                'when: cdkTreeNodeDefWhen'
                            ],
                        },] },
            ];
            /** @nocollapse */
            CdkTreeNodeDef.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Returns an error to be thrown when there is no usable data.
             * \@docs-private
             * @return {?}
             */
            function getTreeNoValidDataSourceError() {
                return Error("A valid data source must be provided.");
            }
            /**
             * Returns an error to be thrown when there are multiple nodes that are missing a when function.
             * \@docs-private
             * @return {?}
             */
            function getTreeMultipleDefaultNodeDefsError() {
                return Error("There can only be one default row without a when predicate function.");
            }
            /**
             * Returns an error to be thrown when there are no matching node defs for a particular set of data.
             * \@docs-private
             * @return {?}
             */
            function getTreeMissingMatchingNodeDefError() {
                return Error("Could not find a matching node definition for the provided node data.");
            }
            /**
             * Returns an error to be thrown when there are tree control.
             * \@docs-private
             * @return {?}
             */
            function getTreeControlMissingError() {
                return Error("Could not find a tree control for the tree.");
            }
            /**
             * Returns an error to be thrown when tree control did not implement functions for flat/nested node.
             * \@docs-private
             * @return {?}
             */
            function getTreeControlFunctionsMissingError() {
                return Error("Could not find functions for nested/flat tree in tree control.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * CDK tree component that connects with a data source to retrieve data of type `T` and renders
             * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.
             * @template T
             */
            var CdkTree = /** @class */ (function () {
                /**
                 * @param {?} _differs
                 * @param {?} _changeDetectorRef
                 */
                function CdkTree(_differs, _changeDetectorRef) {
                    this._differs = _differs;
                    this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    this._onDestroy = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * Level of nodes
                     */
                    this._levels = new Map();
                    // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.
                    //     Remove the MAX_VALUE in viewChange
                    /**
                     * Stream containing the latest information on what rows are being displayed on screen.
                     * Can be used by the data source to as a heuristic of what data should be provided.
                     */
                    this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__["BehaviorSubject"]({ start: 0, end: Number.MAX_VALUE });
                }
                Object.defineProperty(CdkTree.prototype, "dataSource", {
                    /**
                     * Provides a stream containing the latest data array to render. Influenced by the tree's
                     * stream of view window (what dataNodes are currently on screen).
                     * Data source can be an observable of data array, or a data array to render.
                     * @return {?}
                     */
                    get: function () { return this._dataSource; },
                    /**
                     * @param {?} dataSource
                     * @return {?}
                     */
                    set: function (dataSource) {
                        if (this._dataSource !== dataSource) {
                            this._switchDataSource(dataSource);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkTree.prototype.ngOnInit = function () {
                    this._dataDiffer = this._differs.find([]).create(this.trackBy);
                    if (!this.treeControl) {
                        throw getTreeControlMissingError();
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTree.prototype.ngOnDestroy = function () {
                    this._nodeOutlet.viewContainer.clear();
                    this._onDestroy.next();
                    this._onDestroy.complete();
                    if (this._dataSource && typeof (( /** @type {?} */(this._dataSource))).disconnect === 'function') {
                        (( /** @type {?} */(this.dataSource))).disconnect(this);
                    }
                    if (this._dataSubscription) {
                        this._dataSubscription.unsubscribe();
                        this._dataSubscription = null;
                    }
                };
                /**
                 * @return {?}
                 */
                CdkTree.prototype.ngAfterContentChecked = function () {
                    /** @type {?} */
                    var defaultNodeDefs = this._nodeDefs.filter(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return !def.when; }));
                    if (defaultNodeDefs.length > 1) {
                        throw getTreeMultipleDefaultNodeDefsError();
                    }
                    this._defaultNodeDef = defaultNodeDefs[0];
                    if (this.dataSource && this._nodeDefs && !this._dataSubscription) {
                        this._observeRenderChanges();
                    }
                };
                // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL
                //     and nested trees.
                /**
                 * Switch to the provided data source by resetting the data and unsubscribing from the current
                 * render change subscription if one exists. If the data source is null, interpret this by
                 * clearing the node outlet. Otherwise start listening for new data.
                 * @private
                 * @param {?} dataSource
                 * @return {?}
                 */
                CdkTree.prototype._switchDataSource = function (dataSource) {
                    if (this._dataSource && typeof (( /** @type {?} */(this._dataSource))).disconnect === 'function') {
                        (( /** @type {?} */(this.dataSource))).disconnect(this);
                    }
                    if (this._dataSubscription) {
                        this._dataSubscription.unsubscribe();
                        this._dataSubscription = null;
                    }
                    // Remove the all dataNodes if there is now no data source
                    if (!dataSource) {
                        this._nodeOutlet.viewContainer.clear();
                    }
                    this._dataSource = dataSource;
                    if (this._nodeDefs) {
                        this._observeRenderChanges();
                    }
                };
                /**
                 * Set up a subscription for the data provided by the data source.
                 * @private
                 * @return {?}
                 */
                CdkTree.prototype._observeRenderChanges = function () {
                    var _this = this;
                    /** @type {?} */
                    var dataStream;
                    if (Object(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__["isDataSource"])(this._dataSource)) {
                        dataStream = this._dataSource.connect(this);
                    }
                    else if (this._dataSource instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
                        dataStream = this._dataSource;
                    }
                    else if (Array.isArray(this._dataSource)) {
                        dataStream = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])(this._dataSource);
                    }
                    if (dataStream) {
                        this._dataSubscription = dataStream.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["takeUntil"])(this._onDestroy))
                            .subscribe(( /**
                     * @param {?} data
                     * @return {?}
                     */function (/**
                     * @param {?} data
                     * @return {?}
                     */ data) { return _this.renderNodeChanges(data); }));
                    }
                    else {
                        throw getTreeNoValidDataSourceError();
                    }
                };
                /**
                 * Check for changes made in the data and render each change (node added/removed/moved).
                 * @param {?} data
                 * @param {?=} dataDiffer
                 * @param {?=} viewContainer
                 * @param {?=} parentData
                 * @return {?}
                 */
                CdkTree.prototype.renderNodeChanges = function (data, dataDiffer, viewContainer, parentData) {
                    var _this = this;
                    if (dataDiffer === void 0) { dataDiffer = this._dataDiffer; }
                    if (viewContainer === void 0) { viewContainer = this._nodeOutlet.viewContainer; }
                    /** @type {?} */
                    var changes = dataDiffer.diff(data);
                    if (!changes) {
                        return;
                    }
                    changes.forEachOperation(( /**
                     * @param {?} item
                     * @param {?} adjustedPreviousIndex
                     * @param {?} currentIndex
                     * @return {?}
                     */function (item, adjustedPreviousIndex, currentIndex) {
                        if (item.previousIndex == null) {
                            _this.insertNode(data[( /** @type {?} */(currentIndex))], ( /** @type {?} */(currentIndex)), viewContainer, parentData);
                        }
                        else if (currentIndex == null) {
                            viewContainer.remove(( /** @type {?} */(adjustedPreviousIndex)));
                            _this._levels.delete(item.item);
                        }
                        else {
                            /** @type {?} */
                            var view = viewContainer.get(( /** @type {?} */(adjustedPreviousIndex)));
                            viewContainer.move(( /** @type {?} */(view)), currentIndex);
                        }
                    }));
                    this._changeDetectorRef.detectChanges();
                };
                /**
                 * Finds the matching node definition that should be used for this node data. If there is only
                 * one node definition, it is returned. Otherwise, find the node definition that has a when
                 * predicate that returns true with the data. If none return true, return the default node
                 * definition.
                 * @param {?} data
                 * @param {?} i
                 * @return {?}
                 */
                CdkTree.prototype._getNodeDef = function (data, i) {
                    if (this._nodeDefs.length === 1) {
                        return this._nodeDefs.first;
                    }
                    /** @type {?} */
                    var nodeDef = this._nodeDefs.find(( /**
                     * @param {?} def
                     * @return {?}
                     */function (/**
                     * @param {?} def
                     * @return {?}
                     */ def) { return def.when && def.when(i, data); })) || this._defaultNodeDef;
                    if (!nodeDef) {
                        throw getTreeMissingMatchingNodeDefError();
                    }
                    return nodeDef;
                };
                /**
                 * Create the embedded view for the data node template and place it in the correct index location
                 * within the data node view container.
                 * @param {?} nodeData
                 * @param {?} index
                 * @param {?=} viewContainer
                 * @param {?=} parentData
                 * @return {?}
                 */
                CdkTree.prototype.insertNode = function (nodeData, index, viewContainer, parentData) {
                    /** @type {?} */
                    var node = this._getNodeDef(nodeData, index);
                    // Node context that will be provided to created embedded view
                    /** @type {?} */
                    var context = new CdkTreeNodeOutletContext(nodeData);
                    // If the tree is flat tree, then use the `getLevel` function in flat tree control
                    // Otherwise, use the level of parent node.
                    if (this.treeControl.getLevel) {
                        context.level = this.treeControl.getLevel(nodeData);
                    }
                    else if (typeof parentData !== 'undefined' && this._levels.has(parentData)) {
                        context.level = ( /** @type {?} */(this._levels.get(parentData))) + 1;
                    }
                    else {
                        context.level = 0;
                    }
                    this._levels.set(nodeData, context.level);
                    // Use default tree nodeOutlet, or nested node's nodeOutlet
                    /** @type {?} */
                    var container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;
                    container.createEmbeddedView(node.template, context, index);
                    // Set the data to just created `CdkTreeNode`.
                    // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable
                    //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.
                    if (CdkTreeNode.mostRecentTreeNode) {
                        CdkTreeNode.mostRecentTreeNode.data = nodeData;
                    }
                };
                return CdkTree;
            }());
            CdkTree.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'cdk-tree',
                            exportAs: 'cdkTree',
                            template: "<ng-container cdkTreeNodeOutlet></ng-container>",
                            host: {
                                'class': 'cdk-tree',
                                'role': 'tree',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            // The "OnPush" status for the `CdkTree` component is effectively a noop, so we are removing it.
                            // The view for `CdkTree` consists entirely of templates declared in other views. As they are
                            // declared elsewhere, they are checked when their declaration points are checked.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].Default
                        },] },
            ];
            /** @nocollapse */
            CdkTree.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["IterableDiffers"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            CdkTree.propDecorators = {
                dataSource: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                treeControl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                trackBy: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                _nodeOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: [CdkTreeNodeOutlet, { static: true },] }],
                _nodeDefs: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [CdkTreeNodeDef,] }]
            };
            /**
             * Tree node for CdkTree. It contains the data in the tree node.
             * @template T
             */
            var CdkTreeNode = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _tree
                 */
                function CdkTreeNode(_elementRef, _tree) {
                    this._elementRef = _elementRef;
                    this._tree = _tree;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * Emits when the node's data has changed.
                     */
                    this._dataChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * The role of the node should be 'group' if it's an internal node,
                     * and 'treeitem' if it's a leaf node.
                     */
                    this.role = 'treeitem';
                    CdkTreeNode.mostRecentTreeNode = ( /** @type {?} */(this));
                }
                Object.defineProperty(CdkTreeNode.prototype, "data", {
                    /**
                     * The tree node's data.
                     * @return {?}
                     */
                    get: function () { return this._data; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== this._data) {
                            this._data = value;
                            this._setRoleFromData();
                            this._dataChanges.next();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTreeNode.prototype, "isExpanded", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._tree.treeControl.isExpanded(this._data);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTreeNode.prototype, "level", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkTreeNode.prototype.ngOnDestroy = function () {
                    // If this is the last tree node being destroyed,
                    // clear out the reference to avoid leaking memory.
                    if (CdkTreeNode.mostRecentTreeNode === this) {
                        CdkTreeNode.mostRecentTreeNode = null;
                    }
                    this._dataChanges.complete();
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Focuses the menu item. Implements for FocusableOption.
                 * @return {?}
                 */
                CdkTreeNode.prototype.focus = function () {
                    this._elementRef.nativeElement.focus();
                };
                /**
                 * @protected
                 * @return {?}
                 */
                CdkTreeNode.prototype._setRoleFromData = function () {
                    var _this = this;
                    if (this._tree.treeControl.isExpandable) {
                        this.role = this._tree.treeControl.isExpandable(this._data) ? 'group' : 'treeitem';
                    }
                    else {
                        if (!this._tree.treeControl.getChildren) {
                            throw getTreeControlFunctionsMissingError();
                        }
                        /** @type {?} */
                        var childrenNodes = this._tree.treeControl.getChildren(this._data);
                        if (Array.isArray(childrenNodes)) {
                            this._setRoleFromChildren(( /** @type {?} */(childrenNodes)));
                        }
                        else if (childrenNodes instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
                            childrenNodes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["takeUntil"])(this._destroyed))
                                .subscribe(( /**
                         * @param {?} children
                         * @return {?}
                         */function (/**
                         * @param {?} children
                         * @return {?}
                         */ children) { return _this._setRoleFromChildren(children); }));
                        }
                    }
                };
                /**
                 * @protected
                 * @param {?} children
                 * @return {?}
                 */
                CdkTreeNode.prototype._setRoleFromChildren = function (children) {
                    this.role = children && children.length ? 'group' : 'treeitem';
                };
                return CdkTreeNode;
            }());
            /**
             * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it
             * in `CdkTree` and set the data to it.
             */
            CdkTreeNode.mostRecentTreeNode = null;
            CdkTreeNode.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'cdk-tree-node',
                            exportAs: 'cdkTreeNode',
                            host: {
                                '[attr.aria-expanded]': 'isExpanded',
                                '[attr.aria-level]': 'role === "treeitem" ? level : null',
                                '[attr.role]': 'role',
                                'class': 'cdk-tree-node',
                            },
                        },] },
            ];
            /** @nocollapse */
            CdkTreeNode.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: CdkTree }
            ]; };
            CdkTreeNode.propDecorators = {
                role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Nested node is a child of `<cdk-tree>`. It works with nested tree.
             * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will
             * be added in the `cdkTreeNodeOutlet` in tree node template.
             * For example:
             *   ```html
             *   <cdk-nested-tree-node>
             *     {{node.name}}
             *     <ng-template cdkTreeNodeOutlet></ng-template>
             *   </cdk-nested-tree-node>
             *   ```
             * The children of node will be automatically added to `cdkTreeNodeOutlet`, the result dom will be
             * like this:
             *   ```html
             *   <cdk-nested-tree-node>
             *     {{node.name}}
             *      <cdk-nested-tree-node>{{child1.name}}</cdk-nested-tree-node>
             *      <cdk-nested-tree-node>{{child2.name}}</cdk-nested-tree-node>
             *   </cdk-nested-tree-node>
             *   ```
             * @template T
             */
            var CdkNestedTreeNode = /** @class */ (function (_super) {
                __extends(CdkNestedTreeNode, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _tree
                 * @param {?} _differs
                 */
                function CdkNestedTreeNode(_elementRef, _tree, _differs) {
                    var _this = _super.call(this, _elementRef, _tree) || this;
                    _this._elementRef = _elementRef;
                    _this._tree = _tree;
                    _this._differs = _differs;
                    return _this;
                }
                /**
                 * @return {?}
                 */
                CdkNestedTreeNode.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);
                    if (!this._tree.treeControl.getChildren) {
                        throw getTreeControlFunctionsMissingError();
                    }
                    /** @type {?} */
                    var childrenNodes = this._tree.treeControl.getChildren(this.data);
                    if (Array.isArray(childrenNodes)) {
                        this.updateChildrenNodes(( /** @type {?} */(childrenNodes)));
                    }
                    else if (childrenNodes instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__["Observable"]) {
                        childrenNodes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["takeUntil"])(this._destroyed))
                            .subscribe(( /**
                     * @param {?} result
                     * @return {?}
                     */function (/**
                     * @param {?} result
                     * @return {?}
                     */ result) { return _this.updateChildrenNodes(result); }));
                    }
                    this.nodeOutlet.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _this.updateChildrenNodes(); }));
                };
                /**
                 * @return {?}
                 */
                CdkNestedTreeNode.prototype.ngOnDestroy = function () {
                    this._clear();
                    _super.prototype.ngOnDestroy.call(this);
                };
                /**
                 * Add children dataNodes to the NodeOutlet
                 * @protected
                 * @param {?=} children
                 * @return {?}
                 */
                CdkNestedTreeNode.prototype.updateChildrenNodes = function (children) {
                    /** @type {?} */
                    var outlet = this._getNodeOutlet();
                    if (children) {
                        this._children = children;
                    }
                    if (outlet && this._children) {
                        /** @type {?} */
                        var viewContainer = outlet.viewContainer;
                        this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);
                    }
                    else {
                        // Reset the data differ if there's no children nodes displayed
                        this._dataDiffer.diff([]);
                    }
                };
                /**
                 * Clear the children dataNodes.
                 * @protected
                 * @return {?}
                 */
                CdkNestedTreeNode.prototype._clear = function () {
                    /** @type {?} */
                    var outlet = this._getNodeOutlet();
                    if (outlet) {
                        outlet.viewContainer.clear();
                        this._dataDiffer.diff([]);
                    }
                };
                /**
                 * Gets the outlet for the current node.
                 * @private
                 * @return {?}
                 */
                CdkNestedTreeNode.prototype._getNodeOutlet = function () {
                    var _this = this;
                    /** @type {?} */
                    var outlets = this.nodeOutlet;
                    // Note that since we use `descendants: true` on the query, we have to ensure
                    // that we don't pick up the outlet of a child node by accident.
                    return outlets && outlets.find(( /**
                     * @param {?} outlet
                     * @return {?}
                     */function (/**
                     * @param {?} outlet
                     * @return {?}
                     */ outlet) { return !outlet._node || outlet._node === _this; }));
                };
                return CdkNestedTreeNode;
            }(CdkTreeNode));
            CdkNestedTreeNode.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'cdk-nested-tree-node',
                            exportAs: 'cdkNestedTreeNode',
                            host: {
                                '[attr.aria-expanded]': 'isExpanded',
                                '[attr.role]': 'role',
                                'class': 'cdk-tree-node cdk-nested-tree-node',
                            },
                            providers: [
                                { provide: CdkTreeNode, useExisting: CdkNestedTreeNode },
                                { provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode }
                            ]
                        },] },
            ];
            /** @nocollapse */
            CdkNestedTreeNode.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: CdkTree },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["IterableDiffers"] }
            ]; };
            CdkNestedTreeNode.propDecorators = {
                nodeOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [CdkTreeNodeOutlet, {
                                // We need to use `descendants: true`, because Ivy will no longer match
                                // indirect descendants if it's left as false.
                                descendants: true
                            },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Regex used to split a string on its CSS units.
             * @type {?}
             */
            var cssUnitPattern = /([A-Za-z%]+)$/;
            /**
             * Indent for the children tree dataNodes.
             * This directive will add left-padding to the node to show hierarchy.
             * @template T
             */
            var CdkTreeNodePadding = /** @class */ (function () {
                /**
                 * @param {?} _treeNode
                 * @param {?} _tree
                 * @param {?} _renderer
                 * @param {?} _element
                 * @param {?} _dir
                 */
                function CdkTreeNodePadding(_treeNode, _tree, _renderer, _element, _dir) {
                    var _this = this;
                    this._treeNode = _treeNode;
                    this._tree = _tree;
                    this._renderer = _renderer;
                    this._element = _element;
                    this._dir = _dir;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * CSS units used for the indentation value.
                     */
                    this.indentUnits = 'px';
                    this._indent = 40;
                    this._setPadding();
                    if (_dir) {
                        _dir.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["takeUntil"])(this._destroyed)).subscribe(( /**
                         * @return {?}
                         */function () { return _this._setPadding(true); }));
                    }
                    // In Ivy the indentation binding might be set before the tree node's data has been added,
                    // which means that we'll miss the first render. We have to subscribe to changes in the
                    // data to ensure that everything is up to date.
                    _treeNode._dataChanges.subscribe(( /**
                     * @return {?}
                     */function () { return _this._setPadding(); }));
                }
                Object.defineProperty(CdkTreeNodePadding.prototype, "level", {
                    /**
                     * The level of depth of the tree node. The padding will be `level * indent` pixels.
                     * @return {?}
                     */
                    get: function () { return this._level; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        // Set to null as the fallback value so that _setPadding can fall back to the node level if the
                        // consumer set the directive as `cdkTreeNodePadding=""`. We still want to take this value if
                        // they set 0 explicitly.
                        this._level = ( /** @type {?} */(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__["coerceNumberProperty"])(value, null)));
                        this._setPadding();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CdkTreeNodePadding.prototype, "indent", {
                    /**
                     * The indent for each level. Can be a number or a CSS string.
                     * Default number 40px from material design menu sub-menu spec.
                     * @return {?}
                     */
                    get: function () { return this._indent; },
                    /**
                     * @param {?} indent
                     * @return {?}
                     */
                    set: function (indent) {
                        /** @type {?} */
                        var value = indent;
                        /** @type {?} */
                        var units = 'px';
                        if (typeof indent === 'string') {
                            /** @type {?} */
                            var parts = indent.split(cssUnitPattern);
                            value = parts[0];
                            units = parts[1] || units;
                        }
                        this.indentUnits = units;
                        this._indent = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__["coerceNumberProperty"])(value);
                        this._setPadding();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                CdkTreeNodePadding.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * The padding indent value for the tree node. Returns a string with px numbers if not null.
                 * @return {?}
                 */
                CdkTreeNodePadding.prototype._paddingIndent = function () {
                    /** @type {?} */
                    var nodeLevel = (this._treeNode.data && this._tree.treeControl.getLevel)
                        ? this._tree.treeControl.getLevel(this._treeNode.data)
                        : null;
                    /** @type {?} */
                    var level = this._level == null ? nodeLevel : this._level;
                    return typeof level === 'number' ? "" + level * this._indent + this.indentUnits : null;
                };
                /**
                 * @param {?=} forceChange
                 * @return {?}
                 */
                CdkTreeNodePadding.prototype._setPadding = function (forceChange) {
                    if (forceChange === void 0) { forceChange = false; }
                    /** @type {?} */
                    var padding = this._paddingIndent();
                    if (padding !== this._currentPadding || forceChange) {
                        /** @type {?} */
                        var element = this._element.nativeElement;
                        /** @type {?} */
                        var paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';
                        /** @type {?} */
                        var resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';
                        this._renderer.setStyle(element, paddingProp, padding);
                        this._renderer.setStyle(element, resetProp, null);
                        this._currentPadding = padding;
                    }
                };
                return CdkTreeNodePadding;
            }());
            CdkTreeNodePadding.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[cdkTreeNodePadding]',
                        },] },
            ];
            /** @nocollapse */
            CdkTreeNodePadding.ctorParameters = function () { return [
                { type: CdkTreeNode },
                { type: CdkTree },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Renderer2"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] }
            ]; };
            CdkTreeNodePadding.propDecorators = {
                level: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkTreeNodePadding',] }],
                indent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkTreeNodePaddingIndent',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Node toggle to expand/collapse the node.
             * @template T
             */
            var CdkTreeNodeToggle = /** @class */ (function () {
                /**
                 * @param {?} _tree
                 * @param {?} _treeNode
                 */
                function CdkTreeNodeToggle(_tree, _treeNode) {
                    this._tree = _tree;
                    this._treeNode = _treeNode;
                    this._recursive = false;
                }
                Object.defineProperty(CdkTreeNodeToggle.prototype, "recursive", {
                    /**
                     * Whether expand/collapse the node recursively.
                     * @return {?}
                     */
                    get: function () { return this._recursive; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._recursive = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @param {?} event
                 * @return {?}
                 */
                CdkTreeNodeToggle.prototype._toggle = function (event) {
                    this.recursive
                        ? this._tree.treeControl.toggleDescendants(this._treeNode.data)
                        : this._tree.treeControl.toggle(this._treeNode.data);
                    event.stopPropagation();
                };
                return CdkTreeNodeToggle;
            }());
            CdkTreeNodeToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{ selector: '[cdkTreeNodeToggle]' },] },
            ];
            /** @nocollapse */
            CdkTreeNodeToggle.ctorParameters = function () { return [
                { type: CdkTree },
                { type: CdkTreeNode }
            ]; };
            CdkTreeNodeToggle.propDecorators = {
                recursive: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['cdkTreeNodeToggleRecursive',] }],
                _toggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["HostListener"], args: ['click', ['$event'],] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var EXPORTED_DECLARATIONS = [
                CdkNestedTreeNode,
                CdkTreeNodeDef,
                CdkTreeNodePadding,
                CdkTreeNodeToggle,
                CdkTree,
                CdkTreeNode,
                CdkTreeNodeOutlet,
            ];
            var CdkTreeModule = /** @class */ (function () {
                function CdkTreeModule() {
                }
                return CdkTreeModule;
            }());
            CdkTreeModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"]],
                            exports: EXPORTED_DECLARATIONS,
                            declarations: EXPORTED_DECLARATIONS,
                            providers: [_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__["FocusMonitor"], CdkTreeNodeDef]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=tree.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/autocomplete.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/autocomplete.js ***!
          \****************************************************************/
        /*! exports provided: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MatAutocompleteSelectedEvent, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, getMatAutocompleteMissingPanelError, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocompleteTrigger, MatAutocompleteOrigin */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY", function () { return MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteSelectedEvent", function () { return MatAutocompleteSelectedEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS", function () { return MAT_AUTOCOMPLETE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocomplete", function () { return MatAutocomplete; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteModule", function () { return MatAutocompleteModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMatAutocompleteMissingPanelError", function () { return getMatAutocompleteMissingPanelError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_OPTION_HEIGHT", function () { return AUTOCOMPLETE_OPTION_HEIGHT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_PANEL_HEIGHT", function () { return AUTOCOMPLETE_PANEL_HEIGHT; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_VALUE_ACCESSOR", function () { return MAT_AUTOCOMPLETE_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteTrigger", function () { return MatAutocompleteTrigger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteOrigin", function () { return MatAutocompleteOrigin; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Autocomplete IDs need to be unique across components, so this counter exists outside of
             * the component definition.
             * @type {?}
             */
            var _uniqueAutocompleteIdCounter = 0;
            /**
             * Event object that is emitted when an autocomplete option is selected.
             */
            var MatAutocompleteSelectedEvent = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} option
                 */
                function MatAutocompleteSelectedEvent(source, option) {
                    this.source = source;
                    this.option = option;
                }
                return MatAutocompleteSelectedEvent;
            }());
            // Boilerplate for applying mixins to MatAutocomplete.
            /**
             * \@docs-private
             */
            var MatAutocompleteBase = /** @class */ (function () {
                function MatAutocompleteBase() {
                }
                return MatAutocompleteBase;
            }());
            /** @type {?} */
            var _MatAutocompleteMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisableRipple"])(MatAutocompleteBase);
            /**
             * Injection token to be used to override the default options for `mat-autocomplete`.
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('mat-autocomplete-default-options', {
                providedIn: 'root',
                factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {
                return { autoActiveFirstOption: false };
            }
            var MatAutocomplete = /** @class */ (function (_super) {
                __extends(MatAutocomplete, _super);
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} defaults
                 */
                function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {
                    var _this = _super.call(this) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._elementRef = _elementRef;
                    /**
                     * Whether the autocomplete panel should be visible, depending on option length.
                     */
                    _this.showPanel = false;
                    _this._isOpen = false;
                    /**
                     * Function that maps an option's control value to its display value in the trigger.
                     */
                    _this.displayWith = null;
                    /**
                     * Event that is emitted whenever an option from the list is selected.
                     */
                    _this.optionSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    /**
                     * Event that is emitted when the autocomplete panel is opened.
                     */
                    _this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    /**
                     * Event that is emitted when the autocomplete panel is closed.
                     */
                    _this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
                    _this._classList = {};
                    /**
                     * Unique ID to be used by autocomplete trigger's "aria-owns" property.
                     */
                    _this.id = "mat-autocomplete-" + _uniqueAutocompleteIdCounter++;
                    _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;
                    return _this;
                }
                Object.defineProperty(MatAutocomplete.prototype, "isOpen", {
                    /**
                     * Whether the autocomplete panel is open.
                     * @return {?}
                     */
                    get: function () { return this._isOpen && this.showPanel; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocomplete.prototype, "autoActiveFirstOption", {
                    /**
                     * Whether the first option should be highlighted when the autocomplete panel is opened.
                     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.
                     * @return {?}
                     */
                    get: function () { return this._autoActiveFirstOption; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._autoActiveFirstOption = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocomplete.prototype, "classList", {
                    /**
                     * Takes classes set on the host mat-autocomplete element and applies them to the panel
                     * inside the overlay container to allow for easy styling.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value && value.length) {
                            this._classList = value.split(' ').reduce(( /**
                             * @param {?} classList
                             * @param {?} className
                             * @return {?}
                             */function (classList, className) {
                                classList[className.trim()] = true;
                                return classList;
                            }), ( /** @type {?} */({})));
                        }
                        else {
                            this._classList = {};
                        }
                        this._setVisibilityClasses(this._classList);
                        this._elementRef.nativeElement.className = '';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAutocomplete.prototype.ngAfterContentInit = function () {
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["ActiveDescendantKeyManager"](this.options).withWrap();
                    // Set the initial visibility state.
                    this._setVisibility();
                };
                /**
                 * Sets the panel scrollTop. This allows us to manually scroll to display options
                 * above or below the fold, as they are not actually being focused when active.
                 * @param {?} scrollTop
                 * @return {?}
                 */
                MatAutocomplete.prototype._setScrollTop = function (scrollTop) {
                    if (this.panel) {
                        this.panel.nativeElement.scrollTop = scrollTop;
                    }
                };
                /**
                 * Returns the panel's scrollTop.
                 * @return {?}
                 */
                MatAutocomplete.prototype._getScrollTop = function () {
                    return this.panel ? this.panel.nativeElement.scrollTop : 0;
                };
                /**
                 * Panel should hide itself when the option list is empty.
                 * @return {?}
                 */
                MatAutocomplete.prototype._setVisibility = function () {
                    this.showPanel = !!this.options.length;
                    this._setVisibilityClasses(this._classList);
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Emits the `select` event.
                 * @param {?} option
                 * @return {?}
                 */
                MatAutocomplete.prototype._emitSelectEvent = function (option) {
                    /** @type {?} */
                    var event = new MatAutocompleteSelectedEvent(this, option);
                    this.optionSelected.emit(event);
                };
                /**
                 * Sets the autocomplete visibility classes on a classlist based on the panel is visible.
                 * @private
                 * @param {?} classList
                 * @return {?}
                 */
                MatAutocomplete.prototype._setVisibilityClasses = function (classList) {
                    classList['mat-autocomplete-visible'] = this.showPanel;
                    classList['mat-autocomplete-hidden'] = !this.showPanel;
                };
                return MatAutocomplete;
            }(_MatAutocompleteMixinBase));
            MatAutocomplete.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"], args: [{ selector: 'mat-autocomplete',
                            template: "<ng-template><div class=\"mat-autocomplete-panel\" role=\"listbox\" [id]=\"id\" [ngClass]=\"_classList\" #panel><ng-content></ng-content></div></ng-template>",
                            styles: [".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}@media (-ms-high-contrast:active){.mat-autocomplete-panel{outline:solid 1px}}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
                            exportAs: 'matAutocomplete',
                            inputs: ['disableRipple'],
                            host: {
                                'class': 'mat-autocomplete'
                            },
                            providers: [
                                { provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MAT_OPTION_PARENT_COMPONENT"], useExisting: MatAutocomplete }
                            ]
                        },] },
            ];
            /** @nocollapse */
            MatAutocomplete.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatAutocomplete.propDecorators = {
                template: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["TemplateRef"], { static: true },] }],
                panel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewChild"], args: ['panel', { static: false },] }],
                options: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOption"], { descendants: true },] }],
                optionGroups: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptgroup"],] }],
                displayWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                autoActiveFirstOption: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                panelWidth: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"] }],
                optionSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"] }],
                classList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['class',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive applied to an element to make it usable
             * as a connection point for an autocomplete panel.
             */
            var MatAutocompleteOrigin = /** @class */ (function () {
                /**
                 * @param {?} elementRef
                 */
                function MatAutocompleteOrigin(elementRef) {
                    this.elementRef = elementRef;
                }
                return MatAutocompleteOrigin;
            }());
            MatAutocompleteOrigin.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: '[matAutocompleteOrigin]',
                            exportAs: 'matAutocompleteOrigin',
                        },] },
            ];
            /** @nocollapse */
            MatAutocompleteOrigin.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * The height of each autocomplete option.
             * @type {?}
             */
            var AUTOCOMPLETE_OPTION_HEIGHT = 48;
            /**
             * The total height of the autocomplete panel.
             * @type {?}
             */
            var AUTOCOMPLETE_PANEL_HEIGHT = 256;
            /**
             * Injection token that determines the scroll handling while the autocomplete panel is open.
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["InjectionToken"]('mat-autocomplete-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"]],
                useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,
            };
            /**
             * Provider that allows the autocomplete to register as a ControlValueAccessor.
             * \@docs-private
             * @type {?}
             */
            var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatAutocompleteTrigger; })),
                multi: true
            };
            /**
             * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
             * \@docs-private
             * @return {?}
             */
            function getMatAutocompleteMissingPanelError() {
                return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +
                    'Make sure that the id passed to the `matAutocomplete` is correct and that ' +
                    'you\'re attempting to open it after the ngAfterContentInit hook.');
            }
            var MatAutocompleteTrigger = /** @class */ (function () {
                /**
                 * @param {?} _element
                 * @param {?} _overlay
                 * @param {?} _viewContainerRef
                 * @param {?} _zone
                 * @param {?} _changeDetectorRef
                 * @param {?} scrollStrategy
                 * @param {?} _dir
                 * @param {?} _formField
                 * @param {?} _document
                 * @param {?=} _viewportRuler
                 */
                function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler) {
                    var _this = this;
                    this._element = _element;
                    this._overlay = _overlay;
                    this._viewContainerRef = _viewContainerRef;
                    this._zone = _zone;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dir = _dir;
                    this._formField = _formField;
                    this._document = _document;
                    this._viewportRuler = _viewportRuler;
                    this._componentDestroyed = false;
                    this._autocompleteDisabled = false;
                    /**
                     * Whether or not the label state is being overridden.
                     */
                    this._manuallyFloatingLabel = false;
                    /**
                     * Subscription to viewport size changes.
                     */
                    this._viewportSubscription = rxjs__WEBPACK_IMPORTED_MODULE_13__["Subscription"].EMPTY;
                    /**
                     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,
                     * closed autocomplete from being reopened if the user switches to another browser tab and then
                     * comes back.
                     */
                    this._canOpenOnNextFocus = true;
                    /**
                     * Stream of keyboard events that can close the panel.
                     */
                    this._closeKeyEventStream = new rxjs__WEBPACK_IMPORTED_MODULE_13__["Subject"]();
                    /**
                     * Event handler for when the window is blurred. Needs to be an
                     * arrow function in order to preserve the context.
                     */
                    this._windowBlurHandler = ( /**
                     * @return {?}
                     */function () {
                        // If the user blurred the window while the autocomplete is focused, it means that it'll be
                        // refocused when they come back. In this case we want to skip the first focus event, if the
                        // pane was closed, in order to avoid reopening it unintentionally.
                        _this._canOpenOnNextFocus =
                            _this._document.activeElement !== _this._element.nativeElement || _this.panelOpen;
                    });
                    /**
                     * `View -> model callback called when value changes`
                     */
                    this._onChange = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * `View -> model callback called when autocomplete has been touched`
                     */
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Position of the autocomplete panel relative to the trigger element. A position of `auto`
                     * will render the panel underneath the trigger if there is enough space for it to fit in
                     * the viewport, otherwise the panel will be shown above it. If the position is set to
                     * `above` or `below`, the panel will always be shown above or below the trigger. no matter
                     * whether it fits completely in the viewport.
                     */
                    this.position = 'auto';
                    /**
                     * `autocomplete` attribute to be set on the input element.
                     * \@docs-private
                     */
                    this.autocompleteAttribute = 'off';
                    this._overlayAttached = false;
                    /**
                     * Stream of autocomplete option selections.
                     */
                    this.optionSelections = ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["defer"])(( /**
                     * @return {?}
                     */function () {
                        if (_this.autocomplete && _this.autocomplete.options) {
                            return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"]).apply(void 0, __spread(_this.autocomplete.options.map(( /**
                             * @param {?} option
                             * @return {?}
                             */function (/**
                             * @param {?} option
                             * @return {?}
                             */ option) { return option.onSelectionChange; }))));
                        }
                        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.
                        // Return a stream that we'll replace with the real one once everything is in place.
                        return _this._zone.onStable
                            .asObservable()
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["switchMap"])(( /**
                     * @return {?}
                     */function () { return _this.optionSelections; })));
                    }))));
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatAutocompleteTrigger.prototype, "autocompleteDisabled", {
                    /**
                     * Whether the autocomplete is disabled. When disabled, the element will
                     * act as a regular input and the user won't be able to open the panel.
                     * @return {?}
                     */
                    get: function () { return this._autocompleteDisabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._autocompleteDisabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    if (typeof window !== 'undefined') {
                        this._zone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            window.addEventListener('blur', _this._windowBlurHandler);
                        }));
                        if (Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__["_supportsShadowDom"])()) {
                            /** @type {?} */
                            var element = this._element.nativeElement;
                            /** @type {?} */
                            var rootNode = element.getRootNode ? element.getRootNode() : null;
                            // We need to take the `ShadowRoot` off of `window`, because the built-in types are
                            // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.
                            this._isInsideShadowRoot = rootNode instanceof (( /** @type {?} */(window))).ShadowRoot;
                        }
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngOnChanges = function (changes) {
                    if (changes['position'] && this._positionStrategy) {
                        this._setStrategyPositions(this._positionStrategy);
                        if (this.panelOpen) {
                            ( /** @type {?} */(this._overlayRef)).updatePosition();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.ngOnDestroy = function () {
                    if (typeof window !== 'undefined') {
                        window.removeEventListener('blur', this._windowBlurHandler);
                    }
                    this._viewportSubscription.unsubscribe();
                    this._componentDestroyed = true;
                    this._destroyPanel();
                    this._closeKeyEventStream.complete();
                };
                Object.defineProperty(MatAutocompleteTrigger.prototype, "panelOpen", {
                    /**
                     * Whether or not the autocomplete panel is open.
                     * @return {?}
                     */
                    get: function () {
                        return this._overlayAttached && this.autocomplete.showPanel;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens the autocomplete suggestion panel.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.openPanel = function () {
                    this._attachOverlay();
                    this._floatLabel();
                };
                /**
                 * Closes the autocomplete suggestion panel.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.closePanel = function () {
                    this._resetLabel();
                    if (!this._overlayAttached) {
                        return;
                    }
                    if (this.panelOpen) {
                        // Only emit if the panel was visible.
                        this.autocomplete.closed.emit();
                    }
                    this.autocomplete._isOpen = this._overlayAttached = false;
                    if (this._overlayRef && this._overlayRef.hasAttached()) {
                        this._overlayRef.detach();
                        this._closingActionsSubscription.unsubscribe();
                    }
                    // Note that in some cases this can end up being called after the component is destroyed.
                    // Add a check to ensure that we don't try to run change detection on a destroyed view.
                    if (!this._componentDestroyed) {
                        // We need to trigger change detection manually, because
                        // `fromEvent` doesn't seem to do it at the proper time.
                        // This ensures that the label is reset when the
                        // user clicks outside.
                        this._changeDetectorRef.detectChanges();
                    }
                };
                /**
                 * Updates the position of the autocomplete suggestion panel to ensure that it fits all options
                 * within the viewport.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.updatePosition = function () {
                    if (this._overlayAttached) {
                        ( /** @type {?} */(this._overlayRef)).updatePosition();
                    }
                };
                Object.defineProperty(MatAutocompleteTrigger.prototype, "panelClosingActions", {
                    /**
                     * A stream of actions that should close the autocomplete panel, including
                     * when an option is selected, on blur, and when TAB is pressed.
                     * @return {?}
                     */
                    get: function () {
                        var _this = this;
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                         * @return {?}
                         */function () { return _this._overlayAttached; }))), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?
                            this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                             * @return {?}
                             */function () { return _this._overlayAttached; }))) :
                            Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["of"])()).pipe(
                        // Normalize the output so we return a consistent type.
                        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["map"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return event instanceof _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionSelectionChange"] ? event : null; })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatAutocompleteTrigger.prototype, "activeOption", {
                    /**
                     * The currently active option, coerced to MatOption type.
                     * @return {?}
                     */
                    get: function () {
                        if (this.autocomplete && this.autocomplete._keyManager) {
                            return this.autocomplete._keyManager.activeItem;
                        }
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Stream of clicks outside of the autocomplete panel.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOutsideClickStream = function () {
                    var _this = this;
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["fromEvent"])(this._document, 'click'))), ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["fromEvent"])(this._document, 'touchend'))))
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["filter"])(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        // If we're in the Shadow DOM, the event target will be the shadow root, so we have to
                        // fall back to check the first element in the path of the click event.
                        /** @type {?} */
                        var clickTarget = ( /** @type {?} */((_this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :
                            event.target)));
                        /** @type {?} */
                        var formField = _this._formField ? _this._formField._elementRef.nativeElement : null;
                        return _this._overlayAttached && clickTarget !== _this._element.nativeElement &&
                            (!formField || !formField.contains(clickTarget)) &&
                            (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));
                    })));
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.writeValue = function (value) {
                    var _this = this;
                    Promise.resolve(null).then(( /**
                     * @return {?}
                     */function () { return _this._setTriggerValue(value); }));
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype.setDisabledState = function (isDisabled) {
                    this._element.nativeElement.disabled = isDisabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    // Prevent the default action on all escape key presses. This is here primarily to bring IE
                    // in line with other browsers. By default, pressing escape on IE will cause it to revert
                    // the input value to the one that it had on focus, however it won't dispatch any events
                    // which means that the model value will be out of sync with the view.
                    if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"]) {
                        event.preventDefault();
                    }
                    if (this.activeOption && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ENTER"] && this.panelOpen) {
                        this.activeOption._selectViaInteraction();
                        this._resetActiveItem();
                        event.preventDefault();
                    }
                    else if (this.autocomplete) {
                        /** @type {?} */
                        var prevActiveItem = this.autocomplete._keyManager.activeItem;
                        /** @type {?} */
                        var isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["DOWN_ARROW"];
                        if (this.panelOpen || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["TAB"]) {
                            this.autocomplete._keyManager.onKeydown(event);
                        }
                        else if (isArrowKey && this._canOpen()) {
                            this.openPanel();
                        }
                        if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {
                            this._scrollToOption();
                        }
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleInput = function (event) {
                    /** @type {?} */
                    var target = ( /** @type {?} */(event.target));
                    /** @type {?} */
                    var value = target.value;
                    // Based on `NumberValueAccessor` from forms.
                    if (target.type === 'number') {
                        value = value == '' ? null : parseFloat(value);
                    }
                    // If the input has a placeholder, IE will fire the `input` event on page load,
                    // focus and blur, in addition to when the user actually changed the value. To
                    // filter out all of the extra events, we save the value on focus and between
                    // `input` events, and we check whether it changed.
                    // See: https://connect.microsoft.com/IE/feedback/details/885747/
                    if (this._previousValue !== value) {
                        this._previousValue = value;
                        this._onChange(value);
                        if (this._canOpen() && this._document.activeElement === event.target) {
                            this.openPanel();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._handleFocus = function () {
                    if (!this._canOpenOnNextFocus) {
                        this._canOpenOnNextFocus = true;
                    }
                    else if (this._canOpen()) {
                        this._previousValue = this._element.nativeElement.value;
                        this._attachOverlay();
                        this._floatLabel(true);
                    }
                };
                /**
                 * In "auto" mode, the label will animate down as soon as focus is lost.
                 * This causes the value to jump when selecting an option with the mouse.
                 * This method manually floats the label until the panel can be closed.
                 * @private
                 * @param {?=} shouldAnimate Whether the label should be animated when it is floated.
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._floatLabel = function (shouldAnimate) {
                    if (shouldAnimate === void 0) { shouldAnimate = false; }
                    if (this._formField && this._formField.floatLabel === 'auto') {
                        if (shouldAnimate) {
                            this._formField._animateAndLockLabel();
                        }
                        else {
                            this._formField.floatLabel = 'always';
                        }
                        this._manuallyFloatingLabel = true;
                    }
                };
                /**
                 * If the label has been manually elevated, return it to its normal state.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._resetLabel = function () {
                    if (this._manuallyFloatingLabel) {
                        this._formField.floatLabel = 'auto';
                        this._manuallyFloatingLabel = false;
                    }
                };
                /**
                 * Given that we are not actually focusing active options, we must manually adjust scroll
                 * to reveal options below the fold. First, we find the offset of the option from the top
                 * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
                 * the panel height + the option height, so the active option will be just visible at the
                 * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
                 * will become the offset. If that offset is visible within the panel already, the scrollTop is
                 * not adjusted.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._scrollToOption = function () {
                    /** @type {?} */
                    var index = this.autocomplete._keyManager.activeItemIndex || 0;
                    /** @type {?} */
                    var labelCount = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["_countGroupLabelsBeforeOption"])(index, this.autocomplete.options, this.autocomplete.optionGroups);
                    if (index === 0 && labelCount === 1) {
                        // If we've got one group label before the option and we're at the top option,
                        // scroll the list to the top. This is better UX than scrolling the list to the
                        // top of the option, because it allows the user to read the top group's label.
                        this.autocomplete._setScrollTop(0);
                    }
                    else {
                        /** @type {?} */
                        var newScrollPosition = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["_getOptionScrollPosition"])(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);
                        this.autocomplete._setScrollTop(newScrollPosition);
                    }
                };
                /**
                 * This method listens to a stream of panel closing actions and resets the
                 * stream every time the option list changes.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._subscribeToClosingActions = function () {
                    var _this = this;
                    /** @type {?} */
                    var firstStable = this._zone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1));
                    /** @type {?} */
                    var optionChanges = this.autocomplete.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["tap"])(( /**
                     * @return {?}
                     */function () { return _this._positionStrategy.reapplyLastPosition(); })), 
                    // Defer emitting to the stream until the next tick, because changing
                    // bindings in here will cause "changed after checked" errors.
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["delay"])(0));
                    // When the zone is stable initially, and when the option list changes...
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_13__["merge"])(firstStable, optionChanges)
                        .pipe(
                    // create a new stream of panelClosingActions, replacing any previous streams
                    // that were created, and flatten it so our stream only emits closing events...
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["switchMap"])(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var wasOpen = _this.panelOpen;
                        _this._resetActiveItem();
                        _this.autocomplete._setVisibility();
                        if (_this.panelOpen) {
                            ( /** @type {?} */(_this._overlayRef)).updatePosition();
                            // If the `panelOpen` state changed, we need to make sure to emit the `opened`
                            // event, because we may not have emitted it when the panel was attached. This
                            // can happen if the users opens the panel and there are no options, but the
                            // options come in slightly later or as a result of the value changing.
                            if (wasOpen !== _this.panelOpen) {
                                _this.autocomplete.opened.emit();
                            }
                        }
                        return _this.panelClosingActions;
                    })), 
                    // when the first closing event occurs...
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_14__["take"])(1))
                        // set the value, close the panel, and complete.
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) { return _this._setValueAndClose(event); }));
                };
                /**
                 * Destroys the autocomplete suggestion panel.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._destroyPanel = function () {
                    if (this._overlayRef) {
                        this.closePanel();
                        this._overlayRef.dispose();
                        this._overlayRef = null;
                    }
                };
                /**
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setTriggerValue = function (value) {
                    /** @type {?} */
                    var toDisplay = this.autocomplete && this.autocomplete.displayWith ?
                        this.autocomplete.displayWith(value) :
                        value;
                    // Simply falling back to an empty string if the display value is falsy does not work properly.
                    // The display value can also be the number zero and shouldn't fall back to an empty string.
                    /** @type {?} */
                    var inputValue = toDisplay != null ? toDisplay : '';
                    // If it's used within a `MatFormField`, we should set it through the property so it can go
                    // through change detection.
                    if (this._formField) {
                        this._formField._control.value = inputValue;
                    }
                    else {
                        this._element.nativeElement.value = inputValue;
                    }
                    this._previousValue = inputValue;
                };
                /**
                 * This method closes the panel, and if a value is specified, also sets the associated
                 * control to that value. It will also mark the control as dirty if this interaction
                 * stemmed from the user.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setValueAndClose = function (event) {
                    if (event && event.source) {
                        this._clearPreviousSelectedOption(event.source);
                        this._setTriggerValue(event.source.value);
                        this._onChange(event.source.value);
                        this._element.nativeElement.focus();
                        this.autocomplete._emitSelectEvent(event.source);
                    }
                    this.closePanel();
                };
                /**
                 * Clear any previous selected option and emit a selection change event for this option
                 * @private
                 * @param {?} skip
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {
                    this.autocomplete.options.forEach(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) {
                        if (option != skip && option.selected) {
                            option.deselect();
                        }
                    }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._attachOverlay = function () {
                    var _this = this;
                    if (!this.autocomplete) {
                        throw getMatAutocompleteMissingPanelError();
                    }
                    /** @type {?} */
                    var overlayRef = this._overlayRef;
                    if (!overlayRef) {
                        this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_8__["TemplatePortal"](this.autocomplete.template, this._viewContainerRef);
                        overlayRef = this._overlay.create(this._getOverlayConfig());
                        this._overlayRef = overlayRef;
                        // Use the `keydownEvents` in order to take advantage of
                        // the overlay event targeting provided by the CDK overlay.
                        overlayRef.keydownEvents().subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.
                            // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction
                            if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"] || (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["UP_ARROW"] && event.altKey)) {
                                _this._resetActiveItem();
                                _this._closeKeyEventStream.next();
                                // We need to stop propagation, otherwise the event will eventually
                                // reach the input itself and cause the overlay to be reopened.
                                event.stopPropagation();
                                event.preventDefault();
                            }
                        }));
                        if (this._viewportRuler) {
                            this._viewportSubscription = this._viewportRuler.change().subscribe(( /**
                             * @return {?}
                             */function () {
                                if (_this.panelOpen && overlayRef) {
                                    overlayRef.updateSize({ width: _this._getPanelWidth() });
                                }
                            }));
                        }
                    }
                    else {
                        // Update the trigger, panel width and direction, in case anything has changed.
                        this._positionStrategy.setOrigin(this._getConnectedElement());
                        overlayRef.updateSize({ width: this._getPanelWidth() });
                    }
                    if (overlayRef && !overlayRef.hasAttached()) {
                        overlayRef.attach(this._portal);
                        this._closingActionsSubscription = this._subscribeToClosingActions();
                    }
                    /** @type {?} */
                    var wasOpen = this.panelOpen;
                    this.autocomplete._setVisibility();
                    this.autocomplete._isOpen = this._overlayAttached = true;
                    // We need to do an extra `panelOpen` check in here, because the
                    // autocomplete won't be shown if there are no options.
                    if (this.panelOpen && wasOpen !== this.panelOpen) {
                        this.autocomplete.opened.emit();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOverlayConfig = function () {
                    return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayConfig"]({
                        positionStrategy: this._getOverlayPosition(),
                        scrollStrategy: this._scrollStrategy(),
                        width: this._getPanelWidth(),
                        direction: this._dir
                    });
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getOverlayPosition = function () {
                    /** @type {?} */
                    var strategy = this._overlay.position()
                        .flexibleConnectedTo(this._getConnectedElement())
                        .withFlexibleDimensions(false)
                        .withPush(false);
                    this._setStrategyPositions(strategy);
                    this._positionStrategy = strategy;
                    return strategy;
                };
                /**
                 * Sets the positions on a position strategy based on the directive's input state.
                 * @private
                 * @param {?} positionStrategy
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._setStrategyPositions = function (positionStrategy) {
                    /** @type {?} */
                    var belowPosition = {
                        originX: 'start',
                        originY: 'bottom',
                        overlayX: 'start',
                        overlayY: 'top'
                    };
                    /** @type {?} */
                    var abovePosition = {
                        originX: 'start',
                        originY: 'top',
                        overlayX: 'start',
                        overlayY: 'bottom',
                        // The overlay edge connected to the trigger should have squared corners, while
                        // the opposite end has rounded corners. We apply a CSS class to swap the
                        // border-radius based on the overlay position.
                        panelClass: 'mat-autocomplete-panel-above'
                    };
                    /** @type {?} */
                    var positions;
                    if (this.position === 'above') {
                        positions = [abovePosition];
                    }
                    else if (this.position === 'below') {
                        positions = [belowPosition];
                    }
                    else {
                        positions = [belowPosition, abovePosition];
                    }
                    positionStrategy.withPositions(positions);
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getConnectedElement = function () {
                    if (this.connectedTo) {
                        return this.connectedTo.elementRef;
                    }
                    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getPanelWidth = function () {
                    return this.autocomplete.panelWidth || this._getHostWidth();
                };
                /**
                 * Returns the width of the input element, so the panel width can match it.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._getHostWidth = function () {
                    return this._getConnectedElement().nativeElement.getBoundingClientRect().width;
                };
                /**
                 * Resets the active item to -1 so arrow events will activate the
                 * correct options, or to 0 if the consumer opted into it.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._resetActiveItem = function () {
                    this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);
                };
                /**
                 * Determines whether the panel can be opened.
                 * @private
                 * @return {?}
                 */
                MatAutocompleteTrigger.prototype._canOpen = function () {
                    /** @type {?} */
                    var element = this._element.nativeElement;
                    return !element.readOnly && !element.disabled && !this._autocompleteDisabled;
                };
                return MatAutocompleteTrigger;
            }());
            MatAutocompleteTrigger.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: "input[matAutocomplete], textarea[matAutocomplete]",
                            host: {
                                'class': 'mat-autocomplete-trigger',
                                '[attr.autocomplete]': 'autocompleteAttribute',
                                '[attr.role]': 'autocompleteDisabled ? null : "combobox"',
                                '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : "list"',
                                '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',
                                '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',
                                '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',
                                '[attr.aria-haspopup]': '!autocompleteDisabled',
                                // Note: we use `focusin`, as opposed to `focus`, in order to open the panel
                                // a little earlier. This avoids issues where IE delays the focusing of the input.
                                '(focusin)': '_handleFocus()',
                                '(blur)': '_onTouched()',
                                '(input)': '_handleInput($event)',
                                '(keydown)': '_handleKeydown($event)',
                            },
                            exportAs: 'matAutocompleteTrigger',
                            providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]
                        },] },
            ];
            /** @nocollapse */
            MatAutocompleteTrigger.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewContainerRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_4__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }] },
                { type: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__["MatFormField"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Host"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__["DOCUMENT"],] }] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_9__["ViewportRuler"] }
            ]; };
            MatAutocompleteTrigger.propDecorators = {
                autocomplete: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocomplete',] }],
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompletePosition',] }],
                connectedTo: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompleteConnectedTo',] }],
                autocompleteAttribute: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['autocomplete',] }],
                autocompleteDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matAutocompleteDisabled',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatAutocompleteModule = /** @class */ (function () {
                function MatAutocompleteModule() {
                }
                return MatAutocompleteModule;
            }());
            MatAutocompleteModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionModule"], _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_6__["OverlayModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_10__["CommonModule"]],
                            exports: [
                                MatAutocomplete,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatOptionModule"],
                                MatAutocompleteTrigger,
                                MatAutocompleteOrigin,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]
                            ],
                            declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],
                            providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=autocomplete.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/badge.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/badge.js ***!
          \*********************************************************/
        /*! exports provided: MatBadgeModule, MatBadge */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBadgeModule", function () { return MatBadgeModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBadge", function () { return MatBadge; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var nextId = 0;
            // Boilerplate for applying mixins to MatBadge.
            /**
             * \@docs-private
             */
            var MatBadgeBase = /** @class */ (function () {
                function MatBadgeBase() {
                }
                return MatBadgeBase;
            }());
            /** @type {?} */
            var _MatBadgeMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinDisabled"])(MatBadgeBase);
            /**
             * Directive to display a text badge.
             */
            var MatBadge = /** @class */ (function (_super) {
                __extends(MatBadge, _super);
                /**
                 * @param {?} _ngZone
                 * @param {?} _elementRef
                 * @param {?} _ariaDescriber
                 * @param {?} _renderer
                 * @param {?=} _animationMode
                 */
                function MatBadge(_ngZone, _elementRef, _ariaDescriber, _renderer, _animationMode) {
                    var _this = _super.call(this) || this;
                    _this._ngZone = _ngZone;
                    _this._elementRef = _elementRef;
                    _this._ariaDescriber = _ariaDescriber;
                    _this._renderer = _renderer;
                    _this._animationMode = _animationMode;
                    /**
                     * Whether the badge has any content.
                     */
                    _this._hasContent = false;
                    _this._color = 'primary';
                    _this._overlap = true;
                    /**
                     * Position the badge should reside.
                     * Accepts any combination of 'above'|'below' and 'before'|'after'
                     */
                    _this.position = 'above after';
                    /**
                     * Size of the badge. Can be 'small', 'medium', or 'large'.
                     */
                    _this.size = 'medium';
                    /**
                     * Unique id for the badge
                     */
                    _this._id = nextId++;
                    if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["isDevMode"])()) {
                        /** @type {?} */
                        var nativeElement = _elementRef.nativeElement;
                        if (nativeElement.nodeType !== nativeElement.ELEMENT_NODE) {
                            throw Error('matBadge must be attached to an element node.');
                        }
                    }
                    return _this;
                }
                Object.defineProperty(MatBadge.prototype, "color", {
                    /**
                     * The color of the badge. Can be `primary`, `accent`, or `warn`.
                     * @return {?}
                     */
                    get: function () { return this._color; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._setColor(value);
                        this._color = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatBadge.prototype, "overlap", {
                    /**
                     * Whether the badge should overlap its contents or not
                     * @return {?}
                     */
                    get: function () { return this._overlap; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) {
                        this._overlap = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(val);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatBadge.prototype, "description", {
                    /**
                     * Message used to describe the decorated element via aria-describedby
                     * @return {?}
                     */
                    get: function () { return this._description; },
                    /**
                     * @param {?} newDescription
                     * @return {?}
                     */
                    set: function (newDescription) {
                        if (newDescription !== this._description) {
                            /** @type {?} */
                            var badgeElement = this._badgeElement;
                            this._updateHostAriaDescription(newDescription, this._description);
                            this._description = newDescription;
                            if (badgeElement) {
                                newDescription ? badgeElement.setAttribute('aria-label', newDescription) :
                                    badgeElement.removeAttribute('aria-label');
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatBadge.prototype, "hidden", {
                    /**
                     * Whether the badge is hidden.
                     * @return {?}
                     */
                    get: function () { return this._hidden; },
                    /**
                     * @param {?} val
                     * @return {?}
                     */
                    set: function (val) {
                        this._hidden = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(val);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether the badge is above the host or not
                 * @return {?}
                 */
                MatBadge.prototype.isAbove = function () {
                    return this.position.indexOf('below') === -1;
                };
                /**
                 * Whether the badge is after the host or not
                 * @return {?}
                 */
                MatBadge.prototype.isAfter = function () {
                    return this.position.indexOf('before') === -1;
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatBadge.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var contentChange = changes['content'];
                    if (contentChange) {
                        /** @type {?} */
                        var value = contentChange.currentValue;
                        this._hasContent = value != null && ("" + value).trim().length > 0;
                        this._updateTextContent();
                    }
                };
                /**
                 * @return {?}
                 */
                MatBadge.prototype.ngOnDestroy = function () {
                    /** @type {?} */
                    var badgeElement = this._badgeElement;
                    if (badgeElement) {
                        if (this.description) {
                            this._ariaDescriber.removeDescription(badgeElement, this.description);
                        }
                        // When creating a badge through the Renderer, Angular will keep it in an index.
                        // We have to destroy it ourselves, otherwise it'll be retained in memory.
                        if (this._renderer.destroyNode) {
                            this._renderer.destroyNode(badgeElement);
                        }
                    }
                };
                /**
                 * Gets the element into which the badge's content is being rendered.
                 * Undefined if the element hasn't been created (e.g. if the badge doesn't have content).
                 * @return {?}
                 */
                MatBadge.prototype.getBadgeElement = function () {
                    return this._badgeElement;
                };
                /**
                 * Injects a span element into the DOM with the content.
                 * @private
                 * @return {?}
                 */
                MatBadge.prototype._updateTextContent = function () {
                    if (!this._badgeElement) {
                        this._badgeElement = this._createBadgeElement();
                    }
                    else {
                        this._badgeElement.textContent = this.content;
                    }
                    return this._badgeElement;
                };
                /**
                 * Creates the badge element
                 * @private
                 * @return {?}
                 */
                MatBadge.prototype._createBadgeElement = function () {
                    /** @type {?} */
                    var badgeElement = this._renderer.createElement('span');
                    /** @type {?} */
                    var activeClass = 'mat-badge-active';
                    /** @type {?} */
                    var contentClass = 'mat-badge-content';
                    // Clear any existing badges which may have persisted from a server-side render.
                    this._clearExistingBadges(contentClass);
                    badgeElement.setAttribute('id', "mat-badge-content-" + this._id);
                    badgeElement.classList.add(contentClass);
                    badgeElement.textContent = this.content;
                    if (this._animationMode === 'NoopAnimations') {
                        badgeElement.classList.add('_mat-animation-noopable');
                    }
                    if (this.description) {
                        badgeElement.setAttribute('aria-label', this.description);
                    }
                    this._elementRef.nativeElement.appendChild(badgeElement);
                    // animate in after insertion
                    if (typeof requestAnimationFrame === 'function' && this._animationMode !== 'NoopAnimations') {
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            requestAnimationFrame(( /**
                             * @return {?}
                             */function () {
                                badgeElement.classList.add(activeClass);
                            }));
                        }));
                    }
                    else {
                        badgeElement.classList.add(activeClass);
                    }
                    return badgeElement;
                };
                /**
                 * Sets the aria-label property on the element
                 * @private
                 * @param {?} newDescription
                 * @param {?} oldDescription
                 * @return {?}
                 */
                MatBadge.prototype._updateHostAriaDescription = function (newDescription, oldDescription) {
                    // ensure content available before setting label
                    /** @type {?} */
                    var content = this._updateTextContent();
                    if (oldDescription) {
                        this._ariaDescriber.removeDescription(content, oldDescription);
                    }
                    if (newDescription) {
                        this._ariaDescriber.describe(content, newDescription);
                    }
                };
                /**
                 * Adds css theme class given the color to the component host
                 * @private
                 * @param {?} colorPalette
                 * @return {?}
                 */
                MatBadge.prototype._setColor = function (colorPalette) {
                    if (colorPalette !== this._color) {
                        if (this._color) {
                            this._elementRef.nativeElement.classList.remove("mat-badge-" + this._color);
                        }
                        if (colorPalette) {
                            this._elementRef.nativeElement.classList.add("mat-badge-" + colorPalette);
                        }
                    }
                };
                /**
                 * Clears any existing badges that might be left over from server-side rendering.
                 * @private
                 * @param {?} cssClass
                 * @return {?}
                 */
                MatBadge.prototype._clearExistingBadges = function (cssClass) {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var childCount = element.children.length;
                    // Use a reverse while, because we'll be removing elements from the list as we're iterating.
                    while (childCount--) {
                        /** @type {?} */
                        var currentChild = element.children[childCount];
                        if (currentChild.classList.contains(cssClass)) {
                            element.removeChild(currentChild);
                        }
                    }
                };
                return MatBadge;
            }(_MatBadgeMixinBase));
            MatBadge.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: '[matBadge]',
                            inputs: ['disabled: matBadgeDisabled'],
                            host: {
                                'class': 'mat-badge',
                                '[class.mat-badge-overlap]': 'overlap',
                                '[class.mat-badge-above]': 'isAbove()',
                                '[class.mat-badge-below]': '!isAbove()',
                                '[class.mat-badge-before]': '!isAfter()',
                                '[class.mat-badge-after]': 'isAfter()',
                                '[class.mat-badge-small]': 'size === "small"',
                                '[class.mat-badge-medium]': 'size === "medium"',
                                '[class.mat-badge-large]': 'size === "large"',
                                '[class.mat-badge-hidden]': 'hidden || !_hasContent',
                                '[class.mat-badge-disabled]': 'disabled',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatBadge.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["AriaDescriber"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Renderer2"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_4__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatBadge.propDecorators = {
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeColor',] }],
                overlap: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeOverlap',] }],
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgePosition',] }],
                content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadge',] }],
                description: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeDescription',] }],
                size: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeSize',] }],
                hidden: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"], args: ['matBadgeHidden',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatBadgeModule = /** @class */ (function () {
                function MatBadgeModule() {
                }
                return MatBadgeModule;
            }());
            MatBadgeModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["A11yModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]
                            ],
                            exports: [MatBadge],
                            declarations: [MatBadge],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=badge.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/bottom-sheet.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/bottom-sheet.js ***!
          \****************************************************************/
        /*! exports provided: MatBottomSheetModule, MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, MatBottomSheet, MAT_BOTTOM_SHEET_DATA, MatBottomSheetConfig, MatBottomSheetContainer, matBottomSheetAnimations, MatBottomSheetRef */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetModule", function () { return MatBottomSheetModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BOTTOM_SHEET_DEFAULT_OPTIONS", function () { return MAT_BOTTOM_SHEET_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheet", function () { return MatBottomSheet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BOTTOM_SHEET_DATA", function () { return MAT_BOTTOM_SHEET_DATA; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetConfig", function () { return MatBottomSheetConfig; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetContainer", function () { return MatBottomSheetContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matBottomSheetAnimations", function () { return matBottomSheetAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetRef", function () { return MatBottomSheetRef; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to access the data that was passed in to a bottom sheet.
             * @type {?}
             */
            var MAT_BOTTOM_SHEET_DATA = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MatBottomSheetData');
            /**
             * Configuration used when opening a bottom sheet.
             * @template D
             */
            var MatBottomSheetConfig = /** @class */ (function () {
                function MatBottomSheetConfig() {
                    /**
                     * Data being injected into the child component.
                     */
                    this.data = null;
                    /**
                     * Whether the bottom sheet has a backdrop.
                     */
                    this.hasBackdrop = true;
                    /**
                     * Whether the user can use escape or clicking outside to close the bottom sheet.
                     */
                    this.disableClose = false;
                    /**
                     * Aria label to assign to the bottom sheet element.
                     */
                    this.ariaLabel = null;
                    /**
                     * Whether the bottom sheet should close when the user goes backwards/forwards in history.
                     * Note that this usually doesn't include clicking on links (unless the user is using
                     * the `HashLocationStrategy`).
                     */
                    this.closeOnNavigation = true;
                    // Note that this is disabled by default, because while the a11y recommendations are to focus
                    // the first focusable element, doing so prevents screen readers from reading out the
                    // rest of the bottom sheet content.
                    /**
                     * Whether the bottom sheet should focus the first focusable element on open.
                     */
                    this.autoFocus = false;
                    /**
                     * Whether the bottom sheet should restore focus to the
                     * previously-focused element, after it's closed.
                     */
                    this.restoreFocus = true;
                }
                return MatBottomSheetConfig;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material bottom sheet.
             * @type {?}
             */
            var matBottomSheetAnimations = {
                /**
                 * Animation that shows and hides a bottom sheet.
                 */
                bottomSheetState: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('state', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('void, hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'translateY(100%)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'translateY(0%)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('visible => void, visible => hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationDurations"].COMPLEX + " " + _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationCurves"].ACCELERATION_CURVE)),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('void => visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationDurations"].EXITING + " " + _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationCurves"].DECELERATION_CURVE)),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO(crisbeto): consolidate some logic between this, MatDialog and MatSnackBar
            /**
             * Internal component that wraps user-provided bottom sheet content.
             * \@docs-private
             */
            var MatBottomSheetContainer = /** @class */ (function (_super) {
                __extends(MatBottomSheetContainer, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _focusTrapFactory
                 * @param {?} breakpointObserver
                 * @param {?} document
                 * @param {?} bottomSheetConfig
                 */
                function MatBottomSheetContainer(_elementRef, _changeDetectorRef, _focusTrapFactory, breakpointObserver, document, bottomSheetConfig) {
                    var _this = _super.call(this) || this;
                    _this._elementRef = _elementRef;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._focusTrapFactory = _focusTrapFactory;
                    _this.bottomSheetConfig = bottomSheetConfig;
                    /**
                     * The state of the bottom sheet animations.
                     */
                    _this._animationState = 'void';
                    /**
                     * Emits whenever the state of the animation changes.
                     */
                    _this._animationStateChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Element that was focused before the bottom sheet was opened.
                     */
                    _this._elementFocusedBeforeOpened = null;
                    _this._document = document;
                    _this._breakpointSubscription = breakpointObserver
                        .observe([_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Medium, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Large, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].XLarge])
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._toggleClass('mat-bottom-sheet-container-medium', breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Medium));
                        _this._toggleClass('mat-bottom-sheet-container-large', breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].Large));
                        _this._toggleClass('mat-bottom-sheet-container-xlarge', breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["Breakpoints"].XLarge));
                    }));
                    return _this;
                }
                /**
                 * Attach a component portal as content to this bottom sheet container.
                 * @template T
                 * @param {?} portal
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.attachComponentPortal = function (portal) {
                    this._validatePortalAttached();
                    this._setPanelClass();
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachComponentPortal(portal);
                };
                /**
                 * Attach a template portal as content to this bottom sheet container.
                 * @template C
                 * @param {?} portal
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.attachTemplatePortal = function (portal) {
                    this._validatePortalAttached();
                    this._setPanelClass();
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachTemplatePortal(portal);
                };
                /**
                 * Begin animation of bottom sheet entrance into view.
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.enter = function () {
                    if (!this._destroyed) {
                        this._animationState = 'visible';
                        this._changeDetectorRef.detectChanges();
                    }
                };
                /**
                 * Begin animation of the bottom sheet exiting from view.
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.exit = function () {
                    if (!this._destroyed) {
                        this._animationState = 'hidden';
                        this._changeDetectorRef.markForCheck();
                    }
                };
                /**
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype.ngOnDestroy = function () {
                    this._breakpointSubscription.unsubscribe();
                    this._destroyed = true;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._onAnimationDone = function (event) {
                    if (event.toState === 'hidden') {
                        this._restoreFocus();
                    }
                    else if (event.toState === 'visible') {
                        this._trapFocus();
                    }
                    this._animationStateChanged.emit(event);
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._onAnimationStart = function (event) {
                    this._animationStateChanged.emit(event);
                };
                /**
                 * @private
                 * @param {?} cssClass
                 * @param {?} add
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._toggleClass = function (cssClass, add) {
                    /** @type {?} */
                    var classList = this._elementRef.nativeElement.classList;
                    add ? classList.add(cssClass) : classList.remove(cssClass);
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._validatePortalAttached = function () {
                    if (this._portalOutlet.hasAttached()) {
                        throw Error('Attempting to attach bottom sheet content after content is already attached');
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._setPanelClass = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var panelClass = this.bottomSheetConfig.panelClass;
                    if (Array.isArray(panelClass)) {
                        // Note that we can't use a spread here, because IE doesn't support multiple arguments.
                        panelClass.forEach(( /**
                         * @param {?} cssClass
                         * @return {?}
                         */function (/**
                         * @param {?} cssClass
                         * @return {?}
                         */ cssClass) { return element.classList.add(cssClass); }));
                    }
                    else if (panelClass) {
                        element.classList.add(panelClass);
                    }
                };
                /**
                 * Moves the focus inside the focus trap.
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._trapFocus = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    if (!this._focusTrap) {
                        this._focusTrap = this._focusTrapFactory.create(element);
                    }
                    if (this.bottomSheetConfig.autoFocus) {
                        this._focusTrap.focusInitialElementWhenReady();
                    }
                    else {
                        /** @type {?} */
                        var activeElement = this._document.activeElement;
                        // Otherwise ensure that focus is on the container. It's possible that a different
                        // component tried to move focus while the open animation was running. See:
                        // https://github.com/angular/components/issues/16215. Note that we only want to do this
                        // if the focus isn't inside the bottom sheet already, because it's possible that the
                        // consumer turned off `autoFocus` in order to move focus themselves.
                        if (activeElement !== element && !element.contains(activeElement)) {
                            element.focus();
                        }
                    }
                };
                /**
                 * Restores focus to the element that was focused before the bottom sheet was opened.
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._restoreFocus = function () {
                    /** @type {?} */
                    var toFocus = this._elementFocusedBeforeOpened;
                    // We need the extra check, because IE can set the `activeElement` to null in some cases.
                    if (this.bottomSheetConfig.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
                        toFocus.focus();
                    }
                    if (this._focusTrap) {
                        this._focusTrap.destroy();
                    }
                };
                /**
                 * Saves a reference to the element that was focused before the bottom sheet was opened.
                 * @private
                 * @return {?}
                 */
                MatBottomSheetContainer.prototype._savePreviouslyFocusedElement = function () {
                    var _this = this;
                    this._elementFocusedBeforeOpened = ( /** @type {?} */(this._document.activeElement));
                    // The `focus` method isn't available during server-side rendering.
                    if (this._elementRef.nativeElement.focus) {
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () { return _this._elementRef.nativeElement.focus(); }));
                    }
                };
                return MatBottomSheetContainer;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["BasePortalOutlet"]));
            MatBottomSheetContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-bottom-sheet-container',
                            template: "<ng-template cdkPortalOutlet></ng-template>",
                            styles: [".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}@media (-ms-high-contrast:active){.mat-bottom-sheet-container{outline:1px solid}}.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium,.mat-bottom-sheet-container-xlarge{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}"],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            animations: [matBottomSheetAnimations.bottomSheetState],
                            host: {
                                'class': 'mat-bottom-sheet-container',
                                'tabindex': '-1',
                                'role': 'dialog',
                                'aria-modal': 'true',
                                '[attr.aria-label]': 'bottomSheetConfig?.ariaLabel',
                                '[@state]': '_animationState',
                                '(@state.start)': '_onAnimationStart($event)',
                                '(@state.done)': '_onAnimationDone($event)'
                            },
                        },] },
            ];
            /** @nocollapse */
            MatBottomSheetContainer.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__["FocusTrapFactory"] },
                { type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_4__["BreakpointObserver"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["DOCUMENT"],] }] },
                { type: MatBottomSheetConfig }
            ]; };
            MatBottomSheetContainer.propDecorators = {
                _portalOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["CdkPortalOutlet"], { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatBottomSheetModule = /** @class */ (function () {
                function MatBottomSheetModule() {
                }
                return MatBottomSheetModule;
            }());
            MatBottomSheetModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["OverlayModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalModule"],
                            ],
                            exports: [MatBottomSheetContainer, _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"]],
                            declarations: [MatBottomSheetContainer],
                            entryComponents: [MatBottomSheetContainer],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Reference to a bottom sheet dispatched from the bottom sheet service.
             * @template T, R
             */
            var MatBottomSheetRef = /** @class */ (function () {
                /**
                 * @param {?} containerInstance
                 * @param {?} _overlayRef
                 * @param {?=} _location
                 */
                function MatBottomSheetRef(containerInstance, _overlayRef, 
                // @breaking-change 8.0.0 `_location` parameter to be removed.
                _location) {
                    var _this = this;
                    this._overlayRef = _overlayRef;
                    /**
                     * Subject for notifying the user that the bottom sheet has been dismissed.
                     */
                    this._afterDismissed = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    /**
                     * Subject for notifying the user that the bottom sheet has opened and appeared.
                     */
                    this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    this.containerInstance = containerInstance;
                    this.disableClose = containerInstance.bottomSheetConfig.disableClose;
                    // Emit when opening animation completes
                    containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'done' && event.toState === 'visible'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._afterOpened.next();
                        _this._afterOpened.complete();
                    }));
                    // Dispose overlay when closing animation is complete
                    containerInstance._animationStateChanged
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) { return event.phaseName === 'done' && event.toState === 'hidden'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        clearTimeout(_this._closeFallbackTimeout);
                        _overlayRef.dispose();
                    }));
                    _overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._afterDismissed.next(_this._result);
                        _this._afterDismissed.complete();
                    }));
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["merge"])(_overlayRef.backdropClick(), _overlayRef.keydownEvents().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["ESCAPE"]; })))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (!_this.disableClose &&
                            (event.type !== 'keydown' || !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["hasModifierKey"])(( /** @type {?} */(event))))) {
                            event.preventDefault();
                            _this.dismiss();
                        }
                    }));
                }
                /**
                 * Dismisses the bottom sheet.
                 * @param {?=} result Data to be passed back to the bottom sheet opener.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.dismiss = function (result) {
                    var _this = this;
                    if (!this._afterDismissed.closed) {
                        // Transition the backdrop in parallel to the bottom sheet.
                        this.containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return event.phaseName === 'start'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            // The logic that disposes of the overlay depends on the exit animation completing, however
                            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
                            // timeout which will clean everything up if the animation hasn't fired within the specified
                            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
                            // vast majority of cases the timeout will have been cleared before it has fired.
                            _this._closeFallbackTimeout = setTimeout(( /**
                             * @return {?}
                             */function () {
                                _this._overlayRef.dispose();
                            }), event.totalTime + 100);
                            _this._overlayRef.detachBackdrop();
                        }));
                        this._result = result;
                        this.containerInstance.exit();
                    }
                };
                /**
                 * Gets an observable that is notified when the bottom sheet is finished closing.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.afterDismissed = function () {
                    return this._afterDismissed.asObservable();
                };
                /**
                 * Gets an observable that is notified when the bottom sheet has opened and appeared.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.afterOpened = function () {
                    return this._afterOpened.asObservable();
                };
                /**
                 * Gets an observable that emits when the overlay's backdrop has been clicked.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.backdropClick = function () {
                    return this._overlayRef.backdropClick();
                };
                /**
                 * Gets an observable that emits when keydown events are targeted on the overlay.
                 * @return {?}
                 */
                MatBottomSheetRef.prototype.keydownEvents = function () {
                    return this._overlayRef.keydownEvents();
                };
                return MatBottomSheetRef;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify default bottom sheet options.
             * @type {?}
             */
            var MAT_BOTTOM_SHEET_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-bottom-sheet-default-options');
            /**
             * Service to trigger Material Design bottom sheets.
             */
            var MatBottomSheet = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _injector
                 * @param {?} _parentBottomSheet
                 * @param {?=} _location
                 * @param {?=} _defaultOptions
                 */
                function MatBottomSheet(_overlay, _injector, _parentBottomSheet, _location, _defaultOptions) {
                    this._overlay = _overlay;
                    this._injector = _injector;
                    this._parentBottomSheet = _parentBottomSheet;
                    this._location = _location;
                    this._defaultOptions = _defaultOptions;
                    this._bottomSheetRefAtThisLevel = null;
                }
                Object.defineProperty(MatBottomSheet.prototype, "_openedBottomSheetRef", {
                    /**
                     * Reference to the currently opened bottom sheet.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var parent = this._parentBottomSheet;
                        return parent ? parent._openedBottomSheetRef : this._bottomSheetRefAtThisLevel;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._parentBottomSheet) {
                            this._parentBottomSheet._openedBottomSheetRef = value;
                        }
                        else {
                            this._bottomSheetRefAtThisLevel = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @template T, D, R
                 * @param {?} componentOrTemplateRef
                 * @param {?=} config
                 * @return {?}
                 */
                MatBottomSheet.prototype.open = function (componentOrTemplateRef, config) {
                    var _this = this;
                    /** @type {?} */
                    var _config = _applyConfigDefaults(this._defaultOptions || new MatBottomSheetConfig(), config);
                    /** @type {?} */
                    var overlayRef = this._createOverlay(_config);
                    /** @type {?} */
                    var container = this._attachContainer(overlayRef, _config);
                    /** @type {?} */
                    var ref = new MatBottomSheetRef(container, overlayRef, this._location);
                    if (componentOrTemplateRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"]) {
                        container.attachTemplatePortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["TemplatePortal"](componentOrTemplateRef, ( /** @type {?} */(null)), ( /** @type {?} */({
                            $implicit: _config.data,
                            bottomSheetRef: ref
                        }))));
                    }
                    else {
                        /** @type {?} */
                        var portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](componentOrTemplateRef, undefined, this._createInjector(_config, ref));
                        /** @type {?} */
                        var contentRef = container.attachComponentPortal(portal);
                        ref.instance = contentRef.instance;
                    }
                    // When the bottom sheet is dismissed, clear the reference to it.
                    ref.afterDismissed().subscribe(( /**
                     * @return {?}
                     */function () {
                        // Clear the bottom sheet ref if it hasn't already been replaced by a newer one.
                        if (_this._openedBottomSheetRef == ref) {
                            _this._openedBottomSheetRef = null;
                        }
                    }));
                    if (this._openedBottomSheetRef) {
                        // If a bottom sheet is already in view, dismiss it and enter the
                        // new bottom sheet after exit animation is complete.
                        this._openedBottomSheetRef.afterDismissed().subscribe(( /**
                         * @return {?}
                         */function () { return ref.containerInstance.enter(); }));
                        this._openedBottomSheetRef.dismiss();
                    }
                    else {
                        // If no bottom sheet is in view, enter the new bottom sheet.
                        ref.containerInstance.enter();
                    }
                    this._openedBottomSheetRef = ref;
                    return ref;
                };
                /**
                 * Dismisses the currently-visible bottom sheet.
                 * @return {?}
                 */
                MatBottomSheet.prototype.dismiss = function () {
                    if (this._openedBottomSheetRef) {
                        this._openedBottomSheetRef.dismiss();
                    }
                };
                /**
                 * @return {?}
                 */
                MatBottomSheet.prototype.ngOnDestroy = function () {
                    if (this._bottomSheetRefAtThisLevel) {
                        this._bottomSheetRefAtThisLevel.dismiss();
                    }
                };
                /**
                 * Attaches the bottom sheet container component to the overlay.
                 * @private
                 * @param {?} overlayRef
                 * @param {?} config
                 * @return {?}
                 */
                MatBottomSheet.prototype._attachContainer = function (overlayRef, config) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injector = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatBottomSheetConfig, config]
                    ]));
                    /** @type {?} */
                    var containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](MatBottomSheetContainer, config.viewContainerRef, injector);
                    /** @type {?} */
                    var containerRef = overlayRef.attach(containerPortal);
                    return containerRef.instance;
                };
                /**
                 * Creates a new overlay and places it in the correct location.
                 * @private
                 * @param {?} config The user-specified bottom sheet config.
                 * @return {?}
                 */
                MatBottomSheet.prototype._createOverlay = function (config) {
                    /** @type {?} */
                    var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["OverlayConfig"]({
                        direction: config.direction,
                        hasBackdrop: config.hasBackdrop,
                        disposeOnNavigation: config.closeOnNavigation,
                        maxWidth: '100%',
                        scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(),
                        positionStrategy: this._overlay.position().global().centerHorizontally().bottom('0')
                    });
                    if (config.backdropClass) {
                        overlayConfig.backdropClass = config.backdropClass;
                    }
                    return this._overlay.create(overlayConfig);
                };
                /**
                 * Creates an injector to be used inside of a bottom sheet component.
                 * @private
                 * @template T
                 * @param {?} config Config that was used to create the bottom sheet.
                 * @param {?} bottomSheetRef Reference to the bottom sheet.
                 * @return {?}
                 */
                MatBottomSheet.prototype._createInjector = function (config, bottomSheetRef) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injectionTokens = new WeakMap([
                        [MatBottomSheetRef, bottomSheetRef],
                        [MAT_BOTTOM_SHEET_DATA, config.data]
                    ]);
                    if (config.direction &&
                        (!userInjector || !userInjector.get(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__["Directionality"], null))) {
                        injectionTokens.set(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_11__["Directionality"], {
                            value: config.direction,
                            change: Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["of"])()
                        });
                    }
                    return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, injectionTokens);
                };
                return MatBottomSheet;
            }());
            MatBottomSheet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: MatBottomSheetModule },] },
            ];
            /** @nocollapse */
            MatBottomSheet.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"] },
                { type: MatBottomSheet, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_5__["Location"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: MatBottomSheetConfig, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_BOTTOM_SHEET_DEFAULT_OPTIONS,] }] }
            ]; };
            /** @nocollapse */ MatBottomSheet.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatBottomSheet_Factory() { return new MatBottomSheet(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_7__["Overlay"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__["INJECTOR"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MatBottomSheet, 12), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_common__WEBPACK_IMPORTED_MODULE_5__["Location"], 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, 8)); }, token: MatBottomSheet, providedIn: MatBottomSheetModule });
            /**
             * Applies default options to the bottom sheet config.
             * @param {?} defaults Object containing the default values to which to fall back.
             * @param {?=} config The configuration to which the defaults will be applied.
             * @return {?} The new configuration object with defaults applied.
             */
            function _applyConfigDefaults(defaults, config) {
                return Object.assign({}, defaults, config);
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=bottom-sheet.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/button-toggle.js": 
        /*!*****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/button-toggle.js ***!
          \*****************************************************************/
        /*! exports provided: MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, MatButtonToggleGroupMultiple, MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle, MatButtonToggleModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS", function () { return MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR", function () { return MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroupMultiple", function () { return MatButtonToggleGroupMultiple; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleChange", function () { return MatButtonToggleChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroup", function () { return MatButtonToggleGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggle", function () { return MatButtonToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleModule", function () { return MatButtonToggleModule; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to configure the
             * default options for all button toggles within an app.
             * @type {?}
             */
            var MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS');
            /**
             * Provider Expression that allows mat-button-toggle-group to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)].
             * \@docs-private
             * @type {?}
             */
            var MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatButtonToggleGroup; })),
                multi: true
            };
            /**
             * @deprecated Use `MatButtonToggleGroup` instead.
             * \@breaking-change 8.0.0
             */
            var MatButtonToggleGroupMultiple = /** @class */ (function () {
                function MatButtonToggleGroupMultiple() {
                }
                return MatButtonToggleGroupMultiple;
            }());
            /** @type {?} */
            var _uniqueIdCounter = 0;
            /**
             * Change event object emitted by MatButtonToggle.
             */
            var MatButtonToggleChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatButtonToggleChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatButtonToggleChange;
            }());
            /**
             * Exclusive selection button toggle group that behaves like a radio-button group.
             */
            var MatButtonToggleGroup = /** @class */ (function () {
                /**
                 * @param {?} _changeDetector
                 * @param {?=} defaultOptions
                 */
                function MatButtonToggleGroup(_changeDetector, defaultOptions) {
                    this._changeDetector = _changeDetector;
                    this._vertical = false;
                    this._multiple = false;
                    this._disabled = false;
                    /**
                     * The method to be called in order to update ngModel.
                     * Now `ngModel` binding is not supported in multiple selection mode.
                     */
                    this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     */
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    this._name = "mat-button-toggle-group-" + _uniqueIdCounter++;
                    /**
                     * Event that emits whenever the value of the group changes.
                     * Used to facilitate two-way data binding.
                     * \@docs-private
                     */
                    this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the group's value changes.
                     */
                    this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    this.appearance =
                        defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
                }
                Object.defineProperty(MatButtonToggleGroup.prototype, "name", {
                    /**
                     * `name` attribute for the underlying `input` element.
                     * @return {?}
                     */
                    get: function () { return this._name; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this = this;
                        this._name = value;
                        if (this._buttonToggles) {
                            this._buttonToggles.forEach(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) {
                                toggle.name = _this._name;
                                toggle._markForCheck();
                            }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "vertical", {
                    /**
                     * Whether the toggle group is vertical.
                     * @return {?}
                     */
                    get: function () { return this._vertical; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._vertical = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "value", {
                    /**
                     * Value of the toggle group.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var selected = this._selectionModel ? this._selectionModel.selected : [];
                        if (this.multiple) {
                            return selected.map(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) { return toggle.value; }));
                        }
                        return selected[0] ? selected[0].value : undefined;
                    },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        this._setSelectionByValue(newValue);
                        this.valueChange.emit(this.value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "selected", {
                    /**
                     * Selected button toggles in the group.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var selected = this._selectionModel ? this._selectionModel.selected : [];
                        return this.multiple ? selected : (selected[0] || null);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "multiple", {
                    /**
                     * Whether multiple button toggles can be selected.
                     * @return {?}
                     */
                    get: function () { return this._multiple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._multiple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggleGroup.prototype, "disabled", {
                    /**
                     * Whether multiple button toggle group is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._buttonToggles) {
                            this._buttonToggles.forEach(( /**
                             * @param {?} toggle
                             * @return {?}
                             */function (/**
                             * @param {?} toggle
                             * @return {?}
                             */ toggle) { return toggle._markForCheck(); }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.ngOnInit = function () {
                    this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__["SelectionModel"](this.multiple, undefined, false);
                };
                /**
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.ngAfterContentInit = function () {
                    var _a;
                    (_a = this._selectionModel).select.apply(_a, __spread(this._buttonToggles.filter(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) { return toggle.checked; }))));
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value Value to be set to the model.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.writeValue = function (value) {
                    this.value = value;
                    this._changeDetector.markForCheck();
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * Dispatch change event with current selection and group value.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._emitChangeEvent = function () {
                    /** @type {?} */
                    var selected = this.selected;
                    /** @type {?} */
                    var source = Array.isArray(selected) ? selected[selected.length - 1] : selected;
                    /** @type {?} */
                    var event = new MatButtonToggleChange(( /** @type {?} */(source)), this.value);
                    this._controlValueAccessorChangeFn(event.value);
                    this.change.emit(event);
                };
                /**
                 * Syncs a button toggle's selected state with the model value.
                 * @param {?} toggle Toggle to be synced.
                 * @param {?} select Whether the toggle should be selected.
                 * @param {?=} isUserInput Whether the change was a result of a user interaction.
                 * @param {?=} deferEvents Whether to defer emitting the change events.
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._syncButtonToggle = function (toggle, select, isUserInput, deferEvents) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    if (deferEvents === void 0) { deferEvents = false; }
                    // Deselect the currently-selected toggle, if we're in single-selection
                    // mode and the button being toggled isn't selected at the moment.
                    if (!this.multiple && this.selected && !toggle.checked) {
                        (( /** @type {?} */(this.selected))).checked = false;
                    }
                    if (this._selectionModel) {
                        if (select) {
                            this._selectionModel.select(toggle);
                        }
                        else {
                            this._selectionModel.deselect(toggle);
                        }
                    }
                    else {
                        deferEvents = true;
                    }
                    // We need to defer in some cases in order to avoid "changed after checked errors", however
                    // the side-effect is that we may end up updating the model value out of sequence in others
                    // The `deferEvents` flag allows us to decide whether to do it on a case-by-case basis.
                    if (deferEvents) {
                    }
                    else {
                        this._updateModelValue(isUserInput);
                    }
                };
                /**
                 * Checks whether a button toggle is selected.
                 * @param {?} toggle
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._isSelected = function (toggle) {
                    return this._selectionModel && this._selectionModel.isSelected(toggle);
                };
                /**
                 * Determines whether a button toggle should be checked on init.
                 * @param {?} toggle
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._isPrechecked = function (toggle) {
                    if (typeof this._rawValue === 'undefined') {
                        return false;
                    }
                    if (this.multiple && Array.isArray(this._rawValue)) {
                        return this._rawValue.some(( /**
                         * @param {?} value
                         * @return {?}
                         */function (/**
                         * @param {?} value
                         * @return {?}
                         */ value) { return toggle.value != null && value === toggle.value; }));
                    }
                    return toggle.value === this._rawValue;
                };
                /**
                 * Updates the selection state of the toggles in the group based on a value.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._setSelectionByValue = function (value) {
                    var _this = this;
                    this._rawValue = value;
                    if (!this._buttonToggles) {
                        return;
                    }
                    if (this.multiple && value) {
                        if (!Array.isArray(value)) {
                            throw Error('Value must be an array in multiple-selection mode.');
                        }
                        this._clearSelection();
                        value.forEach(( /**
                         * @param {?} currentValue
                         * @return {?}
                         */function (currentValue) { return _this._selectValue(currentValue); }));
                    }
                    else {
                        this._clearSelection();
                        this._selectValue(value);
                    }
                };
                /**
                 * Clears the selected toggles.
                 * @private
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._clearSelection = function () {
                    this._selectionModel.clear();
                    this._buttonToggles.forEach(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) { return toggle.checked = false; }));
                };
                /**
                 * Selects a value if there's a toggle that corresponds to it.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._selectValue = function (value) {
                    /** @type {?} */
                    var correspondingOption = this._buttonToggles.find(( /**
                     * @param {?} toggle
                     * @return {?}
                     */function (/**
                     * @param {?} toggle
                     * @return {?}
                     */ toggle) {
                        return toggle.value != null && toggle.value === value;
                    }));
                    if (correspondingOption) {
                        correspondingOption.checked = true;
                        this._selectionModel.select(correspondingOption);
                    }
                };
                /**
                 * Syncs up the group's value with the model and emits the change event.
                 * @private
                 * @param {?} isUserInput
                 * @return {?}
                 */
                MatButtonToggleGroup.prototype._updateModelValue = function (isUserInput) {
                    // Only emit the change event for user input.
                    if (isUserInput) {
                        this._emitChangeEvent();
                    }
                    // Note: we emit this one no matter whether it was a user interaction, because
                    // it is used by Angular to sync up the two-way data binding.
                    this.valueChange.emit(this.value);
                };
                return MatButtonToggleGroup;
            }());
            MatButtonToggleGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-button-toggle-group',
                            providers: [
                                MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR,
                                { provide: MatButtonToggleGroupMultiple, useExisting: MatButtonToggleGroup },
                            ],
                            host: {
                                'role': 'group',
                                'class': 'mat-button-toggle-group',
                                '[attr.aria-disabled]': 'disabled',
                                '[class.mat-button-toggle-vertical]': 'vertical',
                                '[class.mat-button-toggle-group-appearance-standard]': 'appearance === "standard"',
                            },
                            exportAs: 'matButtonToggleGroup',
                        },] },
            ];
            /** @nocollapse */
            MatButtonToggleGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatButtonToggleGroup.propDecorators = {
                _buttonToggles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatButtonToggle; })),] }],
                appearance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            // Boilerplate for applying mixins to the MatButtonToggle class.
            /**
             * \@docs-private
             */
            var MatButtonToggleBase = /** @class */ (function () {
                function MatButtonToggleBase() {
                }
                return MatButtonToggleBase;
            }());
            /** @type {?} */
            var _MatButtonToggleMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(MatButtonToggleBase);
            /**
             * Single button inside of a toggle group.
             */
            var MatButtonToggle = /** @class */ (function (_super) {
                __extends(MatButtonToggle, _super);
                /**
                 * @param {?} toggleGroup
                 * @param {?} _changeDetectorRef
                 * @param {?} _elementRef
                 * @param {?} _focusMonitor
                 * @param {?} defaultTabIndex
                 * @param {?=} defaultOptions
                 */
                function MatButtonToggle(toggleGroup, _changeDetectorRef, _elementRef, _focusMonitor, 
                // @breaking-change 8.0.0 `defaultTabIndex` to be made a required parameter.
                defaultTabIndex, defaultOptions) {
                    var _this = _super.call(this) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._elementRef = _elementRef;
                    _this._focusMonitor = _focusMonitor;
                    _this._isSingleSelector = false;
                    _this._checked = false;
                    /**
                     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
                     */
                    _this.ariaLabelledby = null;
                    _this._disabled = false;
                    /**
                     * Event emitted when the group value changes.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /** @type {?} */
                    var parsedTabIndex = Number(defaultTabIndex);
                    _this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
                    _this.buttonToggleGroup = toggleGroup;
                    _this.appearance =
                        defaultOptions && defaultOptions.appearance ? defaultOptions.appearance : 'standard';
                    return _this;
                }
                Object.defineProperty(MatButtonToggle.prototype, "buttonId", {
                    /**
                     * Unique ID for the underlying `button` element.
                     * @return {?}
                     */
                    get: function () { return this.id + "-button"; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "appearance", {
                    /**
                     * The appearance style of the button.
                     * @return {?}
                     */
                    get: function () {
                        return this.buttonToggleGroup ? this.buttonToggleGroup.appearance : this._appearance;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._appearance = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "checked", {
                    /**
                     * Whether the button is checked.
                     * @return {?}
                     */
                    get: function () {
                        return this.buttonToggleGroup ? this.buttonToggleGroup._isSelected(this) : this._checked;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (newValue !== this._checked) {
                            this._checked = newValue;
                            if (this.buttonToggleGroup) {
                                this.buttonToggleGroup._syncButtonToggle(this, this._checked);
                            }
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatButtonToggle.prototype, "disabled", {
                    /**
                     * Whether the button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled || (this.buttonToggleGroup && this.buttonToggleGroup.disabled);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatButtonToggle.prototype.ngOnInit = function () {
                    this._isSingleSelector = this.buttonToggleGroup && !this.buttonToggleGroup.multiple;
                    this._type = this._isSingleSelector ? 'radio' : 'checkbox';
                    this.id = this.id || "mat-button-toggle-" + _uniqueIdCounter++;
                    if (this._isSingleSelector) {
                        this.name = this.buttonToggleGroup.name;
                    }
                    if (this.buttonToggleGroup && this.buttonToggleGroup._isPrechecked(this)) {
                        this.checked = true;
                    }
                    this._focusMonitor.monitor(this._elementRef, true);
                };
                /**
                 * @return {?}
                 */
                MatButtonToggle.prototype.ngOnDestroy = function () {
                    /** @type {?} */
                    var group = this.buttonToggleGroup;
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    // Remove the toggle from the selection once it's destroyed. Needs to happen
                    // on the next tick in order to avoid "changed after checked" errors.
                    if (group && group._isSelected(this)) {
                        group._syncButtonToggle(this, false, false, true);
                    }
                };
                /**
                 * Focuses the button.
                 * @param {?=} options
                 * @return {?}
                 */
                MatButtonToggle.prototype.focus = function (options) {
                    this._buttonElement.nativeElement.focus(options);
                };
                /**
                 * Checks the button toggle due to an interaction with the underlying native button.
                 * @return {?}
                 */
                MatButtonToggle.prototype._onButtonClick = function () {
                    /** @type {?} */
                    var newChecked = this._isSingleSelector ? true : !this._checked;
                    if (newChecked !== this._checked) {
                        this._checked = newChecked;
                        if (this.buttonToggleGroup) {
                            this.buttonToggleGroup._syncButtonToggle(this, this._checked, true);
                            this.buttonToggleGroup._onTouched();
                        }
                    }
                    // Emit a change event when it's the single selector
                    this.change.emit(new MatButtonToggleChange(this, this.value));
                };
                /**
                 * Marks the button toggle as needing checking for change detection.
                 * This method is exposed because the parent button toggle group will directly
                 * update bound properties of the radio button.
                 * @return {?}
                 */
                MatButtonToggle.prototype._markForCheck = function () {
                    // When the group value changes, the button will not be notified.
                    // Use `markForCheck` to explicit update button toggle's status.
                    this._changeDetectorRef.markForCheck();
                };
                return MatButtonToggle;
            }(_MatButtonToggleMixinBase));
            MatButtonToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-button-toggle',
                            template: "<button #button class=\"mat-button-toggle-button\" type=\"button\" [id]=\"buttonId\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [attr.aria-pressed]=\"checked\" [disabled]=\"disabled || null\" [attr.name]=\"name || null\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (click)=\"_onButtonClick()\"><div class=\"mat-button-toggle-label-content\"><ng-content></ng-content></div></button><div class=\"mat-button-toggle-focus-overlay\"></div><div class=\"mat-button-toggle-ripple\" matRipple [matRippleTrigger]=\"button\" [matRippleDisabled]=\"this.disableRipple || this.disabled\"></div>",
                            styles: [".mat-button-toggle-group,.mat-button-toggle-standalone{position:relative;display:inline-flex;flex-direction:row;white-space:nowrap;overflow:hidden;border-radius:2px;-webkit-tap-highlight-color:transparent}@media (-ms-high-contrast:active){.mat-button-toggle-group,.mat-button-toggle-standalone{outline:solid 1px}}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border-radius:4px}@media (-ms-high-contrast:active){.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{outline:0}}.mat-button-toggle-vertical{flex-direction:column}.mat-button-toggle-vertical .mat-button-toggle-label-content{display:block}.mat-button-toggle{white-space:nowrap;position:relative}.mat-button-toggle .mat-icon svg{vertical-align:top}.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:1}@media (-ms-high-contrast:active){.mat-button-toggle.cdk-keyboard-focused .mat-button-toggle-focus-overlay{opacity:.5}}.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{opacity:.04}.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.12}@media (-ms-high-contrast:active){.mat-button-toggle-appearance-standard.cdk-keyboard-focused:not(.mat-button-toggle-disabled) .mat-button-toggle-focus-overlay{opacity:.5}}@media (hover:none){.mat-button-toggle-appearance-standard:not(.mat-button-toggle-disabled):hover .mat-button-toggle-focus-overlay{display:none}}.mat-button-toggle-label-content{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;line-height:36px;padding:0 16px;position:relative}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px;padding:0 12px}.mat-button-toggle-label-content>*{vertical-align:middle}.mat-button-toggle-focus-overlay{border-radius:inherit;pointer-events:none;opacity:0;top:0;left:0;right:0;bottom:0;position:absolute}.mat-button-toggle-checked .mat-button-toggle-focus-overlay{border-bottom:solid 36px}@media (-ms-high-contrast:active){.mat-button-toggle-checked .mat-button-toggle-focus-overlay{opacity:.5;height:0}}@media (-ms-high-contrast:active){.mat-button-toggle-checked.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{border-bottom:solid 48px}}.mat-button-toggle .mat-button-toggle-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-button-toggle-button{border:0;background:0 0;color:inherit;padding:0;margin:0;font:inherit;outline:0;width:100%;cursor:pointer}.mat-button-toggle-disabled .mat-button-toggle-button{cursor:default}.mat-button-toggle-button::-moz-focus-inner{border:0}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matButtonToggle',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disableRipple'],
                            host: {
                                '[class.mat-button-toggle-standalone]': '!buttonToggleGroup',
                                '[class.mat-button-toggle-checked]': 'checked',
                                '[class.mat-button-toggle-disabled]': 'disabled',
                                '[class.mat-button-toggle-appearance-standard]': 'appearance === "standard"',
                                'class': 'mat-button-toggle',
                                // Always reset the tabindex to -1 so it doesn't conflict with the one on the `button`,
                                // but can still receive focus from things like cdkFocusInitial.
                                '[attr.tabindex]': '-1',
                                '[attr.id]': 'id',
                                '[attr.name]': 'null',
                                '(focus)': 'focus()',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatButtonToggle.ctorParameters = function () { return [
                { type: MatButtonToggleGroup, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Attribute"], args: ['tabindex',] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS,] }] }
            ]; };
            MatButtonToggle.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-labelledby',] }],
                _buttonElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: ['button', { static: false },] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                appearance: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatButtonToggleModule = /** @class */ (function () {
                function MatButtonToggleModule() {
                }
                return MatButtonToggleModule;
            }());
            MatButtonToggleModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"]],
                            exports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"], MatButtonToggleGroup, MatButtonToggle],
                            declarations: [MatButtonToggleGroup, MatButtonToggle],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=button-toggle.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/card.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/card.js ***!
          \********************************************************/
        /*! exports provided: MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardImage, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardXlImage, MatCardAvatar, MatCard, MatCardHeader, MatCardTitleGroup, MatCardModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardContent", function () { return MatCardContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardTitle", function () { return MatCardTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardSubtitle", function () { return MatCardSubtitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardActions", function () { return MatCardActions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardFooter", function () { return MatCardFooter; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardImage", function () { return MatCardImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardSmImage", function () { return MatCardSmImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardMdImage", function () { return MatCardMdImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardLgImage", function () { return MatCardLgImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardXlImage", function () { return MatCardXlImage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardAvatar", function () { return MatCardAvatar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCard", function () { return MatCard; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardHeader", function () { return MatCardHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardTitleGroup", function () { return MatCardTitleGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCardModule", function () { return MatCardModule; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Content of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardContent = /** @class */ (function () {
                function MatCardContent() {
                }
                return MatCardContent;
            }());
            MatCardContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-content',
                            host: { 'class': 'mat-card-content' }
                        },] },
            ];
            /**
             * Title of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardTitle = /** @class */ (function () {
                function MatCardTitle() {
                }
                return MatCardTitle;
            }());
            MatCardTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-card-title, [mat-card-title], [matCardTitle]",
                            host: {
                                'class': 'mat-card-title'
                            }
                        },] },
            ];
            /**
             * Sub-title of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardSubtitle = /** @class */ (function () {
                function MatCardSubtitle() {
                }
                return MatCardSubtitle;
            }());
            MatCardSubtitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-card-subtitle, [mat-card-subtitle], [matCardSubtitle]",
                            host: {
                                'class': 'mat-card-subtitle'
                            }
                        },] },
            ];
            /**
             * Action section of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardActions = /** @class */ (function () {
                function MatCardActions() {
                    /**
                     * Position of the actions inside the card.
                     */
                    this.align = 'start';
                }
                return MatCardActions;
            }());
            MatCardActions.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-actions',
                            exportAs: 'matCardActions',
                            host: {
                                'class': 'mat-card-actions',
                                '[class.mat-card-actions-align-end]': 'align === "end"',
                            }
                        },] },
            ];
            MatCardActions.propDecorators = {
                align: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Footer of a card, needed as it's used as a selector in the API.
             * \@docs-private
             */
            var MatCardFooter = /** @class */ (function () {
                function MatCardFooter() {
                }
                return MatCardFooter;
            }());
            MatCardFooter.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-card-footer',
                            host: { 'class': 'mat-card-footer' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardImage = /** @class */ (function () {
                function MatCardImage() {
                }
                return MatCardImage;
            }());
            MatCardImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-image], [matCardImage]',
                            host: { 'class': 'mat-card-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardSmImage = /** @class */ (function () {
                function MatCardSmImage() {
                }
                return MatCardSmImage;
            }());
            MatCardSmImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-sm-image], [matCardImageSmall]',
                            host: { 'class': 'mat-card-sm-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardMdImage = /** @class */ (function () {
                function MatCardMdImage() {
                }
                return MatCardMdImage;
            }());
            MatCardMdImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-md-image], [matCardImageMedium]',
                            host: { 'class': 'mat-card-md-image' }
                        },] },
            ];
            /**
             * Image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardLgImage = /** @class */ (function () {
                function MatCardLgImage() {
                }
                return MatCardLgImage;
            }());
            MatCardLgImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-lg-image], [matCardImageLarge]',
                            host: { 'class': 'mat-card-lg-image' }
                        },] },
            ];
            /**
             * Large image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardXlImage = /** @class */ (function () {
                function MatCardXlImage() {
                }
                return MatCardXlImage;
            }());
            MatCardXlImage.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-xl-image], [matCardImageXLarge]',
                            host: { 'class': 'mat-card-xl-image' }
                        },] },
            ];
            /**
             * Avatar image used in a card, needed to add the mat- CSS styling.
             * \@docs-private
             */
            var MatCardAvatar = /** @class */ (function () {
                function MatCardAvatar() {
                }
                return MatCardAvatar;
            }());
            MatCardAvatar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-card-avatar], [matCardAvatar]',
                            host: { 'class': 'mat-card-avatar' }
                        },] },
            ];
            /**
             * A basic content container component that adds the styles of a Material design card.
             *
             * While this component can be used alone, it also provides a number
             * of preset styles for common card sections, including:
             * - mat-card-title
             * - mat-card-subtitle
             * - mat-card-content
             * - mat-card-actions
             * - mat-card-footer
             */
            var MatCard = /** @class */ (function () {
                // @breaking-change 9.0.0 `_animationMode` parameter to be made required.
                /**
                 * @param {?=} _animationMode
                 */
                function MatCard(_animationMode) {
                    this._animationMode = _animationMode;
                }
                return MatCard;
            }());
            MatCard.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card',
                            exportAs: 'matCard',
                            template: "<ng-content></ng-content><ng-content select=\"mat-card-footer\"></ng-content>",
                            styles: [".mat-card{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}@media (-ms-high-contrast:active){.mat-card{outline:solid 1px}}.mat-card-actions,.mat-card-content,.mat-card-subtitle{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media (max-width:599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card-content>:first-child,.mat-card>:first-child{margin-top:0}.mat-card-content>:last-child:not(.mat-card-footer),.mat-card>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions .mat-button:first-child,.mat-card-actions .mat-raised-button:first-child,.mat-card-actions .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-subtitle:not(:first-child),.mat-card-title:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'class': 'mat-card',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatCard.ctorParameters = function () { return [
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_1__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            /**
             * Component intended to be used within the `<mat-card>` component. It adds styles for a
             * preset header section (i.e. a title, subtitle, and avatar layout).
             * \@docs-private
             */
            var MatCardHeader = /** @class */ (function () {
                function MatCardHeader() {
                }
                return MatCardHeader;
            }());
            MatCardHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card-header',
                            template: "<ng-content select=\"[mat-card-avatar], [matCardAvatar]\"></ng-content><div class=\"mat-card-header-text\"><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content></ng-content>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: { 'class': 'mat-card-header' }
                        },] },
            ];
            /**
             * Component intended to be used within the `<mat-card>` component. It adds styles for a preset
             * layout that groups an image with a title section.
             * \@docs-private
             */
            var MatCardTitleGroup = /** @class */ (function () {
                function MatCardTitleGroup() {
                }
                return MatCardTitleGroup;
            }());
            MatCardTitleGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-card-title-group',
                            template: "<div><ng-content select=\"mat-card-title, mat-card-subtitle, [mat-card-title], [mat-card-subtitle], [matCardTitle], [matCardSubtitle]\"></ng-content></div><ng-content select=\"img\"></ng-content><ng-content></ng-content>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            host: { 'class': 'mat-card-title-group' }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatCardModule = /** @class */ (function () {
                function MatCardModule() {
                }
                return MatCardModule;
            }());
            MatCardModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"]],
                            exports: [
                                MatCard,
                                MatCardHeader,
                                MatCardTitleGroup,
                                MatCardContent,
                                MatCardTitle,
                                MatCardSubtitle,
                                MatCardActions,
                                MatCardFooter,
                                MatCardSmImage,
                                MatCardMdImage,
                                MatCardLgImage,
                                MatCardImage,
                                MatCardXlImage,
                                MatCardAvatar,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"],
                            ],
                            declarations: [
                                MatCard, MatCardHeader, MatCardTitleGroup, MatCardContent, MatCardTitle, MatCardSubtitle,
                                MatCardActions, MatCardFooter, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardImage,
                                MatCardXlImage, MatCardAvatar,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=card.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/checkbox.js": 
        /*!************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/checkbox.js ***!
          \************************************************************/
        /*! exports provided: MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, TransitionCheckState, MatCheckboxChange, MatCheckbox, MAT_CHECKBOX_CLICK_ACTION, _MatCheckboxRequiredValidatorModule, MatCheckboxModule, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckboxRequiredValidator */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR", function () { return MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransitionCheckState", function () { return TransitionCheckState; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxChange", function () { return MatCheckboxChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckbox", function () { return MatCheckbox; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CLICK_ACTION", function () { return MAT_CHECKBOX_CLICK_ACTION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatCheckboxRequiredValidatorModule", function () { return _MatCheckboxRequiredValidatorModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxModule", function () { return MatCheckboxModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_REQUIRED_VALIDATOR", function () { return MAT_CHECKBOX_REQUIRED_VALIDATOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxRequiredValidator", function () { return MatCheckboxRequiredValidator; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify the checkbox click behavior.
             * @type {?}
             */
            var MAT_CHECKBOX_CLICK_ACTION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-checkbox-click-action');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids for checkbox components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)].
             * \@docs-private
             * @type {?}
             */
            var MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatCheckbox; })),
                multi: true
            };
            /** @enum {number} */
            var TransitionCheckState = {
                /** The initial state of the component before any user interaction. */
                Init: 0,
                /** The state representing the component when it's becoming checked. */
                Checked: 1,
                /** The state representing the component when it's becoming unchecked. */
                Unchecked: 2,
                /** The state representing the component when it's becoming indeterminate. */
                Indeterminate: 3,
            };
            TransitionCheckState[TransitionCheckState.Init] = 'Init';
            TransitionCheckState[TransitionCheckState.Checked] = 'Checked';
            TransitionCheckState[TransitionCheckState.Unchecked] = 'Unchecked';
            TransitionCheckState[TransitionCheckState.Indeterminate] = 'Indeterminate';
            /**
             * Change event object emitted by MatCheckbox.
             */
            var MatCheckboxChange = /** @class */ (function () {
                function MatCheckboxChange() {
                }
                return MatCheckboxChange;
            }());
            // Boilerplate for applying mixins to MatCheckbox.
            /**
             * \@docs-private
             */
            var MatCheckboxBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatCheckboxBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatCheckboxBase;
            }());
            /** @type {?} */
            var _MatCheckboxMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisabled"])(MatCheckboxBase)), 'accent'));
            /**
             * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,
             * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or
             * disabled. Note that all additional accessibility attributes are taken care of by the component,
             * so there is no need to provide them yourself. However, if you want to omit a label and still
             * have the checkbox be accessible, you may supply an [aria-label] input.
             * See: https://material.io/design/components/selection-controls.html
             */
            var MatCheckbox = /** @class */ (function (_super) {
                __extends(MatCheckbox, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _focusMonitor
                 * @param {?} _ngZone
                 * @param {?} tabIndex
                 * @param {?} _clickAction
                 * @param {?=} _animationMode
                 */
                function MatCheckbox(elementRef, _changeDetectorRef, _focusMonitor, _ngZone, tabIndex, _clickAction, _animationMode) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._focusMonitor = _focusMonitor;
                    _this._ngZone = _ngZone;
                    _this._clickAction = _clickAction;
                    _this._animationMode = _animationMode;
                    /**
                     * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will
                     * take precedence so this may be omitted.
                     */
                    _this.ariaLabel = '';
                    /**
                     * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element
                     */
                    _this.ariaLabelledby = null;
                    _this._uniqueId = "mat-checkbox-" + ++nextUniqueId;
                    /**
                     * A unique id for the checkbox input. If none is supplied, it will be auto-generated.
                     */
                    _this.id = _this._uniqueId;
                    /**
                     * Whether the label should appear after or before the checkbox. Defaults to 'after'
                     */
                    _this.labelPosition = 'after';
                    /**
                     * Name value will be applied to the input element if present
                     */
                    _this.name = null;
                    /**
                     * Event emitted when the checkbox's `checked` value changes.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Event emitted when the checkbox's `indeterminate` value changes.
                     */
                    _this.indeterminateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.
                     * \@docs-private
                     */
                    _this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this._currentAnimationClass = '';
                    _this._currentCheckState = TransitionCheckState.Init;
                    _this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    _this._checked = false;
                    _this._disabled = false;
                    _this._indeterminate = false;
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    _this._focusMonitor.monitor(elementRef, true).subscribe(( /**
                     * @param {?} focusOrigin
                     * @return {?}
                     */function (/**
                     * @param {?} focusOrigin
                     * @return {?}
                     */ focusOrigin) {
                        if (!focusOrigin) {
                            // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                            // Angular does not expect events to be raised during change detection, so any state change
                            // (such as a form control's 'ng-touched') will cause a changed-after-checked error.
                            // See https://github.com/angular/angular/issues/17793. To work around this, we defer
                            // telling the form control it has been touched until the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this._onTouched();
                                _changeDetectorRef.markForCheck();
                            }));
                        }
                    }));
                    return _this;
                }
                Object.defineProperty(MatCheckbox.prototype, "inputId", {
                    /**
                     * Returns the unique id for the visual hidden input.
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "required", {
                    /**
                     * Whether the checkbox is required.
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                // TODO: Delete next major revision.
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype.ngAfterViewChecked = function () { };
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                Object.defineProperty(MatCheckbox.prototype, "checked", {
                    /**
                     * Whether the checkbox is checked.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value != this.checked) {
                            this._checked = value;
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "disabled", {
                    /**
                     * Whether the checkbox is disabled. This fully overrides the implementation provided by
                     * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                        if (newValue !== this.disabled) {
                            this._disabled = newValue;
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCheckbox.prototype, "indeterminate", {
                    /**
                     * Whether the checkbox is indeterminate. This is also known as "mixed" mode and can be used to
                     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of
                     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately
                     * set to false.
                     * @return {?}
                     */
                    get: function () { return this._indeterminate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var changed = value != this._indeterminate;
                        this._indeterminate = value;
                        if (changed) {
                            if (this._indeterminate) {
                                this._transitionCheckState(TransitionCheckState.Indeterminate);
                            }
                            else {
                                this._transitionCheckState(this.checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                            }
                            this.indeterminateChange.emit(this._indeterminate);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype._isRippleDisabled = function () {
                    return this.disableRipple || this.disabled;
                };
                /**
                 * Method being called whenever the label text changes.
                 * @return {?}
                 */
                MatCheckbox.prototype._onLabelTextChange = function () {
                    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox
                    // component will be only marked for check, but no actual change detection runs automatically.
                    // Instead of going back into the zone in order to trigger a change detection which causes
                    // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger
                    // an explicit change detection for the checkbox view and its children.
                    this._changeDetectorRef.detectChanges();
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatCheckbox.prototype.writeValue = function (value) {
                    this.checked = !!value;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatCheckbox.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatCheckbox.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatCheckbox.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * @return {?}
                 */
                MatCheckbox.prototype._getAriaChecked = function () {
                    return this.checked ? 'true' : (this.indeterminate ? 'mixed' : 'false');
                };
                /**
                 * @private
                 * @param {?} newState
                 * @return {?}
                 */
                MatCheckbox.prototype._transitionCheckState = function (newState) {
                    /** @type {?} */
                    var oldState = this._currentCheckState;
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    if (oldState === newState) {
                        return;
                    }
                    if (this._currentAnimationClass.length > 0) {
                        element.classList.remove(this._currentAnimationClass);
                    }
                    this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);
                    this._currentCheckState = newState;
                    if (this._currentAnimationClass.length > 0) {
                        element.classList.add(this._currentAnimationClass);
                        // Remove the animation class to avoid animation when the checkbox is moved between containers
                        /** @type {?} */
                        var animationClass_1 = this._currentAnimationClass;
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () {
                            setTimeout(( /**
                             * @return {?}
                             */function () {
                                element.classList.remove(animationClass_1);
                            }), 1000);
                        }));
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatCheckbox.prototype._emitChangeEvent = function () {
                    /** @type {?} */
                    var event = new MatCheckboxChange();
                    event.source = this;
                    event.checked = this.checked;
                    this._controlValueAccessorChangeFn(this.checked);
                    this.change.emit(event);
                };
                /**
                 * Toggles the `checked` state of the checkbox.
                 * @return {?}
                 */
                MatCheckbox.prototype.toggle = function () {
                    this.checked = !this.checked;
                };
                /**
                 * Event handler for checkbox input element.
                 * Toggles checked state if element is not disabled.
                 * Do not toggle on (change) event since IE doesn't fire change event when
                 *   indeterminate checkbox is clicked.
                 * @param {?} event
                 * @return {?}
                 */
                MatCheckbox.prototype._onInputClick = function (event) {
                    var _this = this;
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `checkbox` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                    // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click
                    if (!this.disabled && this._clickAction !== 'noop') {
                        // When user manually click on the checkbox, `indeterminate` is set to false.
                        if (this.indeterminate && this._clickAction !== 'check') {
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this._indeterminate = false;
                                _this.indeterminateChange.emit(_this._indeterminate);
                            }));
                        }
                        this.toggle();
                        this._transitionCheckState(this._checked ? TransitionCheckState.Checked : TransitionCheckState.Unchecked);
                        // Emit our custom change event if the native input emitted one.
                        // It is important to only emit it, if the native input triggered one, because
                        // we don't want to trigger a change event, when the `checked` variable changes for example.
                        this._emitChangeEvent();
                    }
                    else if (!this.disabled && this._clickAction === 'noop') {
                        // Reset native input when clicked with noop. The native checkbox becomes checked after
                        // click, reset it to be align with `checked` value of `mat-checkbox`.
                        this._inputElement.nativeElement.checked = this.checked;
                        this._inputElement.nativeElement.indeterminate = this.indeterminate;
                    }
                };
                /**
                 * Focuses the checkbox.
                 * @param {?=} origin
                 * @param {?=} options
                 * @return {?}
                 */
                MatCheckbox.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'keyboard'; }
                    this._focusMonitor.focusVia(this._inputElement, origin, options);
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatCheckbox.prototype._onInteractionEvent = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the `change` output.
                    event.stopPropagation();
                };
                /**
                 * @private
                 * @param {?} oldState
                 * @param {?} newState
                 * @return {?}
                 */
                MatCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {
                    // Don't transition if animations are disabled.
                    if (this._animationMode === 'NoopAnimations') {
                        return '';
                    }
                    /** @type {?} */
                    var animSuffix = '';
                    switch (oldState) {
                        case TransitionCheckState.Init:
                            // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or
                            // [checked] bound to it.
                            if (newState === TransitionCheckState.Checked) {
                                animSuffix = 'unchecked-checked';
                            }
                            else if (newState == TransitionCheckState.Indeterminate) {
                                animSuffix = 'unchecked-indeterminate';
                            }
                            else {
                                return '';
                            }
                            break;
                        case TransitionCheckState.Unchecked:
                            animSuffix = newState === TransitionCheckState.Checked ?
                                'unchecked-checked' : 'unchecked-indeterminate';
                            break;
                        case TransitionCheckState.Checked:
                            animSuffix = newState === TransitionCheckState.Unchecked ?
                                'checked-unchecked' : 'checked-indeterminate';
                            break;
                        case TransitionCheckState.Indeterminate:
                            animSuffix = newState === TransitionCheckState.Checked ?
                                'indeterminate-checked' : 'indeterminate-unchecked';
                            break;
                    }
                    return "mat-checkbox-anim-" + animSuffix;
                };
                return MatCheckbox;
            }(_MatCheckboxMixinBase));
            MatCheckbox.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-checkbox',
                            template: "<label [attr.for]=\"inputId\" class=\"mat-checkbox-layout\" #label><div class=\"mat-checkbox-inner-container\" [class.mat-checkbox-inner-container-no-side-margin]=\"!checkboxLabel.textContent || !checkboxLabel.textContent.trim()\"><input #input class=\"mat-checkbox-input cdk-visually-hidden\" type=\"checkbox\" [id]=\"inputId\" [required]=\"required\" [checked]=\"checked\" [attr.value]=\"value\" [disabled]=\"disabled\" [attr.name]=\"name\" [tabIndex]=\"tabIndex\" [indeterminate]=\"indeterminate\" [attr.aria-label]=\"ariaLabel || null\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-checked]=\"_getAriaChecked()\" (change)=\"_onInteractionEvent($event)\" (click)=\"_onInputClick($event)\"><div matRipple class=\"mat-checkbox-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleRadius]=\"20\" [matRippleCentered]=\"true\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-checkbox-persistent-ripple\"></div></div><div class=\"mat-checkbox-frame\"></div><div class=\"mat-checkbox-background\"><svg version=\"1.1\" focusable=\"false\" class=\"mat-checkbox-checkmark\" viewBox=\"0 0 24 24\" xml:space=\"preserve\"><path class=\"mat-checkbox-checkmark-path\" fill=\"none\" stroke=\"white\" d=\"M4.1,12.7 9,17.6 20.3,6.3\"/></svg><div class=\"mat-checkbox-mixedmark\"></div></div></div><span class=\"mat-checkbox-label\" #checkboxLabel (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                            styles: ["@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.91026}50%{animation-timing-function:cubic-bezier(0,0,.2,.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0,0,0,1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(.4,0,1,1);stroke-dashoffset:0}to{stroke-dashoffset:-22.91026}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0,0,.2,.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(.14,0,0,1);opacity:1;transform:rotate(0)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}100%,32.8%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{transition:background .4s cubic-bezier(.25,.8,.25,1),box-shadow 280ms cubic-bezier(.4,0,.2,1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0,0,.2,.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}@media (-ms-high-contrast:active){.mat-checkbox.cdk-keyboard-focused .mat-checkbox-frame{border-style:dotted}}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0,0,.2,.1),opacity 90ms cubic-bezier(0,0,.2,.1)}._mat-animation-noopable .mat-checkbox-background{transition:none}.mat-checkbox-persistent-ripple{width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media (hover:none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.91026;stroke-dasharray:22.91026;stroke-width:2.13333px}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0);border-radius:2px}@media (-ms-high-contrast:active){.mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0s mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0s mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0s mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:.5s linear 0s mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0s mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:.3s linear 0s mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}"],
                            exportAs: 'matCheckbox',
                            host: {
                                'class': 'mat-checkbox',
                                '[id]': 'id',
                                '[attr.tabindex]': 'null',
                                '[class.mat-checkbox-indeterminate]': 'indeterminate',
                                '[class.mat-checkbox-checked]': 'checked',
                                '[class.mat-checkbox-disabled]': 'disabled',
                                '[class.mat-checkbox-label-before]': 'labelPosition == "before"',
                                '[class._mat-animation-noopable]': "_animationMode === 'NoopAnimations'",
                            },
                            providers: [MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR],
                            inputs: ['disableRipple', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatCheckbox.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_CHECKBOX_CLICK_ACTION,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_5__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatCheckbox.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                indeterminateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['input', { static: false },] }],
                ripple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRipple"], { static: false },] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                indeterminate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_CHECKBOX_REQUIRED_VALIDATOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatCheckboxRequiredValidator; })),
                multi: true
            };
            /**
             * Validator for Material checkbox's required attribute in template-driven checkbox.
             * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not
             * work with `mat-checkbox`.
             */
            var MatCheckboxRequiredValidator = /** @class */ (function (_super) {
                __extends(MatCheckboxRequiredValidator, _super);
                function MatCheckboxRequiredValidator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatCheckboxRequiredValidator;
            }(_angular_forms__WEBPACK_IMPORTED_MODULE_3__["CheckboxRequiredValidator"]));
            MatCheckboxRequiredValidator.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-checkbox[required][formControlName],\n             mat-checkbox[required][formControl], mat-checkbox[required][ngModel]",
                            providers: [MAT_CHECKBOX_REQUIRED_VALIDATOR],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This module is used by both original and MDC-based checkbox implementations.
             */
            // tslint:disable-next-line:class-name
            var _MatCheckboxRequiredValidatorModule = /** @class */ (function () {
                function _MatCheckboxRequiredValidatorModule() {
                }
                return _MatCheckboxRequiredValidatorModule;
            }());
            _MatCheckboxRequiredValidatorModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: [MatCheckboxRequiredValidator],
                            declarations: [MatCheckboxRequiredValidator],
                        },] },
            ];
            var MatCheckboxModule = /** @class */ (function () {
                function MatCheckboxModule() {
                }
                return MatCheckboxModule;
            }());
            MatCheckboxModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_6__["ObserversModule"],
                                _MatCheckboxRequiredValidatorModule
                            ],
                            exports: [MatCheckbox, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MatCommonModule"], _MatCheckboxRequiredValidatorModule],
                            declarations: [MatCheckbox],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=checkbox.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/chips.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/chips.js ***!
          \*********************************************************/
        /*! exports provided: MatChipsModule, MatChipListChange, MatChipList, MatChipSelectionChange, MatChipAvatar, MatChipTrailingIcon, MatChip, MatChipRemove, MatChipInput, MAT_CHIPS_DEFAULT_OPTIONS */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipsModule", function () { return MatChipsModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipListChange", function () { return MatChipListChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipList", function () { return MatChipList; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipSelectionChange", function () { return MatChipSelectionChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipAvatar", function () { return MatChipAvatar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipTrailingIcon", function () { return MatChipTrailingIcon; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChip", function () { return MatChip; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipRemove", function () { return MatChipRemove; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatChipInput", function () { return MatChipInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_CHIPS_DEFAULT_OPTIONS", function () { return MAT_CHIPS_DEFAULT_OPTIONS; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Event object emitted by MatChip when selected or deselected.
             */
            var MatChipSelectionChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} selected
                 * @param {?=} isUserInput
                 */
                function MatChipSelectionChange(source, selected, isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this.source = source;
                    this.selected = selected;
                    this.isUserInput = isUserInput;
                }
                return MatChipSelectionChange;
            }());
            // Boilerplate for applying mixins to MatChip.
            /**
             * \@docs-private
             */
            var MatChipBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatChipBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatChipBase;
            }());
            /** @type {?} */
            var _MatChipMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinDisabled"])(MatChipBase)), 'primary');
            /**
             * Dummy directive to add CSS class to chip avatar.
             * \@docs-private
             */
            var MatChipAvatar = /** @class */ (function () {
                function MatChipAvatar() {
                }
                return MatChipAvatar;
            }());
            MatChipAvatar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-chip-avatar, [matChipAvatar]',
                            host: { 'class': 'mat-chip-avatar' }
                        },] },
            ];
            /**
             * Dummy directive to add CSS class to chip trailing icon.
             * \@docs-private
             */
            var MatChipTrailingIcon = /** @class */ (function () {
                function MatChipTrailingIcon() {
                }
                return MatChipTrailingIcon;
            }());
            MatChipTrailingIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',
                            host: { 'class': 'mat-chip-trailing-icon' }
                        },] },
            ];
            /**
             * Material design styled Chip component. Used inside the MatChipList component.
             */
            var MatChip = /** @class */ (function (_super) {
                __extends(MatChip, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?} platform
                 * @param {?} globalRippleOptions
                 * @param {?=} animationMode
                 * @param {?=} _changeDetectorRef
                 */
                function MatChip(_elementRef, _ngZone, platform, globalRippleOptions, 
                // @breaking-change 8.0.0 `animationMode` parameter to become required.
                animationMode, _changeDetectorRef) {
                    var _this = _super.call(this, _elementRef) || this;
                    _this._elementRef = _elementRef;
                    _this._ngZone = _ngZone;
                    _this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Whether the chip has focus.
                     */
                    _this._hasFocus = false;
                    /**
                     * Whether the chip list is selectable
                     */
                    _this.chipListSelectable = true;
                    /**
                     * Whether the chip list is in multi-selection mode.
                     */
                    _this._chipListMultiple = false;
                    _this._selected = false;
                    _this._selectable = true;
                    _this._removable = true;
                    /**
                     * Emits when the chip is focused.
                     */
                    _this._onFocus = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Emits when the chip is blured.
                     */
                    _this._onBlur = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Emitted when the chip is selected or deselected.
                     */
                    _this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Emitted when the chip is destroyed.
                     */
                    _this.destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Emitted when a chip is to be removed.
                     */
                    _this.removed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    _this._addHostClassName();
                    _this._chipRipple = new _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["RippleRenderer"](_this, _ngZone, _elementRef, platform);
                    _this._chipRipple.setupTriggerEvents(_elementRef);
                    _this.rippleConfig = globalRippleOptions || {};
                    _this._animationsDisabled = animationMode === 'NoopAnimations';
                    return _this;
                }
                Object.defineProperty(MatChip.prototype, "rippleDisabled", {
                    /**
                     * Whether ripples are disabled on interaction
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "selected", {
                    /**
                     * Whether the chip is selected.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var coercedValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        if (coercedValue !== this._selected) {
                            this._selected = coercedValue;
                            this._dispatchSelectionChange();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "value", {
                    /**
                     * The value of the chip. Defaults to the content inside `<mat-chip>` tags.
                     * @return {?}
                     */
                    get: function () {
                        return this._value !== undefined
                            ? this._value
                            : this._elementRef.nativeElement.textContent;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._value = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "selectable", {
                    /**
                     * Whether or not the chip is selectable. When a chip is not selectable,
                     * changes to its selected state are always ignored. By default a chip is
                     * selectable, and it becomes non-selectable if its parent chip list is
                     * not selectable.
                     * @return {?}
                     */
                    get: function () { return this._selectable && this.chipListSelectable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selectable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "removable", {
                    /**
                     * Determines whether or not the chip displays the remove styling and emits (removed) events.
                     * @return {?}
                     */
                    get: function () { return this._removable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._removable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChip.prototype, "ariaSelected", {
                    /**
                     * The ARIA selected applied to the chip.
                     * @return {?}
                     */
                    get: function () {
                        // Remove the `aria-selected` when the chip is deselected in single-selection mode, because
                        // it adds noise to NVDA users where "not selected" will be read out for each chip.
                        return this.selectable && (this._chipListMultiple || this.selected) ?
                            this.selected.toString() : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChip.prototype._addHostClassName = function () {
                    /** @type {?} */
                    var basicChipAttrName = 'mat-basic-chip';
                    /** @type {?} */
                    var element = ( /** @type {?} */(this._elementRef.nativeElement));
                    if (element.hasAttribute(basicChipAttrName) ||
                        element.tagName.toLowerCase() === basicChipAttrName) {
                        element.classList.add(basicChipAttrName);
                        return;
                    }
                    else {
                        element.classList.add('mat-standard-chip');
                    }
                };
                /**
                 * @return {?}
                 */
                MatChip.prototype.ngOnDestroy = function () {
                    this.destroyed.emit({ chip: this });
                    this._chipRipple._removeTriggerEvents();
                };
                /**
                 * Selects the chip.
                 * @return {?}
                 */
                MatChip.prototype.select = function () {
                    if (!this._selected) {
                        this._selected = true;
                        this._dispatchSelectionChange();
                        this._markForCheck();
                    }
                };
                /**
                 * Deselects the chip.
                 * @return {?}
                 */
                MatChip.prototype.deselect = function () {
                    if (this._selected) {
                        this._selected = false;
                        this._dispatchSelectionChange();
                        this._markForCheck();
                    }
                };
                /**
                 * Select this chip and emit selected event
                 * @return {?}
                 */
                MatChip.prototype.selectViaInteraction = function () {
                    if (!this._selected) {
                        this._selected = true;
                        this._dispatchSelectionChange(true);
                        this._markForCheck();
                    }
                };
                /**
                 * Toggles the current selected state of this chip.
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChip.prototype.toggleSelected = function (isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this._selected = !this.selected;
                    this._dispatchSelectionChange(isUserInput);
                    this._markForCheck();
                    return this.selected;
                };
                /**
                 * Allows for programmatic focusing of the chip.
                 * @return {?}
                 */
                MatChip.prototype.focus = function () {
                    if (!this._hasFocus) {
                        this._elementRef.nativeElement.focus();
                        this._onFocus.next({ chip: this });
                    }
                    this._hasFocus = true;
                };
                /**
                 * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or
                 * BACKSPACE keys are pressed.
                 *
                 * Informs any listeners of the removal request. Does not remove the chip from the DOM.
                 * @return {?}
                 */
                MatChip.prototype.remove = function () {
                    if (this.removable) {
                        this.removed.emit({ chip: this });
                    }
                };
                /**
                 * Handles click events on the chip.
                 * @param {?} event
                 * @return {?}
                 */
                MatChip.prototype._handleClick = function (event) {
                    if (this.disabled) {
                        event.preventDefault();
                    }
                    else {
                        event.stopPropagation();
                    }
                };
                /**
                 * Handle custom key presses.
                 * @param {?} event
                 * @return {?}
                 */
                MatChip.prototype._handleKeydown = function (event) {
                    if (this.disabled) {
                        return;
                    }
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["DELETE"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["BACKSPACE"]:
                            // If we are removable, remove the focused chip
                            this.remove();
                            // Always prevent so page navigation does not occur
                            event.preventDefault();
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["SPACE"]:
                            // If we are selectable, toggle the focused chip
                            if (this.selectable) {
                                this.toggleSelected(true);
                            }
                            // Always prevent space from scrolling the page since the list has focus
                            event.preventDefault();
                            break;
                    }
                };
                /**
                 * @return {?}
                 */
                MatChip.prototype._blur = function () {
                    var _this = this;
                    // When animations are enabled, Angular may end up removing the chip from the DOM a little
                    // earlier than usual, causing it to be blurred and throwing off the logic in the chip list
                    // that moves focus not the next item. To work around the issue, we defer marking the chip
                    // as not focused until the next time the zone stabilizes.
                    this._ngZone.onStable
                        .asObservable()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            _this._hasFocus = false;
                            _this._onBlur.next({ chip: _this });
                        }));
                    }));
                };
                /**
                 * @private
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChip.prototype._dispatchSelectionChange = function (isUserInput) {
                    if (isUserInput === void 0) { isUserInput = false; }
                    this.selectionChange.emit({
                        source: this,
                        isUserInput: isUserInput,
                        selected: this._selected
                    });
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChip.prototype._markForCheck = function () {
                    // @breaking-change 9.0.0 Remove this method once the _changeDetectorRef is a required param.
                    if (this._changeDetectorRef) {
                        this._changeDetectorRef.markForCheck();
                    }
                };
                return MatChip;
            }(_MatChipMixinBase));
            MatChip.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: "mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]",
                            inputs: ['color', 'disabled', 'disableRipple'],
                            exportAs: 'matChip',
                            host: {
                                'class': 'mat-chip',
                                '[attr.tabindex]': 'disabled ? null : -1',
                                'role': 'option',
                                '[class.mat-chip-selected]': 'selected',
                                '[class.mat-chip-with-avatar]': 'avatar',
                                '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',
                                '[class.mat-chip-disabled]': 'disabled',
                                '[class._mat-animation-noopable]': '_animationsDisabled',
                                '[attr.disabled]': 'disabled || null',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.aria-selected]': 'ariaSelected',
                                '(click)': '_handleClick($event)',
                                '(keydown)': '_handleKeydown($event)',
                                '(focus)': 'focus()',
                                '(blur)': '_blur()',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatChip.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_2__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_RIPPLE_GLOBAL_OPTIONS"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            MatChip.propDecorators = {
                avatar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatChipAvatar, { static: false },] }],
                trailingIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatChipTrailingIcon, { static: false },] }],
                removeIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatChipRemove; })), { static: false },] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                removable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                destroyed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                removed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * Applies proper (click) support and adds styling for use with the Material Design "cancel" icon
             * available at https://material.io/icons/#ic_cancel.
             *
             * Example:
             *
             *     `<mat-chip>
             *       <mat-icon matChipRemove>cancel</mat-icon>
             *     </mat-chip>`
             *
             * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning
             * styles to properly center the icon within the chip.
             */
            var MatChipRemove = /** @class */ (function () {
                /**
                 * @param {?} _parentChip
                 */
                function MatChipRemove(_parentChip) {
                    this._parentChip = _parentChip;
                }
                /**
                 * Calls the parent chip's public `remove()` method if applicable.
                 * @param {?} event
                 * @return {?}
                 */
                MatChipRemove.prototype._handleClick = function (event) {
                    /** @type {?} */
                    var parentChip = this._parentChip;
                    if (parentChip.removable && !parentChip.disabled) {
                        parentChip.remove();
                    }
                    // We need to stop event propagation because otherwise the event will bubble up to the
                    // form field and cause the `onContainerClick` method to be invoked. This method would then
                    // reset the focused chip that has been focused after chip removal. Usually the parent
                    // the parent click listener of the `MatChip` would prevent propagation, but it can happen
                    // that the chip is being removed before the event bubbles up.
                    event.stopPropagation();
                };
                return MatChipRemove;
            }());
            MatChipRemove.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: '[matChipRemove]',
                            host: {
                                'class': 'mat-chip-remove mat-chip-trailing-icon',
                                '(click)': '_handleClick($event)',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatChipRemove.ctorParameters = function () { return [
                { type: MatChip }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for the chips module.
             * @type {?}
             */
            var MAT_CHIPS_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-chips-default-options');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatChipList.
            /**
             * \@docs-private
             */
            var MatChipListBase = /** @class */ (function () {
                /**
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} ngControl
                 */
                function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
                    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
                    this._parentForm = _parentForm;
                    this._parentFormGroup = _parentFormGroup;
                    this.ngControl = ngControl;
                }
                return MatChipListBase;
            }());
            /** @type {?} */
            var _MatChipListMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinErrorState"])(MatChipListBase);
            // Increasing integer for generating unique ids for chip-list components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Change event object that is emitted when the chip list value has changed.
             */
            var MatChipListChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatChipListChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatChipListChange;
            }());
            /**
             * A material design chips component (named ChipList for its similarity to the List component).
             */
            var MatChipList = /** @class */ (function (_super) {
                __extends(MatChipList, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} _dir
                 * @param {?} _parentForm
                 * @param {?} _parentFormGroup
                 * @param {?} _defaultErrorStateMatcher
                 * @param {?} ngControl
                 */
                function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, ngControl) {
                    var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;
                    _this._elementRef = _elementRef;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._dir = _dir;
                    _this.ngControl = ngControl;
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     */
                    _this.controlType = 'mat-chip-list';
                    /**
                     * When a chip is destroyed, we store the index of the destroyed chip until the chips
                     * query list notifies about the update. This is necessary because we cannot determine an
                     * appropriate chip that should receive focus until the array of chips updated completely.
                     */
                    _this._lastDestroyedChipIndex = null;
                    /**
                     * Subject that emits when the component has been destroyed.
                     */
                    _this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Uid of the chip list
                     */
                    _this._uid = "mat-chip-list-" + nextUniqueId++;
                    /**
                     * Tab index for the chip list.
                     */
                    _this._tabIndex = 0;
                    /**
                     * User defined tab index.
                     * When it is not null, use user defined tab index. Otherwise use _tabIndex
                     */
                    _this._userTabIndex = null;
                    /**
                     * Function when touched
                     */
                    _this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Function when changed
                     */
                    _this._onChange = ( /**
                     * @return {?}
                     */function () { });
                    _this._multiple = false;
                    _this._compareWith = ( /**
                     * @param {?} o1
                     * @param {?} o2
                     * @return {?}
                     */function (o1, o2) { return o1 === o2; });
                    _this._required = false;
                    _this._disabled = false;
                    /**
                     * Orientation of the chip list.
                     */
                    _this.ariaOrientation = 'horizontal';
                    _this._selectable = true;
                    /**
                     * Event emitted when the selected chip list value has been changed by the user.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event that emits whenever the raw value of the chip-list changes. This is here primarily
                     * to facilitate the two-way binding for the `value` input.
                     * \@docs-private
                     */
                    _this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    if (_this.ngControl) {
                        _this.ngControl.valueAccessor = _this;
                    }
                    return _this;
                }
                Object.defineProperty(MatChipList.prototype, "selected", {
                    /**
                     * The array of selected chips inside chip list.
                     * @return {?}
                     */
                    get: function () {
                        return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "role", {
                    /**
                     * The ARIA role applied to the chip list.
                     * @return {?}
                     */
                    get: function () { return this.empty ? null : 'listbox'; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "multiple", {
                    /**
                     * Whether the user should be allowed to select multiple chips.
                     * @return {?}
                     */
                    get: function () { return this._multiple; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._multiple = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this._syncChipsState();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "compareWith", {
                    /**
                     * A function to compare the option values with the selected values. The first argument
                     * is a value from an option. The second is a value from the selection. A boolean
                     * should be returned.
                     * @return {?}
                     */
                    get: function () { return this._compareWith; },
                    /**
                     * @param {?} fn
                     * @return {?}
                     */
                    set: function (fn) {
                        this._compareWith = fn;
                        if (this._selectionModel) {
                            // A different comparator means the selection could change.
                            this._initializeSelection();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "value", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this.writeValue(value);
                        this._value = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "id", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._chipInput ? this._chipInput.id : this._uid;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "required", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "placeholder", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this._chipInput ? this._chipInput.placeholder : this._placeholder;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._placeholder = value;
                        this.stateChanges.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "focused", {
                    /**
                     * Whether any chips or the matChipInput inside of this chip-list has focus.
                     * @return {?}
                     */
                    get: function () {
                        return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "empty", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "shouldLabelFloat", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return !this.empty || this.focused; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "disabled", {
                    /**
                     * Implemented as part of MatFormFieldControl.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        this._syncChipsState();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "selectable", {
                    /**
                     * Whether or not this chip list is selectable. When a chip list is not selectable,
                     * the selected states for all the chips inside the chip list are always ignored.
                     * @return {?}
                     */
                    get: function () { return this._selectable; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this = this;
                        this._selectable = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value);
                        if (this.chips) {
                            this.chips.forEach(( /**
                             * @param {?} chip
                             * @return {?}
                             */function (/**
                             * @param {?} chip
                             * @return {?}
                             */ chip) { return chip.chipListSelectable = _this._selectable; }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "tabIndex", {
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._userTabIndex = value;
                        this._tabIndex = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipSelectionChanges", {
                    /**
                     * Combined stream of all of the child chips' selection change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, __spread(this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.selectionChange; }))));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipFocusChanges", {
                    /**
                     * Combined stream of all of the child chips' focus change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, __spread(this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip._onFocus; }))));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipBlurChanges", {
                    /**
                     * Combined stream of all of the child chips' blur change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, __spread(this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip._onBlur; }))));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipList.prototype, "chipRemoveChanges", {
                    /**
                     * Combined stream of all of the child chips' remove change events.
                     * @return {?}
                     */
                    get: function () {
                        return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"]).apply(void 0, __spread(this.chips.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.destroyed; }))));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_8__["FocusKeyManager"](this.chips)
                        .withWrap()
                        .withVerticalOrientation()
                        .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');
                    if (this._dir) {
                        this._dir.change
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed))
                            .subscribe(( /**
                     * @param {?} dir
                     * @return {?}
                     */function (/**
                     * @param {?} dir
                     * @return {?}
                     */ dir) { return _this._keyManager.withHorizontalOrientation(dir); }));
                    }
                    this._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._allowFocusEscape();
                    }));
                    // When the list changes, re-subscribe
                    this.chips.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["startWith"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () {
                        if (_this.disabled) {
                            // Since this happens after the content has been
                            // checked, we need to defer it to the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () {
                                _this._syncChipsState();
                            }));
                        }
                        _this._resetChips();
                        // Reset chips selected/deselected status
                        _this._initializeSelection();
                        // Check to see if we need to update our tab index
                        _this._updateTabIndex();
                        // Check to see if we have a destroyed chip and need to refocus
                        _this._updateFocusForDestroyedChips();
                        _this.stateChanges.next();
                    }));
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngOnInit = function () {
                    this._selectionModel = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_10__["SelectionModel"](this.multiple, undefined, false);
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngDoCheck = function () {
                    if (this.ngControl) {
                        // We need to re-evaluate this on every change detection cycle, because there are some
                        // error triggers that we can't subscribe to (e.g. parent form submissions). This means
                        // that whatever logic is in here has to be super lean or we risk destroying the performance.
                        this.updateErrorState();
                    }
                };
                /**
                 * @return {?}
                 */
                MatChipList.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                    this.stateChanges.complete();
                    this._dropSubscriptions();
                };
                /**
                 * Associates an HTML input element with this chip list.
                 * @param {?} inputElement
                 * @return {?}
                 */
                MatChipList.prototype.registerInput = function (inputElement) {
                    this._chipInput = inputElement;
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} ids
                 * @return {?}
                 */
                MatChipList.prototype.setDescribedByIds = function (ids) { this._ariaDescribedby = ids.join(' '); };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatChipList.prototype.writeValue = function (value) {
                    if (this.chips) {
                        this._setSelectionByValue(value, false);
                    }
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatChipList.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatChipList.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatChipList.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this.stateChanges.next();
                };
                /**
                 * Implemented as part of MatFormFieldControl.
                 * \@docs-private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype.onContainerClick = function (event) {
                    if (!this._originatesFromChip(event)) {
                        this.focus();
                    }
                };
                /**
                 * Focuses the first non-disabled chip in this chip list, or the associated input when there
                 * are no eligible chips.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipList.prototype.focus = function (options) {
                    if (this.disabled) {
                        return;
                    }
                    // TODO: ARIA says this should focus the first `selected` chip if any are selected.
                    // Focus on first element if there's no chipInput inside chip-list
                    if (this._chipInput && this._chipInput.focused) {
                        // do nothing
                    }
                    else if (this.chips.length > 0) {
                        this._keyManager.setFirstItemActive();
                        this.stateChanges.next();
                    }
                    else {
                        this._focusInput(options);
                        this.stateChanges.next();
                    }
                };
                /**
                 * Attempt to focus an input if we have one.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipList.prototype._focusInput = function (options) {
                    if (this._chipInput) {
                        this._chipInput.focus(options);
                    }
                };
                /**
                 * Pass events to the keyboard manager. Available here for tests.
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype._keydown = function (event) {
                    /** @type {?} */
                    var target = ( /** @type {?} */(event.target));
                    // If they are on an empty input and hit backspace, focus the last chip
                    if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["BACKSPACE"] && this._isInputEmpty(target)) {
                        this._keyManager.setLastItemActive();
                        event.preventDefault();
                    }
                    else if (target && target.classList.contains('mat-chip')) {
                        if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["HOME"]) {
                            this._keyManager.setFirstItemActive();
                            event.preventDefault();
                        }
                        else if (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["END"]) {
                            this._keyManager.setLastItemActive();
                            event.preventDefault();
                        }
                        else {
                            this._keyManager.onKeydown(event);
                        }
                        this.stateChanges.next();
                    }
                };
                /**
                 * Check the tab index as you should not be allowed to focus an empty list.
                 * @protected
                 * @return {?}
                 */
                MatChipList.prototype._updateTabIndex = function () {
                    // If we have 0 chips, we should not allow keyboard focus
                    this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);
                };
                /**
                 * If the amount of chips changed, we need to update the
                 * key manager state and focus the next closest chip.
                 * @protected
                 * @return {?}
                 */
                MatChipList.prototype._updateFocusForDestroyedChips = function () {
                    // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.
                    if (this._lastDestroyedChipIndex != null) {
                        if (this.chips.length) {
                            /** @type {?} */
                            var newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);
                            this._keyManager.setActiveItem(newChipIndex);
                        }
                        else {
                            this.focus();
                        }
                    }
                    this._lastDestroyedChipIndex = null;
                };
                /**
                 * Utility to ensure all indexes are valid.
                 *
                 * @private
                 * @param {?} index The index to be checked.
                 * @return {?} True if the index is valid for our list of chips.
                 */
                MatChipList.prototype._isValidIndex = function (index) {
                    return index >= 0 && index < this.chips.length;
                };
                /**
                 * @private
                 * @param {?} element
                 * @return {?}
                 */
                MatChipList.prototype._isInputEmpty = function (element) {
                    if (element && element.nodeName.toLowerCase() === 'input') {
                        /** @type {?} */
                        var input = ( /** @type {?} */(element));
                        return !input.value;
                    }
                    return false;
                };
                /**
                 * @param {?} value
                 * @param {?=} isUserInput
                 * @return {?}
                 */
                MatChipList.prototype._setSelectionByValue = function (value, isUserInput) {
                    var _this = this;
                    if (isUserInput === void 0) { isUserInput = true; }
                    this._clearSelection();
                    this.chips.forEach(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) { return chip.deselect(); }));
                    if (Array.isArray(value)) {
                        value.forEach(( /**
                         * @param {?} currentValue
                         * @return {?}
                         */function (/**
                         * @param {?} currentValue
                         * @return {?}
                         */ currentValue) { return _this._selectValue(currentValue, isUserInput); }));
                        this._sortValues();
                    }
                    else {
                        /** @type {?} */
                        var correspondingChip = this._selectValue(value, isUserInput);
                        // Shift focus to the active item. Note that we shouldn't do this in multiple
                        // mode, because we don't know what chip the user interacted with last.
                        if (correspondingChip) {
                            if (isUserInput) {
                                this._keyManager.setActiveItem(correspondingChip);
                            }
                        }
                    }
                };
                /**
                 * Finds and selects the chip based on its value.
                 * @private
                 * @param {?} value
                 * @param {?=} isUserInput
                 * @return {?} Chip that has the corresponding value.
                 */
                MatChipList.prototype._selectValue = function (value, isUserInput) {
                    var _this = this;
                    if (isUserInput === void 0) { isUserInput = true; }
                    /** @type {?} */
                    var correspondingChip = this.chips.find(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) {
                        return chip.value != null && _this._compareWith(chip.value, value);
                    }));
                    if (correspondingChip) {
                        isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
                        this._selectionModel.select(correspondingChip);
                    }
                    return correspondingChip;
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._initializeSelection = function () {
                    var _this = this;
                    // Defer setting the value in order to avoid the "Expression
                    // has changed after it was checked" errors from Angular.
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        if (_this.ngControl || _this._value) {
                            _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);
                            _this.stateChanges.next();
                        }
                    }));
                };
                /**
                 * Deselects every chip in the list.
                 * @private
                 * @param {?=} skip Chip that should not be deselected.
                 * @return {?}
                 */
                MatChipList.prototype._clearSelection = function (skip) {
                    this._selectionModel.clear();
                    this.chips.forEach(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) {
                        if (chip !== skip) {
                            chip.deselect();
                        }
                    }));
                    this.stateChanges.next();
                };
                /**
                 * Sorts the model values, ensuring that they keep the same
                 * order that they have in the panel.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._sortValues = function () {
                    var _this = this;
                    if (this._multiple) {
                        this._selectionModel.clear();
                        this.chips.forEach(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) {
                            if (chip.selected) {
                                _this._selectionModel.select(chip);
                            }
                        }));
                        this.stateChanges.next();
                    }
                };
                /**
                 * Emits change event to set the model value.
                 * @private
                 * @param {?=} fallbackValue
                 * @return {?}
                 */
                MatChipList.prototype._propagateChanges = function (fallbackValue) {
                    /** @type {?} */
                    var valueToEmit = null;
                    if (Array.isArray(this.selected)) {
                        valueToEmit = this.selected.map(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) { return chip.value; }));
                    }
                    else {
                        valueToEmit = this.selected ? this.selected.value : fallbackValue;
                    }
                    this._value = valueToEmit;
                    this.change.emit(new MatChipListChange(this, valueToEmit));
                    this.valueChange.emit(valueToEmit);
                    this._onChange(valueToEmit);
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * When blurred, mark the field as touched when focus moved outside the chip list.
                 * @return {?}
                 */
                MatChipList.prototype._blur = function () {
                    var _this = this;
                    if (!this._hasFocusedChip()) {
                        this._keyManager.setActiveItem(-1);
                    }
                    if (!this.disabled) {
                        if (this._chipInput) {
                            // If there's a chip input, we should check whether the focus moved to chip input.
                            // If the focus is not moved to chip input, mark the field as touched. If the focus moved
                            // to chip input, do nothing.
                            // Timeout is needed to wait for the focus() event trigger on chip input.
                            setTimeout(( /**
                             * @return {?}
                             */function () {
                                if (!_this.focused) {
                                    _this._markAsTouched();
                                }
                            }));
                        }
                        else {
                            // If there's no chip input, then mark the field as touched.
                            this._markAsTouched();
                        }
                    }
                };
                /**
                 * Mark the field as touched
                 * @return {?}
                 */
                MatChipList.prototype._markAsTouched = function () {
                    this._onTouched();
                    this._changeDetectorRef.markForCheck();
                    this.stateChanges.next();
                };
                /**
                 * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the
                 * user to tab out of it. This prevents the list from capturing focus and redirecting
                 * it back to the first chip, creating a focus trap, if it user tries to tab away.
                 * @return {?}
                 */
                MatChipList.prototype._allowFocusEscape = function () {
                    var _this = this;
                    if (this._tabIndex !== -1) {
                        this._tabIndex = -1;
                        setTimeout(( /**
                         * @return {?}
                         */function () {
                            _this._tabIndex = _this._userTabIndex || 0;
                            _this._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._resetChips = function () {
                    this._dropSubscriptions();
                    this._listenToChipsFocus();
                    this._listenToChipsSelection();
                    this._listenToChipsRemoved();
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._dropSubscriptions = function () {
                    if (this._chipFocusSubscription) {
                        this._chipFocusSubscription.unsubscribe();
                        this._chipFocusSubscription = null;
                    }
                    if (this._chipBlurSubscription) {
                        this._chipBlurSubscription.unsubscribe();
                        this._chipBlurSubscription = null;
                    }
                    if (this._chipSelectionSubscription) {
                        this._chipSelectionSubscription.unsubscribe();
                        this._chipSelectionSubscription = null;
                    }
                    if (this._chipRemoveSubscription) {
                        this._chipRemoveSubscription.unsubscribe();
                        this._chipRemoveSubscription = null;
                    }
                };
                /**
                 * Listens to user-generated selection events on each chip.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsSelection = function () {
                    var _this = this;
                    this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        event.source.selected
                            ? _this._selectionModel.select(event.source)
                            : _this._selectionModel.deselect(event.source);
                        // For single selection chip list, make sure the deselected value is unselected.
                        if (!_this.multiple) {
                            _this.chips.forEach(( /**
                             * @param {?} chip
                             * @return {?}
                             */function (/**
                             * @param {?} chip
                             * @return {?}
                             */ chip) {
                                if (!_this._selectionModel.isSelected(chip) && chip.selected) {
                                    chip.deselect();
                                }
                            }));
                        }
                        if (event.isUserInput) {
                            _this._propagateChanges();
                        }
                    }));
                };
                /**
                 * Listens to user-generated selection events on each chip.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsFocus = function () {
                    var _this = this;
                    this._chipFocusSubscription = this.chipFocusChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        /** @type {?} */
                        var chipIndex = _this.chips.toArray().indexOf(event.chip);
                        if (_this._isValidIndex(chipIndex)) {
                            _this._keyManager.updateActiveItemIndex(chipIndex);
                        }
                        _this.stateChanges.next();
                    }));
                    this._chipBlurSubscription = this.chipBlurChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._blur();
                        _this.stateChanges.next();
                    }));
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._listenToChipsRemoved = function () {
                    var _this = this;
                    this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        /** @type {?} */
                        var chip = event.chip;
                        /** @type {?} */
                        var chipIndex = _this.chips.toArray().indexOf(event.chip);
                        // In case the chip that will be removed is currently focused, we temporarily store
                        // the index in order to be able to determine an appropriate sibling chip that will
                        // receive focus.
                        if (_this._isValidIndex(chipIndex) && chip._hasFocus) {
                            _this._lastDestroyedChipIndex = chipIndex;
                        }
                    }));
                };
                /**
                 * Checks whether an event comes from inside a chip element.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipList.prototype._originatesFromChip = function (event) {
                    /** @type {?} */
                    var currentElement = ( /** @type {?} */(event.target));
                    while (currentElement && currentElement !== this._elementRef.nativeElement) {
                        if (currentElement.classList.contains('mat-chip')) {
                            return true;
                        }
                        currentElement = currentElement.parentElement;
                    }
                    return false;
                };
                /**
                 * Checks whether any of the chips is focused.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._hasFocusedChip = function () {
                    return this.chips.some(( /**
                     * @param {?} chip
                     * @return {?}
                     */function (/**
                     * @param {?} chip
                     * @return {?}
                     */ chip) { return chip._hasFocus; }));
                };
                /**
                 * Syncs the list's state with the individual chips.
                 * @private
                 * @return {?}
                 */
                MatChipList.prototype._syncChipsState = function () {
                    var _this = this;
                    if (this.chips) {
                        this.chips.forEach(( /**
                         * @param {?} chip
                         * @return {?}
                         */function (/**
                         * @param {?} chip
                         * @return {?}
                         */ chip) {
                            chip.disabled = _this._disabled;
                            chip._chipListMultiple = _this.multiple;
                        }));
                    }
                };
                return MatChipList;
            }(_MatChipListMixinBase));
            MatChipList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-chip-list',
                            template: "<div class=\"mat-chip-list-wrapper\"><ng-content></ng-content></div>",
                            exportAs: 'matChipList',
                            host: {
                                '[attr.tabindex]': 'disabled ? null : _tabIndex',
                                '[attr.aria-describedby]': '_ariaDescribedby || null',
                                '[attr.aria-required]': 'required.toString()',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.aria-invalid]': 'errorState',
                                '[attr.aria-multiselectable]': 'multiple',
                                '[attr.role]': 'role',
                                '[class.mat-chip-list-disabled]': 'disabled',
                                '[class.mat-chip-list-invalid]': 'errorState',
                                '[class.mat-chip-list-required]': 'required',
                                '[attr.aria-orientation]': 'ariaOrientation',
                                'class': 'mat-chip-list',
                                '(focus)': 'focus()',
                                '(blur)': '_blur()',
                                '(keydown)': '_keydown($event)',
                                '[id]': '_uid',
                            },
                            providers: [{ provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_12__["MatFormFieldControl"], useExisting: MatChipList }],
                            styles: [".mat-chip{position:relative;overflow:hidden;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0)}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(.4,0,.2,1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:'';pointer-events:none;transition:opacity .2s cubic-bezier(.35,0,.25,1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:0}.mat-standard-chip:focus::after{opacity:.16}@media (-ms-high-contrast:active){.mat-standard-chip{outline:solid 1px}.mat-standard-chip:focus{outline:dotted 2px}}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper .mat-standard-chip,.mat-chip-list-wrapper input.mat-input-element{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatChipList.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_9__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NgForm"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["FormGroupDirective"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["ErrorStateMatcher"] },
                { type: _angular_forms__WEBPACK_IMPORTED_MODULE_11__["NgControl"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Self"] }] }
            ]; };
            MatChipList.propDecorators = {
                errorStateMatcher: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                multiple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                compareWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                ariaOrientation: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-orientation',] }],
                selectable: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                chips: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [MatChip, {
                                // We need to use `descendants: true`, because Ivy will no longer match
                                // indirect descendants if it's left as false.
                                descendants: true
                            },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids.
            /** @type {?} */
            var nextUniqueId$1 = 0;
            /**
             * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.
             * May be placed inside or outside of an `<mat-chip-list>`.
             */
            var MatChipInput = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _defaultOptions
                 */
                function MatChipInput(_elementRef, _defaultOptions) {
                    this._elementRef = _elementRef;
                    this._defaultOptions = _defaultOptions;
                    /**
                     * Whether the control is focused.
                     */
                    this.focused = false;
                    this._addOnBlur = false;
                    /**
                     * The list of key codes that will trigger a chipEnd event.
                     *
                     * Defaults to `[ENTER]`.
                     */
                    this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;
                    /**
                     * Emitted when a chip is to be added.
                     */
                    this.chipEnd = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * The input's placeholder text.
                     */
                    this.placeholder = '';
                    /**
                     * Unique id for the input.
                     */
                    this.id = "mat-chip-list-input-" + nextUniqueId$1++;
                    this._disabled = false;
                    this._inputElement = ( /** @type {?} */(this._elementRef.nativeElement));
                }
                Object.defineProperty(MatChipInput.prototype, "chipList", {
                    /**
                     * Register input for chip list
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value) {
                            this._chipList = value;
                            this._chipList.registerInput(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "addOnBlur", {
                    /**
                     * Whether or not the chipEnd event will be emitted when the input is blurred.
                     * @return {?}
                     */
                    get: function () { return this._addOnBlur; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._addOnBlur = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "disabled", {
                    /**
                     * Whether the input is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled || (this._chipList && this._chipList.disabled); },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatChipInput.prototype, "empty", {
                    /**
                     * Whether the input is empty.
                     * @return {?}
                     */
                    get: function () { return !this._inputElement.value; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatChipInput.prototype.ngOnChanges = function () {
                    this._chipList.stateChanges.next();
                };
                /**
                 * Utility method to make host definition/tests more clear.
                 * @param {?=} event
                 * @return {?}
                 */
                MatChipInput.prototype._keydown = function (event) {
                    // Allow the user's focus to escape when they're tabbing forward. Note that we don't
                    // want to do this when going backwards, because focus should go back to the first chip.
                    if (event && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["TAB"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["hasModifierKey"])(event, 'shiftKey')) {
                        this._chipList._allowFocusEscape();
                    }
                    this._emitChipEnd(event);
                };
                /**
                 * Checks to see if the blur should emit the (chipEnd) event.
                 * @return {?}
                 */
                MatChipInput.prototype._blur = function () {
                    if (this.addOnBlur) {
                        this._emitChipEnd();
                    }
                    this.focused = false;
                    // Blur the chip list if it is not focused
                    if (!this._chipList.focused) {
                        this._chipList._blur();
                    }
                    this._chipList.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatChipInput.prototype._focus = function () {
                    this.focused = true;
                    this._chipList.stateChanges.next();
                };
                /**
                 * Checks to see if the (chipEnd) event needs to be emitted.
                 * @param {?=} event
                 * @return {?}
                 */
                MatChipInput.prototype._emitChipEnd = function (event) {
                    if (!this._inputElement.value && !!event) {
                        this._chipList._keydown(event);
                    }
                    if (!event || this._isSeparatorKey(event)) {
                        this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });
                        if (event) {
                            event.preventDefault();
                        }
                    }
                };
                /**
                 * @return {?}
                 */
                MatChipInput.prototype._onInput = function () {
                    // Let chip list know whenever the value changes.
                    this._chipList.stateChanges.next();
                };
                /**
                 * Focuses the input.
                 * @param {?=} options
                 * @return {?}
                 */
                MatChipInput.prototype.focus = function (options) {
                    this._inputElement.focus(options);
                };
                /**
                 * Checks whether a keycode is one of the configured separators.
                 * @private
                 * @param {?} event
                 * @return {?}
                 */
                MatChipInput.prototype._isSeparatorKey = function (event) {
                    if (Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["hasModifierKey"])(event)) {
                        return false;
                    }
                    /** @type {?} */
                    var separators = this.separatorKeyCodes;
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);
                };
                return MatChipInput;
            }());
            MatChipInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'input[matChipInputFor]',
                            exportAs: 'matChipInput, matChipInputFor',
                            host: {
                                'class': 'mat-chip-input mat-input-element',
                                '(keydown)': '_keydown($event)',
                                '(blur)': '_blur()',
                                '(focus)': '_focus()',
                                '(input)': '_onInput()',
                                '[id]': 'id',
                                '[attr.disabled]': 'disabled || null',
                                '[attr.placeholder]': 'placeholder || null',
                                '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatChipInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }
            ]; };
            MatChipInput.propDecorators = {
                chipList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputFor',] }],
                addOnBlur: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputAddOnBlur',] }],
                separatorKeyCodes: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matChipInputSeparatorKeyCodes',] }],
                chipEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"], args: ['matChipInputTokenEnd',] }],
                placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var CHIP_DECLARATIONS = [
                MatChipList,
                MatChip,
                MatChipInput,
                MatChipRemove,
                MatChipAvatar,
                MatChipTrailingIcon,
            ];
            var ɵ0 = ({
                separatorKeyCodes: [_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_1__["ENTER"]]
            });
            var MatChipsModule = /** @class */ (function () {
                function MatChipsModule() {
                }
                return MatChipsModule;
            }());
            MatChipsModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            exports: CHIP_DECLARATIONS,
                            declarations: CHIP_DECLARATIONS,
                            providers: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["ErrorStateMatcher"],
                                {
                                    provide: MAT_CHIPS_DEFAULT_OPTIONS,
                                    useValue: ( /** @type {?} */(ɵ0))
                                }
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=chips.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/datepicker.js": 
        /*!**************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/datepicker.js ***!
          \**************************************************************/
        /*! exports provided: MatMultiYearView, yearsPerPage, yearsPerRow, MatDatepickerModule, MatCalendarHeader, MatCalendar, MatCalendarCell, MatCalendarBody, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MatDatepickerContent, MatDatepicker, matDatepickerAnimations, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, MatDatepickerInputEvent, MatDatepickerInput, MatDatepickerIntl, MatDatepickerToggleIcon, MatDatepickerToggle, MatMonthView, MatYearView */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMultiYearView", function () { return MatMultiYearView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yearsPerPage", function () { return yearsPerPage; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yearsPerRow", function () { return yearsPerRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerModule", function () { return MatDatepickerModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarHeader", function () { return MatCalendarHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendar", function () { return MatCalendar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarCell", function () { return MatCalendarCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCalendarBody", function () { return MatCalendarBody; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY", function () { return MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY", function () { return MAT_DATEPICKER_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerContent", function () { return MatDatepickerContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepicker", function () { return MatDatepicker; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matDatepickerAnimations", function () { return matDatepickerAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALUE_ACCESSOR", function () { return MAT_DATEPICKER_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALIDATORS", function () { return MAT_DATEPICKER_VALIDATORS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInputEvent", function () { return MatDatepickerInputEvent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInput", function () { return MatDatepickerInput; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerIntl", function () { return MatDatepickerIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggleIcon", function () { return MatDatepickerToggleIcon; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggle", function () { return MatDatepickerToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMonthView", function () { return MatMonthView; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatYearView", function () { return MatYearView; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/dialog */ "./node_modules/@angular/material/esm2015/dialog.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony import */ var _angular_material_input__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/material/input */ "./node_modules/@angular/material/esm2015/input.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @param {?} provider
             * @return {?}
             */
            function createMissingDateImplError(provider) {
                return Error("MatDatepicker: No provider found for " + provider + ". You must import one of the following " +
                    "modules at your application root: MatNativeDateModule, MatMomentDateModule, or provide a " +
                    "custom implementation.");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Datepicker data that requires internationalization.
             */
            var MatDatepickerIntl = /** @class */ (function () {
                function MatDatepickerIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * A label for the calendar popup (used by screen readers).
                     */
                    this.calendarLabel = 'Calendar';
                    /**
                     * A label for the button used to open the calendar popup (used by screen readers).
                     */
                    this.openCalendarLabel = 'Open calendar';
                    /**
                     * A label for the previous month button (used by screen readers).
                     */
                    this.prevMonthLabel = 'Previous month';
                    /**
                     * A label for the next month button (used by screen readers).
                     */
                    this.nextMonthLabel = 'Next month';
                    /**
                     * A label for the previous year button (used by screen readers).
                     */
                    this.prevYearLabel = 'Previous year';
                    /**
                     * A label for the next year button (used by screen readers).
                     */
                    this.nextYearLabel = 'Next year';
                    /**
                     * A label for the previous multi-year button (used by screen readers).
                     */
                    this.prevMultiYearLabel = 'Previous 20 years';
                    /**
                     * A label for the next multi-year button (used by screen readers).
                     */
                    this.nextMultiYearLabel = 'Next 20 years';
                    /**
                     * A label for the 'switch to month view' button (used by screen readers).
                     */
                    this.switchToMonthViewLabel = 'Choose date';
                    /**
                     * A label for the 'switch to year view' button (used by screen readers).
                     */
                    this.switchToMultiYearViewLabel = 'Choose month and year';
                }
                /**
                 * Formats a range of years.
                 * @param {?} start
                 * @param {?} end
                 * @return {?}
                 */
                MatDatepickerIntl.prototype.formatYearRange = function (start, end) {
                    return start + " \u2013 " + end;
                };
                return MatDatepickerIntl;
            }());
            MatDatepickerIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatDatepickerIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatDatepickerIntl_Factory() { return new MatDatepickerIntl(); }, token: MatDatepickerIntl, providedIn: "root" });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * An internal class that represents the data corresponding to a single calendar cell.
             * \@docs-private
             */
            var MatCalendarCell = /** @class */ (function () {
                /**
                 * @param {?} value
                 * @param {?} displayValue
                 * @param {?} ariaLabel
                 * @param {?} enabled
                 * @param {?=} cssClasses
                 */
                function MatCalendarCell(value, displayValue, ariaLabel, enabled, cssClasses) {
                    this.value = value;
                    this.displayValue = displayValue;
                    this.ariaLabel = ariaLabel;
                    this.enabled = enabled;
                    this.cssClasses = cssClasses;
                }
                return MatCalendarCell;
            }());
            /**
             * An internal component used to display calendar data in a table.
             * \@docs-private
             */
            var MatCalendarBody = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 */
                function MatCalendarBody(_elementRef, _ngZone) {
                    this._elementRef = _elementRef;
                    this._ngZone = _ngZone;
                    /**
                     * The number of columns in the table.
                     */
                    this.numCols = 7;
                    /**
                     * The cell number of the active cell in the table.
                     */
                    this.activeCell = 0;
                    /**
                     * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
                     * maintained even as the table resizes.
                     */
                    this.cellAspectRatio = 1;
                    /**
                     * Emits when a new value is selected.
                     */
                    this.selectedValueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                }
                /**
                 * @param {?} cell
                 * @return {?}
                 */
                MatCalendarBody.prototype._cellClicked = function (cell) {
                    if (cell.enabled) {
                        this.selectedValueChange.emit(cell.value);
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatCalendarBody.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var columnChanges = changes['numCols'];
                    var _a = this, rows = _a.rows, numCols = _a.numCols;
                    if (changes['rows'] || columnChanges) {
                        this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;
                    }
                    if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {
                        this._cellPadding = 50 * this.cellAspectRatio / numCols + "%";
                    }
                    if (columnChanges || !this._cellWidth) {
                        this._cellWidth = 100 / numCols + "%";
                    }
                };
                /**
                 * @param {?} rowIndex
                 * @param {?} colIndex
                 * @return {?}
                 */
                MatCalendarBody.prototype._isActiveCell = function (rowIndex, colIndex) {
                    /** @type {?} */
                    var cellNumber = rowIndex * this.numCols + colIndex;
                    // Account for the fact that the first row may not have as many cells.
                    if (rowIndex) {
                        cellNumber -= this._firstRowOffset;
                    }
                    return cellNumber == this.activeCell;
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatCalendarBody.prototype._focusActiveCell = function () {
                    var _this = this;
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        _this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            /** @type {?} */
                            var activeCell = _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');
                            if (activeCell) {
                                activeCell.focus();
                            }
                        }));
                    }));
                };
                return MatCalendarBody;
            }());
            MatCalendarBody.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: '[mat-calendar-body]',
                            template: "<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\"><td class=\"mat-calendar-body-label\" [attr.colspan]=\"numCols\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{label}}</td></tr><tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\"><td *ngIf=\"rowIndex === 0 && _firstRowOffset\" aria-hidden=\"true\" class=\"mat-calendar-body-label\" [attr.colspan]=\"_firstRowOffset\" [style.paddingTop]=\"_cellPadding\" [style.paddingBottom]=\"_cellPadding\">{{_firstRowOffset >= labelMinRequiredCells ? label : ''}}</td><td *ngFor=\"let item of row; let colIndex = index\" role=\"gridcell\" class=\"mat-calendar-body-cell\" [ngClass]=\"item.cssClasses\" [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\" [class.mat-calendar-body-disabled]=\"!item.enabled\" [class.mat-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\" [attr.aria-label]=\"item.ariaLabel\" [attr.aria-disabled]=\"!item.enabled || null\" [attr.aria-selected]=\"selectedValue === item.value\" (click)=\"_cellClicked(item)\" [style.width]=\"_cellWidth\" [style.paddingTop]=\"_cellPadding\" role=\"button\" [style.paddingBottom]=\"_cellPadding\"><div class=\"mat-calendar-body-cell-content\" [class.mat-calendar-body-selected]=\"selectedValue === item.value\" [class.mat-calendar-body-today]=\"todayValue === item.value\">{{item.displayValue}}</div></td></tr>",
                            styles: [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}@media (-ms-high-contrast:active){.mat-calendar-body-cell-content{border:none}}@media (-ms-high-contrast:active){.mat-calendar-body-selected,.mat-datepicker-popup:not(:empty){outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}}[dir=rtl] .mat-calendar-body-label{text-align:right}"],
                            host: {
                                'class': 'mat-calendar-body',
                                'role': 'grid',
                                'aria-readonly': 'true'
                            },
                            exportAs: 'matCalendarBody',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendarBody.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] }
            ]; };
            MatCalendarBody.propDecorators = {
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                rows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                todayValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedValue: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelMinRequiredCells: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                numCols: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                activeCell: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                cellAspectRatio: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedValueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var DAYS_PER_WEEK = 7;
            /**
             * An internal component used to display a single month in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatMonthView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateFormats
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatMonthView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateFormats = _dateFormats;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new date is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is selected.
                     */
                    this._userSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatMonthView.prototype, "activeDate", {
                    /**
                     * The date to display in this month view (everything other than the month and year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedDate = this._getDateInCurrentMonth(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMonthView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMonthView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Handles when a new date is selected.
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._dateSelected = function (date) {
                    if (this._selectedDate != date) {
                        /** @type {?} */
                        var selectedYear = this._dateAdapter.getYear(this.activeDate);
                        /** @type {?} */
                        var selectedMonth = this._dateAdapter.getMonth(this.activeDate);
                        /** @type {?} */
                        var selectedDate = this._dateAdapter.createDate(selectedYear, selectedMonth, date);
                        this.selectedChange.emit(selectedDate);
                    }
                    this._userSelection.emit();
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in month view.
                 * @param {?} event
                 * @return {?}
                 */
                MatMonthView.prototype._handleCalendarBodyKeydown = function (event) {
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, (this._dateAdapter.getNumDaysInMonth(this._activeDate) -
                                this._dateAdapter.getDate(this._activeDate)));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate = event.altKey ?
                                this._dateAdapter.addCalendarYears(this._activeDate, -1) :
                                this._dateAdapter.addCalendarMonths(this._activeDate, -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate = event.altKey ?
                                this._dateAdapter.addCalendarYears(this._activeDate, 1) :
                                this._dateAdapter.addCalendarMonths(this._activeDate, 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            if (!this.dateFilter || this.dateFilter(this._activeDate)) {
                                this._dateSelected(this._dateAdapter.getDate(this._activeDate));
                                this._userSelection.emit();
                                // Prevent unexpected default actions such as form submission.
                                event.preventDefault();
                            }
                            return;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * Initializes this month view.
                 * @return {?}
                 */
                MatMonthView.prototype._init = function () {
                    this._selectedDate = this._getDateInCurrentMonth(this.selected);
                    this._todayDate = this._getDateInCurrentMonth(this._dateAdapter.today());
                    this._monthLabel =
                        this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)]
                            .toLocaleUpperCase();
                    /** @type {?} */
                    var firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);
                    this._firstWeekOffset =
                        (DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) -
                            this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK;
                    this._initWeekdays();
                    this._createWeekCells();
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatMonthView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Initializes the weekdays.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._initWeekdays = function () {
                    /** @type {?} */
                    var firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();
                    /** @type {?} */
                    var narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');
                    /** @type {?} */
                    var longWeekdays = this._dateAdapter.getDayOfWeekNames('long');
                    // Rotate the labels for days of the week based on the configured first day of the week.
                    /** @type {?} */
                    var weekdays = longWeekdays.map(( /**
                     * @param {?} long
                     * @param {?} i
                     * @return {?}
                     */function (long, i) {
                        return { long: long, narrow: narrowWeekdays[i] };
                    }));
                    this._weekdays = weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek));
                };
                /**
                 * Creates MatCalendarCells for the dates in this month.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._createWeekCells = function () {
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);
                    /** @type {?} */
                    var dateNames = this._dateAdapter.getDateNames();
                    this._weeks = [[]];
                    for (var i = 0, cell = this._firstWeekOffset; i < daysInMonth; i++, cell++) {
                        if (cell == DAYS_PER_WEEK) {
                            this._weeks.push([]);
                            cell = 0;
                        }
                        /** @type {?} */
                        var date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);
                        /** @type {?} */
                        var enabled = this._shouldEnableDate(date);
                        /** @type {?} */
                        var ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);
                        /** @type {?} */
                        var cellClasses = this.dateClass ? this.dateClass(date) : undefined;
                        this._weeks[this._weeks.length - 1]
                            .push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses));
                    }
                };
                /**
                 * Date filter for the month
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._shouldEnableDate = function (date) {
                    return !!date &&
                        (!this.dateFilter || this.dateFilter(date)) &&
                        (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) &&
                        (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0);
                };
                /**
                 * Gets the date in this month that the given Date falls on.
                 * Returns null if the given Date is in another month.
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatMonthView.prototype._getDateInCurrentMonth = function (date) {
                    return date && this._hasSameMonthAndYear(date, this.activeDate) ?
                        this._dateAdapter.getDate(date) : null;
                };
                /**
                 * Checks whether the 2 dates are non-null and fall within the same month of the same year.
                 * @private
                 * @param {?} d1
                 * @param {?} d2
                 * @return {?}
                 */
                MatMonthView.prototype._hasSameMonthAndYear = function (d1, d2) {
                    return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) &&
                        this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatMonthView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatMonthView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatMonthView;
            }());
            MatMonthView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-month-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th scope=\"col\" *ngFor=\"let day of _weekdays\" [attr.aria-label]=\"day.long\">{{day.narrow}}</th></tr><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"7\" aria-hidden=\"true\"></th></tr></thead><tbody mat-calendar-body [label]=\"_monthLabel\" [rows]=\"_weeks\" [todayValue]=\"_todayDate\" [selectedValue]=\"_selectedDate\" [labelMinRequiredCells]=\"3\" [activeCell]=\"_dateAdapter.getDate(activeDate) - 1\" (selectedValueChange)=\"_dateSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matMonthView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatMonthView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatMonthView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _userSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var yearsPerPage = 24;
            /** @type {?} */
            var yearsPerRow = 4;
            /**
             * An internal component used to display a year selector in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatMultiYearView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatMultiYearView(_changeDetectorRef, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new year is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the selected year. This doesn't imply a change on the selected date
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatMultiYearView.prototype, "activeDate", {
                    /**
                     * The date to display in this multi-year view (everything other than the year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedYear = this._selected && this._dateAdapter.getYear(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMultiYearView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMultiYearView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Initializes this multi-year view.
                 * @return {?}
                 */
                MatMultiYearView.prototype._init = function () {
                    var _this = this;
                    this._todayYear = this._dateAdapter.getYear(this._dateAdapter.today());
                    // We want a range years such that we maximize the number of
                    // enabled dates visible at once. This prevents issues where the minimum year
                    // is the last item of a page OR the maximum year is the first item of a page.
                    // The offset from the active year to the "slot" for the starting year is the
                    // *actual* first rendered year in the multi-year view.
                    /** @type {?} */
                    var activeYear = this._dateAdapter.getYear(this._activeDate);
                    /** @type {?} */
                    var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
                    this._years = [];
                    for (var i = 0, row = []; i < yearsPerPage; i++) {
                        row.push(minYearOfPage + i);
                        if (row.length == yearsPerRow) {
                            this._years.push(row.map(( /**
                             * @param {?} year
                             * @return {?}
                             */function (/**
                             * @param {?} year
                             * @return {?}
                             */ year) { return _this._createCellForYear(year); })));
                            row = [];
                        }
                    }
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Handles when a new year is selected.
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._yearSelected = function (year) {
                    this.yearSelected.emit(this._dateAdapter.createDate(year, 0, 1));
                    /** @type {?} */
                    var month = this._dateAdapter.getMonth(this.activeDate);
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, month, 1));
                    this.selectedChange.emit(this._dateAdapter.createDate(year, month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in multi-year view.
                 * @param {?} event
                 * @return {?}
                 */
                MatMultiYearView.prototype._handleCalendarBodyKeydown = function (event) {
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            this._yearSelected(this._dateAdapter.getYear(this._activeDate));
                            break;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * @return {?}
                 */
                MatMultiYearView.prototype._getActiveCell = function () {
                    return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatMultiYearView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Creates an MatCalendarCell for the given year.
                 * @private
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._createCellForYear = function (year) {
                    /** @type {?} */
                    var yearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(year, 0, 1));
                    return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year));
                };
                /**
                 * Whether the given year is enabled.
                 * @private
                 * @param {?} year
                 * @return {?}
                 */
                MatMultiYearView.prototype._shouldEnableYear = function (year) {
                    // disable if the year is greater than maxDate lower than minDate
                    if (year === undefined || year === null ||
                        (this.maxDate && year > this._dateAdapter.getYear(this.maxDate)) ||
                        (this.minDate && year < this._dateAdapter.getYear(this.minDate))) {
                        return false;
                    }
                    // enable if it reaches here and there's no filter defined
                    if (!this.dateFilter) {
                        return true;
                    }
                    /** @type {?} */
                    var firstOfYear = this._dateAdapter.createDate(year, 0, 1);
                    // If any date in the year is enabled count the year as enabled.
                    for (var date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {
                        if (this.dateFilter(date)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatMultiYearView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatMultiYearView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatMultiYearView;
            }());
            MatMultiYearView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-multi-year-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [rows]=\"_years\" [todayValue]=\"_todayYear\" [selectedValue]=\"_selectedYear\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_getActiveCell()\" (selectedValueChange)=\"_yearSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matMultiYearView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatMultiYearView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatMultiYearView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @template D
             * @param {?} dateAdapter
             * @param {?} date1
             * @param {?} date2
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {
                /** @type {?} */
                var year1 = dateAdapter.getYear(date1);
                /** @type {?} */
                var year2 = dateAdapter.getYear(date2);
                /** @type {?} */
                var startingYear = getStartingYear(dateAdapter, minDate, maxDate);
                return Math.floor((year1 - startingYear) / yearsPerPage) ===
                    Math.floor((year2 - startingYear) / yearsPerPage);
            }
            /**
             * When the multi-year view is first opened, the active year will be in view.
             * So we compute how many years are between the active year and the *slot* where our
             * "startingYear" will render when paged into view.
             * @template D
             * @param {?} dateAdapter
             * @param {?} activeDate
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {
                /** @type {?} */
                var activeYear = dateAdapter.getYear(activeDate);
                return euclideanModulo((activeYear - getStartingYear(dateAdapter, minDate, maxDate)), yearsPerPage);
            }
            /**
             * We pick a "starting" year such that either the maximum year would be at the end
             * or the minimum year would be at the beginning of a page.
             * @template D
             * @param {?} dateAdapter
             * @param {?} minDate
             * @param {?} maxDate
             * @return {?}
             */
            function getStartingYear(dateAdapter, minDate, maxDate) {
                /** @type {?} */
                var startingYear = 0;
                if (maxDate) {
                    /** @type {?} */
                    var maxYear = dateAdapter.getYear(maxDate);
                    startingYear = maxYear - yearsPerPage + 1;
                }
                else if (minDate) {
                    startingYear = dateAdapter.getYear(minDate);
                }
                return startingYear;
            }
            /**
             * Gets remainder that is non-negative, even if first number is negative
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            function euclideanModulo(a, b) {
                return (a % b + b) % b;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * An internal component used to display a single year in the datepicker.
             * \@docs-private
             * @template D
             */
            var MatYearView = /** @class */ (function () {
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _dateFormats
                 * @param {?} _dateAdapter
                 * @param {?=} _dir
                 */
                function MatYearView(_changeDetectorRef, _dateFormats, _dateAdapter, _dir) {
                    this._changeDetectorRef = _changeDetectorRef;
                    this._dateFormats = _dateFormats;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    /**
                     * Emits when a new month is selected.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the selected month. This doesn't imply a change on the selected date
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is activated.
                     */
                    this.activeDateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._activeDate = this._dateAdapter.today();
                }
                Object.defineProperty(MatYearView.prototype, "activeDate", {
                    /**
                     * The date to display in this year view (everything other than the year is ignored).
                     * @return {?}
                     */
                    get: function () { return this._activeDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var oldActiveDate = this._activeDate;
                        /** @type {?} */
                        var validDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();
                        this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);
                        if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {
                            this._init();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._selectedMonth = this._getMonthInCurrentYear(this._selected);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatYearView.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatYearView.prototype.ngAfterContentInit = function () {
                    this._init();
                };
                /**
                 * Handles when a new month is selected.
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._monthSelected = function (month) {
                    /** @type {?} */
                    var normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);
                    this.monthSelected.emit(normalizedDate);
                    /** @type {?} */
                    var daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);
                    this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth)));
                };
                /**
                 * Handles keydown events on the calendar body when calendar is in year view.
                 * @param {?} event
                 * @return {?}
                 */
                MatYearView.prototype._handleCalendarBodyKeydown = function (event) {
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    // TODO(mmalerba): We currently allow keyboard navigation to disabled dates, but just prevent
                    // disabled ones from being selected. This may not be ideal, we should look into whether
                    // navigation should skip over disabled dates, and if so, how to implement that efficiently.
                    /** @type {?} */
                    var oldActiveDate = this._activeDate;
                    /** @type {?} */
                    var isRtl = this._isRtl();
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this.activeDate =
                                this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ENTER"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["SPACE"]:
                            this._monthSelected(this._dateAdapter.getMonth(this._activeDate));
                            break;
                        default:
                            // Don't prevent default or focus active cell on keys that we don't explicitly handle.
                            return;
                    }
                    if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {
                        this.activeDateChange.emit(this.activeDate);
                    }
                    this._focusActiveCell();
                    // Prevent unexpected default actions such as form submission.
                    event.preventDefault();
                };
                /**
                 * Initializes this year view.
                 * @return {?}
                 */
                MatYearView.prototype._init = function () {
                    var _this = this;
                    this._selectedMonth = this._getMonthInCurrentYear(this.selected);
                    this._todayMonth = this._getMonthInCurrentYear(this._dateAdapter.today());
                    this._yearLabel = this._dateAdapter.getYearName(this.activeDate);
                    /** @type {?} */
                    var monthNames = this._dateAdapter.getMonthNames('short');
                    // First row of months only contains 5 elements so we can fit the year label on the same row.
                    this._months = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(( /**
                     * @param {?} row
                     * @return {?}
                     */function (/**
                     * @param {?} row
                     * @return {?}
                     */ row) { return row.map(( /**
                     * @param {?} month
                     * @return {?}
                     */function (/**
                     * @param {?} month
                     * @return {?}
                     */ month) { return _this._createCellForMonth(month, monthNames[month]); })); }));
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the active cell after the microtask queue is empty.
                 * @return {?}
                 */
                MatYearView.prototype._focusActiveCell = function () {
                    this._matCalendarBody._focusActiveCell();
                };
                /**
                 * Gets the month in this year that the given Date falls on.
                 * Returns null if the given Date is in another year.
                 * @private
                 * @param {?} date
                 * @return {?}
                 */
                MatYearView.prototype._getMonthInCurrentYear = function (date) {
                    return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ?
                        this._dateAdapter.getMonth(date) : null;
                };
                /**
                 * Creates an MatCalendarCell for the given month.
                 * @private
                 * @param {?} month
                 * @param {?} monthName
                 * @return {?}
                 */
                MatYearView.prototype._createCellForMonth = function (month, monthName) {
                    /** @type {?} */
                    var ariaLabel = this._dateAdapter.format(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1), this._dateFormats.display.monthYearA11yLabel);
                    return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month));
                };
                /**
                 * Whether the given month is enabled.
                 * @private
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._shouldEnableMonth = function (month) {
                    /** @type {?} */
                    var activeYear = this._dateAdapter.getYear(this.activeDate);
                    if (month === undefined || month === null ||
                        this._isYearAndMonthAfterMaxDate(activeYear, month) ||
                        this._isYearAndMonthBeforeMinDate(activeYear, month)) {
                        return false;
                    }
                    if (!this.dateFilter) {
                        return true;
                    }
                    /** @type {?} */
                    var firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);
                    // If any date in the month is enabled count the month as enabled.
                    for (var date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {
                        if (this.dateFilter(date)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * Tests whether the combination month/year is after this.maxDate, considering
                 * just the month and year of this.maxDate
                 * @private
                 * @param {?} year
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._isYearAndMonthAfterMaxDate = function (year, month) {
                    if (this.maxDate) {
                        /** @type {?} */
                        var maxYear = this._dateAdapter.getYear(this.maxDate);
                        /** @type {?} */
                        var maxMonth = this._dateAdapter.getMonth(this.maxDate);
                        return year > maxYear || (year === maxYear && month > maxMonth);
                    }
                    return false;
                };
                /**
                 * Tests whether the combination month/year is before this.minDate, considering
                 * just the month and year of this.minDate
                 * @private
                 * @param {?} year
                 * @param {?} month
                 * @return {?}
                 */
                MatYearView.prototype._isYearAndMonthBeforeMinDate = function (year, month) {
                    if (this.minDate) {
                        /** @type {?} */
                        var minYear = this._dateAdapter.getYear(this.minDate);
                        /** @type {?} */
                        var minMonth = this._dateAdapter.getMonth(this.minDate);
                        return year < minYear || (year === minYear && month < minMonth);
                    }
                    return false;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatYearView.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Determines whether the user has the RTL layout direction.
                 * @private
                 * @return {?}
                 */
                MatYearView.prototype._isRtl = function () {
                    return this._dir && this._dir.value === 'rtl';
                };
                return MatYearView;
            }());
            MatYearView.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-year-view',
                            template: "<table class=\"mat-calendar-table\" role=\"presentation\"><thead class=\"mat-calendar-table-header\"><tr><th class=\"mat-calendar-table-header-divider\" colspan=\"4\"></th></tr></thead><tbody mat-calendar-body [label]=\"_yearLabel\" [rows]=\"_months\" [todayValue]=\"_todayMonth\" [selectedValue]=\"_selectedMonth\" [labelMinRequiredCells]=\"2\" [numCols]=\"4\" [cellAspectRatio]=\"4 / 7\" [activeCell]=\"_dateAdapter.getMonth(activeDate)\" (selectedValueChange)=\"_monthSelected($event)\" (keydown)=\"_handleCalendarBodyKeydown($event)\"></tbody></table>",
                            exportAs: 'matYearView',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatYearView.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatYearView.propDecorators = {
                activeDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                activeDateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _matCalendarBody: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendarBody, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Default header for MatCalendar
             * @template D
             */
            var MatCalendarHeader = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} calendar
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} changeDetectorRef
                 */
                function MatCalendarHeader(_intl, calendar, _dateAdapter, _dateFormats, changeDetectorRef) {
                    this._intl = _intl;
                    this.calendar = calendar;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this.calendar.stateChanges.subscribe(( /**
                     * @return {?}
                     */function () { return changeDetectorRef.markForCheck(); }));
                }
                Object.defineProperty(MatCalendarHeader.prototype, "periodButtonText", {
                    /**
                     * The label for the current calendar view.
                     * @return {?}
                     */
                    get: function () {
                        if (this.calendar.currentView == 'month') {
                            return this._dateAdapter
                                .format(this.calendar.activeDate, this._dateFormats.display.monthYearLabel)
                                .toLocaleUpperCase();
                        }
                        if (this.calendar.currentView == 'year') {
                            return this._dateAdapter.getYearName(this.calendar.activeDate);
                        }
                        // The offset from the active year to the "slot" for the starting year is the
                        // *actual* first rendered year in the multi-year view, and the last year is
                        // just yearsPerPage - 1 away.
                        /** @type {?} */
                        var activeYear = this._dateAdapter.getYear(this.calendar.activeDate);
                        /** @type {?} */
                        var minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);
                        /** @type {?} */
                        var maxYearOfPage = minYearOfPage + yearsPerPage - 1;
                        /** @type {?} */
                        var minYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));
                        /** @type {?} */
                        var maxYearName = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));
                        return this._intl.formatYearRange(minYearName, maxYearName);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "periodButtonLabel", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this.calendar.currentView == 'month' ?
                            this._intl.switchToMultiYearViewLabel : this._intl.switchToMonthViewLabel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "prevButtonLabel", {
                    /**
                     * The label for the previous button.
                     * @return {?}
                     */
                    get: function () {
                        return {
                            'month': this._intl.prevMonthLabel,
                            'year': this._intl.prevYearLabel,
                            'multi-year': this._intl.prevMultiYearLabel
                        }[this.calendar.currentView];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendarHeader.prototype, "nextButtonLabel", {
                    /**
                     * The label for the next button.
                     * @return {?}
                     */
                    get: function () {
                        return {
                            'month': this._intl.nextMonthLabel,
                            'year': this._intl.nextYearLabel,
                            'multi-year': this._intl.nextMultiYearLabel
                        }[this.calendar.currentView];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Handles user clicks on the period label.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.currentPeriodClicked = function () {
                    this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';
                };
                /**
                 * Handles user clicks on the previous button.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.previousClicked = function () {
                    this.calendar.activeDate = this.calendar.currentView == 'month' ?
                        this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) :
                        this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);
                };
                /**
                 * Handles user clicks on the next button.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.nextClicked = function () {
                    this.calendar.activeDate = this.calendar.currentView == 'month' ?
                        this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) :
                        this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);
                };
                /**
                 * Whether the previous period button is enabled.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.previousEnabled = function () {
                    if (!this.calendar.minDate) {
                        return true;
                    }
                    return !this.calendar.minDate ||
                        !this._isSameView(this.calendar.activeDate, this.calendar.minDate);
                };
                /**
                 * Whether the next period button is enabled.
                 * @return {?}
                 */
                MatCalendarHeader.prototype.nextEnabled = function () {
                    return !this.calendar.maxDate ||
                        !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);
                };
                /**
                 * Whether the two dates represent the same view in the current view mode (month or year).
                 * @private
                 * @param {?} date1
                 * @param {?} date2
                 * @return {?}
                 */
                MatCalendarHeader.prototype._isSameView = function (date1, date2) {
                    if (this.calendar.currentView == 'month') {
                        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) &&
                            this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);
                    }
                    if (this.calendar.currentView == 'year') {
                        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);
                    }
                    // Otherwise we are in 'multi-year' view.
                    return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);
                };
                return MatCalendarHeader;
            }());
            MatCalendarHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-calendar-header',
                            template: "<div class=\"mat-calendar-header\"><div class=\"mat-calendar-controls\"><button mat-button type=\"button\" class=\"mat-calendar-period-button\" (click)=\"currentPeriodClicked()\" [attr.aria-label]=\"periodButtonLabel\" cdkAriaLive=\"polite\">{{periodButtonText}}<div class=\"mat-calendar-arrow\" [class.mat-calendar-invert]=\"calendar.currentView != 'month'\"></div></button><div class=\"mat-calendar-spacer\"></div><ng-content></ng-content><button mat-icon-button type=\"button\" class=\"mat-calendar-previous-button\" [disabled]=\"!previousEnabled()\" (click)=\"previousClicked()\" [attr.aria-label]=\"prevButtonLabel\"></button> <button mat-icon-button type=\"button\" class=\"mat-calendar-next-button\" [disabled]=\"!nextEnabled()\" (click)=\"nextClicked()\" [attr.aria-label]=\"nextButtonLabel\"></button></div></div>",
                            exportAs: 'matCalendarHeader',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendarHeader.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: MatCalendar, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatCalendar; })),] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            /**
             * A calendar that is used as part of the datepicker.
             * \@docs-private
             * @template D
             */
            var MatCalendar = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} _changeDetectorRef
                 */
                function MatCalendar(_intl, _dateAdapter, _dateFormats, _changeDetectorRef) {
                    var _this = this;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Used for scheduling that focus should be moved to the active cell on the next tick.
                     * We need to schedule it, rather than do it immediately, because we have to wait
                     * for Angular to re-evaluate the view children.
                     */
                    this._moveFocusOnNextTick = false;
                    /**
                     * Whether the calendar should be started in month or year view.
                     */
                    this.startView = 'month';
                    /**
                     * Emits when the currently selected date changes.
                     */
                    this.selectedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the year chosen in multiyear view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits the month chosen in year view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when any date is selected.
                     */
                    this._userSelection = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits whenever there is a state change that the header may need to respond to.
                     */
                    this.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    this._intlChanges = _intl.changes.subscribe(( /**
                     * @return {?}
                     */function () {
                        _changeDetectorRef.markForCheck();
                        _this.stateChanges.next();
                    }));
                }
                Object.defineProperty(MatCalendar.prototype, "startAt", {
                    /**
                     * A date representing the period (month or year) to start the calendar in.
                     * @return {?}
                     */
                    get: function () { return this._startAt; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._selected = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._minDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._minDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () { return this._maxDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._maxDate = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "activeDate", {
                    /**
                     * The current active date. This determines which time period is shown and which date is
                     * highlighted when using keyboard navigation.
                     * @return {?}
                     */
                    get: function () { return this._clampedActiveDate; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);
                        this.stateChanges.next();
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatCalendar.prototype, "currentView", {
                    /**
                     * Whether the calendar is in month view.
                     * @return {?}
                     */
                    get: function () { return this._currentView; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._currentView = value;
                        this._moveFocusOnNextTick = true;
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngAfterContentInit = function () {
                    this._calendarHeaderPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["ComponentPortal"](this.headerComponent || MatCalendarHeader);
                    this.activeDate = this.startAt || this._dateAdapter.today();
                    // Assign to the private property since we don't want to move focus on init.
                    this._currentView = this.startView;
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngAfterViewChecked = function () {
                    if (this._moveFocusOnNextTick) {
                        this._moveFocusOnNextTick = false;
                        this.focusActiveCell();
                    }
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.ngOnDestroy = function () {
                    this._intlChanges.unsubscribe();
                    this.stateChanges.complete();
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatCalendar.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var change = changes['minDate'] || changes['maxDate'] || changes['dateFilter'];
                    if (change && !change.firstChange) {
                        /** @type {?} */
                        var view = this._getCurrentViewComponent();
                        if (view) {
                            // We need to `detectChanges` manually here, because the `minDate`, `maxDate` etc. are
                            // passed down to the view via data bindings which won't be up-to-date when we call `_init`.
                            this._changeDetectorRef.detectChanges();
                            view._init();
                        }
                    }
                    this.stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype.focusActiveCell = function () {
                    this._getCurrentViewComponent()._focusActiveCell();
                };
                /**
                 * Updates today's date after an update of the active date
                 * @return {?}
                 */
                MatCalendar.prototype.updateTodaysDate = function () {
                    /** @type {?} */
                    var view = this.currentView == 'month' ? this.monthView :
                        (this.currentView == 'year' ? this.yearView : this.multiYearView);
                    view.ngAfterContentInit();
                };
                /**
                 * Handles date selection in the month view.
                 * @param {?} date
                 * @return {?}
                 */
                MatCalendar.prototype._dateSelected = function (date) {
                    if (!this._dateAdapter.sameDate(date, this.selected)) {
                        this.selectedChange.emit(date);
                    }
                };
                /**
                 * Handles year selection in the multiyear view.
                 * @param {?} normalizedYear
                 * @return {?}
                 */
                MatCalendar.prototype._yearSelectedInMultiYearView = function (normalizedYear) {
                    this.yearSelected.emit(normalizedYear);
                };
                /**
                 * Handles month selection in the year view.
                 * @param {?} normalizedMonth
                 * @return {?}
                 */
                MatCalendar.prototype._monthSelectedInYearView = function (normalizedMonth) {
                    this.monthSelected.emit(normalizedMonth);
                };
                /**
                 * @return {?}
                 */
                MatCalendar.prototype._userSelected = function () {
                    this._userSelection.emit();
                };
                /**
                 * Handles year/month selection in the multi-year/year views.
                 * @param {?} date
                 * @param {?} view
                 * @return {?}
                 */
                MatCalendar.prototype._goToDateInView = function (date, view) {
                    this.activeDate = date;
                    this.currentView = view;
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatCalendar.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Returns the component instance that corresponds to the current calendar view.
                 * @private
                 * @return {?}
                 */
                MatCalendar.prototype._getCurrentViewComponent = function () {
                    return this.monthView || this.yearView || this.multiYearView;
                };
                return MatCalendar;
            }());
            MatCalendar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-calendar',
                            template: "<ng-template [cdkPortalOutlet]=\"_calendarHeaderPortal\"></ng-template><div class=\"mat-calendar-content\" [ngSwitch]=\"currentView\" cdkMonitorSubtreeFocus tabindex=\"-1\"><mat-month-view *ngSwitchCase=\"'month'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" [dateClass]=\"dateClass\" (selectedChange)=\"_dateSelected($event)\" (_userSelection)=\"_userSelected()\"></mat-month-view><mat-year-view *ngSwitchCase=\"'year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (monthSelected)=\"_monthSelectedInYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'month')\"></mat-year-view><mat-multi-year-view *ngSwitchCase=\"'multi-year'\" [(activeDate)]=\"activeDate\" [selected]=\"selected\" [dateFilter]=\"dateFilter\" [maxDate]=\"maxDate\" [minDate]=\"minDate\" (yearSelected)=\"_yearSelectedInMultiYearView($event)\" (selectedChange)=\"_goToDateInView($event, 'year')\"></mat-multi-year-view></div>",
                            styles: [".mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:0}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-next-button,.mat-calendar-previous-button{position:relative}.mat-calendar-next-button::after,.mat-calendar-previous-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:'';margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-next-button,[dir=rtl] .mat-calendar-previous-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:'';position:absolute;top:0;left:-8px;right:-8px;height:1px}"],
                            host: {
                                'class': 'mat-calendar',
                            },
                            exportAs: 'matCalendar',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatCalendar.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatCalendar.propDecorators = {
                headerComponent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startAt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                minDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                maxDate: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selectedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _userSelection: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatMonthView, { static: false },] }],
                yearView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatYearView, { static: false },] }],
                multiYearView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatMultiYearView, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material datepicker.
             * \@docs-private
             * @type {?}
             */
            var matDatepickerAnimations = {
                /**
                 * Transforms the height of the datepicker's calendar.
                 */
                transformPanel: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["trigger"])('transformPanel', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({
                        opacity: 0,
                        transform: 'scale(1, 0.8)'
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('void => enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('120ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({
                        opacity: 1,
                        transform: 'scale(1, 1)'
                    }))),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('* => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('100ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 0 })))
                ]),
                /**
                 * Fades in the content of the calendar.
                 */
                fadeInCalendar: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["trigger"])('fadeInCalendar', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 0 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["state"])('enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["style"])({ opacity: 1 })),
                    // TODO(crisbeto): this animation should be removed since it isn't quite on spec, but we
                    // need to keep it until #12440 gets in, otherwise the exit animation will look glitchy.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["transition"])('void => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_7__["animate"])('120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)'))
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used to generate a unique ID for each datepicker instance.
             * @type {?}
             */
            var datepickerUid = 0;
            /**
             * Injection token that determines the scroll handling while the calendar is open.
             * @type {?}
             */
            var MAT_DATEPICKER_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-datepicker-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_DATEPICKER_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"]],
                useFactory: MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY,
            };
            // Boilerplate for applying mixins to MatDatepickerContent.
            /**
             * \@docs-private
             */
            var MatDatepickerContentBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatDatepickerContentBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatDatepickerContentBase;
            }());
            /** @type {?} */
            var _MatDatepickerContentMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["mixinColor"])(MatDatepickerContentBase);
            /**
             * Component used as the content for the datepicker dialog and popup. We use this instead of using
             * MatCalendar directly as the content so we can control the initial focus. This also gives us a
             * place to put additional features of the popup that are not part of the calendar itself in the
             * future. (e.g. confirmation buttons).
             * \@docs-private
             * @template D
             */
            var MatDatepickerContent = /** @class */ (function (_super) {
                __extends(MatDatepickerContent, _super);
                /**
                 * @param {?} elementRef
                 */
                function MatDatepickerContent(elementRef) {
                    return _super.call(this, elementRef) || this;
                }
                /**
                 * @return {?}
                 */
                MatDatepickerContent.prototype.ngAfterViewInit = function () {
                    this._calendar.focusActiveCell();
                };
                return MatDatepickerContent;
            }(_MatDatepickerContentMixinBase));
            MatDatepickerContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker-content',
                            template: "<mat-calendar cdkTrapFocus [id]=\"datepicker.id\" [ngClass]=\"datepicker.panelClass\" [startAt]=\"datepicker.startAt\" [startView]=\"datepicker.startView\" [minDate]=\"datepicker._minDate\" [maxDate]=\"datepicker._maxDate\" [dateFilter]=\"datepicker._dateFilter\" [headerComponent]=\"datepicker.calendarHeaderComponent\" [selected]=\"datepicker._selected\" [dateClass]=\"datepicker.dateClass\" [@fadeInCalendar]=\"'enter'\" (selectedChange)=\"datepicker.select($event)\" (yearSelected)=\"datepicker._selectYear($event)\" (monthSelected)=\"datepicker._selectMonth($event)\" (_userSelection)=\"datepicker.close()\"></mat-calendar>",
                            styles: [".mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content-touch{display:block;max-height:80vh;overflow:auto;margin:-24px}.mat-datepicker-content-touch .mat-calendar{min-width:250px;min-height:312px;max-width:750px;max-height:788px}@media all and (orientation:landscape){.mat-datepicker-content-touch .mat-calendar{width:64vh;height:80vh}}@media all and (orientation:portrait){.mat-datepicker-content-touch .mat-calendar{width:80vw;height:100vw}}"],
                            host: {
                                'class': 'mat-datepicker-content',
                                '[@transformPanel]': '"enter"',
                                '[class.mat-datepicker-content-touch]': 'datepicker.touchUi',
                            },
                            animations: [
                                matDatepickerAnimations.transformPanel,
                                matDatepickerAnimations.fadeInCalendar,
                            ],
                            exportAs: 'matDatepickerContent',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['color'],
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            MatDatepickerContent.propDecorators = {
                _calendar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: [MatCalendar, { static: false },] }]
            };
            // TODO(mmalerba): We use a component instead of a directive here so the user can use implicit
            // template reference variables (e.g. #d vs #d="matDatepicker"). We can change this to a directive
            // if angular adds support for `exportAs: '$implicit'` on directives.
            /**
             * Component responsible for managing the datepicker popup/dialog.
             * @template D
             */
            var MatDatepicker = /** @class */ (function () {
                /**
                 * @param {?} _dialog
                 * @param {?} _overlay
                 * @param {?} _ngZone
                 * @param {?} _viewContainerRef
                 * @param {?} scrollStrategy
                 * @param {?} _dateAdapter
                 * @param {?} _dir
                 * @param {?} _document
                 */
                function MatDatepicker(_dialog, _overlay, _ngZone, _viewContainerRef, scrollStrategy, _dateAdapter, _dir, _document) {
                    this._dialog = _dialog;
                    this._overlay = _overlay;
                    this._ngZone = _ngZone;
                    this._viewContainerRef = _viewContainerRef;
                    this._dateAdapter = _dateAdapter;
                    this._dir = _dir;
                    this._document = _document;
                    /**
                     * The view that the calendar should start in.
                     */
                    this.startView = 'month';
                    this._touchUi = false;
                    /**
                     * Emits selected year in multiyear view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.yearSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits selected month in year view.
                     * This doesn't imply a change on the selected date.
                     */
                    this.monthSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the datepicker has been opened.
                     */
                    this.openedStream = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the datepicker has been closed.
                     */
                    this.closedStream = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._opened = false;
                    /**
                     * The id for the datepicker calendar.
                     */
                    this.id = "mat-datepicker-" + datepickerUid++;
                    this._validSelected = null;
                    /**
                     * The element that was focused before the datepicker was opened.
                     */
                    this._focusedElementBeforeOpen = null;
                    /**
                     * Subscription to value changes in the associated input element.
                     */
                    this._inputSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /**
                     * Emits when the datepicker is disabled.
                     */
                    this._disabledChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    /**
                     * Emits new selected date when selected date changes.
                     */
                    this._selectedChanged = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatDatepicker.prototype, "startAt", {
                    /**
                     * The date to open the calendar to initially.
                     * @return {?}
                     */
                    get: function () {
                        // If an explicit startAt is set we start there, otherwise we start at whatever the currently
                        // selected value is.
                        return this._startAt || (this._datepickerInput ? this._datepickerInput.value : null);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._startAt = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "color", {
                    /**
                     * Color palette to use on the datepicker's calendar.
                     * @return {?}
                     */
                    get: function () {
                        return this._color ||
                            (this._datepickerInput ? this._datepickerInput._getThemePalette() : undefined);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._color = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "touchUi", {
                    /**
                     * Whether the calendar UI is in touch mode. In touch mode the calendar opens in a dialog rather
                     * than a popup and elements have more padding to allow for bigger touch targets.
                     * @return {?}
                     */
                    get: function () { return this._touchUi; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._touchUi = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "disabled", {
                    /**
                     * Whether the datepicker pop-up should be disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled === undefined && this._datepickerInput ?
                            this._datepickerInput.disabled : !!this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                        if (newValue !== this._disabled) {
                            this._disabled = newValue;
                            this._disabledChange.next(newValue);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "opened", {
                    /**
                     * Whether the calendar is open.
                     * @return {?}
                     */
                    get: function () { return this._opened; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { value ? this.open() : this.close(); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_selected", {
                    /**
                     * The currently selected date.
                     * @return {?}
                     */
                    get: function () { return this._validSelected; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._validSelected = value; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_minDate", {
                    /**
                     * The minimum selectable date.
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput.min;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_maxDate", {
                    /**
                     * The maximum selectable date.
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput.max;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepicker.prototype, "_dateFilter", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._datepickerInput && this._datepickerInput._dateFilter;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatDatepicker.prototype.ngOnDestroy = function () {
                    this.close();
                    this._inputSubscription.unsubscribe();
                    this._disabledChange.complete();
                    if (this._popupRef) {
                        this._popupRef.dispose();
                        this._popupComponentRef = null;
                    }
                };
                /**
                 * Selects the given date
                 * @param {?} date
                 * @return {?}
                 */
                MatDatepicker.prototype.select = function (date) {
                    /** @type {?} */
                    var oldValue = this._selected;
                    this._selected = date;
                    if (!this._dateAdapter.sameDate(oldValue, this._selected)) {
                        this._selectedChanged.next(date);
                    }
                };
                /**
                 * Emits the selected year in multiyear view
                 * @param {?} normalizedYear
                 * @return {?}
                 */
                MatDatepicker.prototype._selectYear = function (normalizedYear) {
                    this.yearSelected.emit(normalizedYear);
                };
                /**
                 * Emits selected month in year view
                 * @param {?} normalizedMonth
                 * @return {?}
                 */
                MatDatepicker.prototype._selectMonth = function (normalizedMonth) {
                    this.monthSelected.emit(normalizedMonth);
                };
                /**
                 * Register an input with this datepicker.
                 * @param {?} input The datepicker input to register with this datepicker.
                 * @return {?}
                 */
                MatDatepicker.prototype._registerInput = function (input) {
                    var _this = this;
                    if (this._datepickerInput) {
                        throw Error('A MatDatepicker can only be associated with a single input.');
                    }
                    this._datepickerInput = input;
                    this._inputSubscription =
                        this._datepickerInput._valueChange.subscribe(( /**
                         * @param {?} value
                         * @return {?}
                         */function (value) { return _this._selected = value; }));
                };
                /**
                 * Open the calendar.
                 * @return {?}
                 */
                MatDatepicker.prototype.open = function () {
                    if (this._opened || this.disabled) {
                        return;
                    }
                    if (!this._datepickerInput) {
                        throw Error('Attempted to open an MatDatepicker with no associated input.');
                    }
                    if (this._document) {
                        this._focusedElementBeforeOpen = this._document.activeElement;
                    }
                    this.touchUi ? this._openAsDialog() : this._openAsPopup();
                    this._opened = true;
                    this.openedStream.emit();
                };
                /**
                 * Close the calendar.
                 * @return {?}
                 */
                MatDatepicker.prototype.close = function () {
                    var _this = this;
                    if (!this._opened) {
                        return;
                    }
                    if (this._popupRef && this._popupRef.hasAttached()) {
                        this._popupRef.detach();
                    }
                    if (this._dialogRef) {
                        this._dialogRef.close();
                        this._dialogRef = null;
                    }
                    if (this._calendarPortal && this._calendarPortal.isAttached) {
                        this._calendarPortal.detach();
                    }
                    /** @type {?} */
                    var completeClose = ( /**
                     * @return {?}
                     */function () {
                        // The `_opened` could've been reset already if
                        // we got two events in quick succession.
                        if (_this._opened) {
                            _this._opened = false;
                            _this.closedStream.emit();
                            _this._focusedElementBeforeOpen = null;
                        }
                    });
                    if (this._focusedElementBeforeOpen &&
                        typeof this._focusedElementBeforeOpen.focus === 'function') {
                        // Because IE moves focus asynchronously, we can't count on it being restored before we've
                        // marked the datepicker as closed. If the event fires out of sequence and the element that
                        // we're refocusing opens the datepicker on focus, the user could be stuck with not being
                        // able to close the calendar at all. We work around it by making the logic, that marks
                        // the datepicker as closed, async as well.
                        this._focusedElementBeforeOpen.focus();
                        setTimeout(completeClose);
                    }
                    else {
                        completeClose();
                    }
                };
                /**
                 * Open the calendar as a dialog.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._openAsDialog = function () {
                    var _this = this;
                    // Usually this would be handled by `open` which ensures that we can only have one overlay
                    // open at a time, however since we reset the variables in async handlers some overlays
                    // may slip through if the user opens and closes multiple times in quick succession (e.g.
                    // by holding down the enter key).
                    if (this._dialogRef) {
                        this._dialogRef.close();
                    }
                    this._dialogRef = this._dialog.open(MatDatepickerContent, {
                        direction: this._dir ? this._dir.value : 'ltr',
                        viewContainerRef: this._viewContainerRef,
                        panelClass: 'mat-datepicker-dialog',
                    });
                    this._dialogRef.afterClosed().subscribe(( /**
                     * @return {?}
                     */function () { return _this.close(); }));
                    this._dialogRef.componentInstance.datepicker = this;
                    this._setColor();
                };
                /**
                 * Open the calendar as a popup.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._openAsPopup = function () {
                    var _this = this;
                    if (!this._calendarPortal) {
                        this._calendarPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["ComponentPortal"](MatDatepickerContent, this._viewContainerRef);
                    }
                    if (!this._popupRef) {
                        this._createPopup();
                    }
                    if (!this._popupRef.hasAttached()) {
                        this._popupComponentRef = this._popupRef.attach(this._calendarPortal);
                        this._popupComponentRef.instance.datepicker = this;
                        this._setColor();
                        // Update the position once the calendar has rendered.
                        this._ngZone.onStable.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._popupRef.updatePosition();
                        }));
                    }
                };
                /**
                 * Create the popup.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._createPopup = function () {
                    var _this = this;
                    /** @type {?} */
                    var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayConfig"]({
                        positionStrategy: this._createPopupPositionStrategy(),
                        hasBackdrop: true,
                        backdropClass: 'mat-overlay-transparent-backdrop',
                        direction: this._dir,
                        scrollStrategy: this._scrollStrategy(),
                        panelClass: 'mat-datepicker-popup',
                    });
                    this._popupRef = this._overlay.create(overlayConfig);
                    this._popupRef.overlayElement.setAttribute('role', 'dialog');
                    Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this._popupRef.backdropClick(), this._popupRef.detachments(), this._popupRef.keydownEvents().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        // Closing on alt + up is only valid when there's an input associated with the datepicker.
                        return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["ESCAPE"] ||
                            (_this._datepickerInput && event.altKey && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]);
                    })))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (event) {
                            event.preventDefault();
                        }
                        _this.close();
                    }));
                };
                /**
                 * Create the popup PositionStrategy.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._createPopupPositionStrategy = function () {
                    return this._overlay.position()
                        .flexibleConnectedTo(this._datepickerInput.getConnectedOverlayOrigin())
                        .withTransformOriginOn('.mat-datepicker-content')
                        .withFlexibleDimensions(false)
                        .withViewportMargin(8)
                        .withLockedPosition()
                        .withPositions([
                        {
                            originX: 'start',
                            originY: 'bottom',
                            overlayX: 'start',
                            overlayY: 'top'
                        },
                        {
                            originX: 'start',
                            originY: 'top',
                            overlayX: 'start',
                            overlayY: 'bottom'
                        },
                        {
                            originX: 'end',
                            originY: 'bottom',
                            overlayX: 'end',
                            overlayY: 'top'
                        },
                        {
                            originX: 'end',
                            originY: 'top',
                            overlayX: 'end',
                            overlayY: 'bottom'
                        }
                    ]);
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatDatepicker.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                /**
                 * Passes the current theme color along to the calendar overlay.
                 * @private
                 * @return {?}
                 */
                MatDatepicker.prototype._setColor = function () {
                    /** @type {?} */
                    var color = this.color;
                    if (this._popupComponentRef) {
                        this._popupComponentRef.instance.color = color;
                    }
                    if (this._dialogRef) {
                        this._dialogRef.componentInstance.color = color;
                    }
                };
                return MatDatepicker;
            }());
            MatDatepicker.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker',
                            template: '',
                            exportAs: 'matDatepicker',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatDatepicker.ctorParameters = function () { return [
                { type: _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__["MatDialog"] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_DATEPICKER_SCROLL_STRATEGY,] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_10__["DOCUMENT"],] }] }
            ]; };
            MatDatepicker.propDecorators = {
                calendarHeaderComponent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startAt: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                startView: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                touchUi: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                yearSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                monthSelected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                panelClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                openedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"], args: ['opened',] }],
                closedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"], args: ['closed',] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_12__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatDatepickerInput; })),
                multi: true
            };
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DATEPICKER_VALIDATORS = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_12__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatDatepickerInput; })),
                multi: true
            };
            /**
             * An event used for datepicker input and change events. We don't always have access to a native
             * input or change event because the event may have been triggered by the user clicking on the
             * calendar popup. For consistency, we always use MatDatepickerInputEvent instead.
             * @template D
             */
            var MatDatepickerInputEvent = /** @class */ (function () {
                /**
                 * @param {?} target
                 * @param {?} targetElement
                 */
                function MatDatepickerInputEvent(target, targetElement) {
                    this.target = target;
                    this.targetElement = targetElement;
                    this.value = this.target.value;
                }
                return MatDatepickerInputEvent;
            }());
            /**
             * Directive used to connect an input to a MatDatepicker.
             * @template D
             */
            var MatDatepickerInput = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _dateAdapter
                 * @param {?} _dateFormats
                 * @param {?} _formField
                 */
                function MatDatepickerInput(_elementRef, _dateAdapter, _dateFormats, _formField) {
                    var _this = this;
                    this._elementRef = _elementRef;
                    this._dateAdapter = _dateAdapter;
                    this._dateFormats = _dateFormats;
                    this._formField = _formField;
                    /**
                     * Emits when a `change` event is fired on this `<input>`.
                     */
                    this.dateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when an `input` event is fired on this `<input>`.
                     */
                    this.dateInput = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the value changes (either due to user input or programmatic change).
                     */
                    this._valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Emits when the disabled state has changed
                     */
                    this._disabledChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    this._cvaOnChange = ( /**
                     * @return {?}
                     */function () { });
                    this._validatorOnChange = ( /**
                     * @return {?}
                     */function () { });
                    this._datepickerSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    this._localeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /**
                     * The form control validator for whether the input parses.
                     */
                    this._parseValidator = ( /**
                     * @return {?}
                     */function () {
                        return _this._lastValueValid ?
                            null : { 'matDatepickerParse': { 'text': _this._elementRef.nativeElement.value } };
                    });
                    /**
                     * The form control validator for the min date.
                     */
                    this._minValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                        return (!_this.min || !controlValue ||
                            _this._dateAdapter.compareDate(_this.min, controlValue) <= 0) ?
                            null : { 'matDatepickerMin': { 'min': _this.min, 'actual': controlValue } };
                    });
                    /**
                     * The form control validator for the max date.
                     */
                    this._maxValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                        return (!_this.max || !controlValue ||
                            _this._dateAdapter.compareDate(_this.max, controlValue) >= 0) ?
                            null : { 'matDatepickerMax': { 'max': _this.max, 'actual': controlValue } };
                    });
                    /**
                     * The form control validator for the date filter.
                     */
                    this._filterValidator = ( /**
                     * @param {?} control
                     * @return {?}
                     */function (control) {
                        /** @type {?} */
                        var controlValue = _this._getValidDateOrNull(_this._dateAdapter.deserialize(control.value));
                        return !_this._dateFilter || !controlValue || _this._dateFilter(controlValue) ?
                            null : { 'matDatepickerFilter': true };
                    });
                    /**
                     * The combined form control validator for this input.
                     */
                    this._validator = _angular_forms__WEBPACK_IMPORTED_MODULE_12__["Validators"].compose([this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator]);
                    /**
                     * Whether the last value set on the input was valid.
                     */
                    this._lastValueValid = false;
                    if (!this._dateAdapter) {
                        throw createMissingDateImplError('DateAdapter');
                    }
                    if (!this._dateFormats) {
                        throw createMissingDateImplError('MAT_DATE_FORMATS');
                    }
                    // Update the displayed date when the locale changes.
                    this._localeSubscription = _dateAdapter.localeChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this.value = _this.value;
                    }));
                }
                Object.defineProperty(MatDatepickerInput.prototype, "matDatepicker", {
                    /**
                     * The datepicker that this input is associated with.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        var _this = this;
                        if (!value) {
                            return;
                        }
                        this._datepicker = value;
                        this._datepicker._registerInput(this);
                        this._datepickerSubscription.unsubscribe();
                        this._datepickerSubscription = this._datepicker._selectedChanged.subscribe(( /**
                         * @param {?} selected
                         * @return {?}
                         */function (selected) {
                            _this.value = selected;
                            _this._cvaOnChange(selected);
                            _this._onTouched();
                            _this.dateInput.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                            _this.dateChange.emit(new MatDatepickerInputEvent(_this, _this._elementRef.nativeElement));
                        }));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "matDatepickerFilter", {
                    /**
                     * Function that can be used to filter out dates within the datepicker.
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._dateFilter = value;
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "value", {
                    /**
                     * The value of the input.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        value = this._dateAdapter.deserialize(value);
                        this._lastValueValid = !value || this._dateAdapter.isValid(value);
                        value = this._getValidDateOrNull(value);
                        /** @type {?} */
                        var oldDate = this.value;
                        this._value = value;
                        this._formatValue(value);
                        if (!this._dateAdapter.sameDate(oldDate, value)) {
                            this._valueChange.emit(value);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "min", {
                    /**
                     * The minimum valid date.
                     * @return {?}
                     */
                    get: function () { return this._min; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._min = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "max", {
                    /**
                     * The maximum valid date.
                     * @return {?}
                     */
                    get: function () { return this._max; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._max = this._getValidDateOrNull(this._dateAdapter.deserialize(value));
                        this._validatorOnChange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDatepickerInput.prototype, "disabled", {
                    /**
                     * Whether the datepicker-input is disabled.
                     * @return {?}
                     */
                    get: function () { return !!this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                        /** @type {?} */
                        var element = this._elementRef.nativeElement;
                        if (this._disabled !== newValue) {
                            this._disabled = newValue;
                            this._disabledChange.emit(newValue);
                        }
                        // We need to null check the `blur` method, because it's undefined during SSR.
                        if (newValue && element.blur) {
                            // Normally, native input elements automatically blur if they turn disabled. This behavior
                            // is problematic, because it would mean that it triggers another change detection cycle,
                            // which then causes a changed after checked error if the input element was focused before.
                            element.blur();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatDatepickerInput.prototype.ngOnDestroy = function () {
                    this._datepickerSubscription.unsubscribe();
                    this._localeSubscription.unsubscribe();
                    this._valueChange.complete();
                    this._disabledChange.complete();
                };
                /**
                 * \@docs-private
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnValidatorChange = function (fn) {
                    this._validatorOnChange = fn;
                };
                /**
                 * \@docs-private
                 * @param {?} c
                 * @return {?}
                 */
                MatDatepickerInput.prototype.validate = function (c) {
                    return this._validator ? this._validator(c) : null;
                };
                /**
                 * @deprecated
                 * \@breaking-change 8.0.0 Use `getConnectedOverlayOrigin` instead
                 * @return {?}
                 */
                MatDatepickerInput.prototype.getPopupConnectionElementRef = function () {
                    return this.getConnectedOverlayOrigin();
                };
                /**
                 * Gets the element that the datepicker popup should be connected to.
                 * @return {?} The element to connect the popup to.
                 */
                MatDatepickerInput.prototype.getConnectedOverlayOrigin = function () {
                    return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype.writeValue = function (value) {
                    this.value = value;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnChange = function (fn) {
                    this._cvaOnChange = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} fn
                 * @return {?}
                 */
                MatDatepickerInput.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                // Implemented as part of ControlValueAccessor.
                /**
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatDatepickerInput.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onKeydown = function (event) {
                    /** @type {?} */
                    var isAltDownArrow = event.altKey && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"];
                    if (this._datepicker && isAltDownArrow && !this._elementRef.nativeElement.readOnly) {
                        this._datepicker.open();
                        event.preventDefault();
                    }
                };
                /**
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onInput = function (value) {
                    /** @type {?} */
                    var date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);
                    this._lastValueValid = !date || this._dateAdapter.isValid(date);
                    date = this._getValidDateOrNull(date);
                    if (!this._dateAdapter.sameDate(date, this._value)) {
                        this._value = date;
                        this._cvaOnChange(date);
                        this._valueChange.emit(date);
                        this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
                    }
                    else {
                        this._validatorOnChange();
                    }
                };
                /**
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onChange = function () {
                    this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));
                };
                /**
                 * Returns the palette used by the input's form field, if any.
                 * @return {?}
                 */
                MatDatepickerInput.prototype._getThemePalette = function () {
                    return this._formField ? this._formField.color : undefined;
                };
                /**
                 * Handles blur events on the input.
                 * @return {?}
                 */
                MatDatepickerInput.prototype._onBlur = function () {
                    // Reformat the input only if we have a valid value.
                    if (this.value) {
                        this._formatValue(this.value);
                    }
                    this._onTouched();
                };
                /**
                 * Formats a value and sets it on the input element.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatDatepickerInput.prototype._formatValue = function (value) {
                    this._elementRef.nativeElement.value =
                        value ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';
                };
                /**
                 * @private
                 * @param {?} obj The object to check.
                 * @return {?} The given object if it is both a date instance and valid, otherwise null.
                 */
                MatDatepickerInput.prototype._getValidDateOrNull = function (obj) {
                    return (this._dateAdapter.isDateInstance(obj) && this._dateAdapter.isValid(obj)) ? obj : null;
                };
                return MatDatepickerInput;
            }());
            MatDatepickerInput.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'input[matDatepicker]',
                            providers: [
                                MAT_DATEPICKER_VALUE_ACCESSOR,
                                MAT_DATEPICKER_VALIDATORS,
                                { provide: _angular_material_input__WEBPACK_IMPORTED_MODULE_14__["MAT_INPUT_VALUE_ACCESSOR"], useExisting: MatDatepickerInput },
                            ],
                            host: {
                                '[attr.aria-haspopup]': '_datepicker ? "dialog" : null',
                                '[attr.aria-owns]': '(_datepicker?.opened && _datepicker.id) || null',
                                '[attr.min]': 'min ? _dateAdapter.toIso8601(min) : null',
                                '[attr.max]': 'max ? _dateAdapter.toIso8601(max) : null',
                                '[disabled]': 'disabled',
                                '(input)': '_onInput($event.target.value)',
                                '(change)': '_onChange()',
                                '(blur)': '_onBlur()',
                                '(keydown)': '_onKeydown($event)',
                            },
                            exportAs: 'matDatepickerInput',
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerInput.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_4__["DateAdapter"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_4__["MAT_DATE_FORMATS"],] }] },
                { type: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatFormField"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatDatepickerInput.propDecorators = {
                matDatepicker: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                matDatepickerFilter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                min: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                dateChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                dateInput: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Can be used to override the icon of a `matDatepickerToggle`.
             */
            var MatDatepickerToggleIcon = /** @class */ (function () {
                function MatDatepickerToggleIcon() {
                }
                return MatDatepickerToggleIcon;
            }());
            MatDatepickerToggleIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matDatepickerToggleIcon]'
                        },] },
            ];
            /**
             * @template D
             */
            var MatDatepickerToggle = /** @class */ (function () {
                /**
                 * @param {?} _intl
                 * @param {?} _changeDetectorRef
                 * @param {?} defaultTabIndex
                 */
                function MatDatepickerToggle(_intl, _changeDetectorRef, defaultTabIndex) {
                    this._intl = _intl;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._stateChanges = rxjs__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
                    /** @type {?} */
                    var parsedTabIndex = Number(defaultTabIndex);
                    this.tabIndex = (parsedTabIndex || parsedTabIndex === 0) ? parsedTabIndex : null;
                }
                Object.defineProperty(MatDatepickerToggle.prototype, "disabled", {
                    /**
                     * Whether the toggle button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        if (this._disabled === undefined && this.datepicker) {
                            return this.datepicker.disabled;
                        }
                        return !!this._disabled;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngOnChanges = function (changes) {
                    if (changes['datepicker']) {
                        this._watchStateChanges();
                    }
                };
                /**
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngOnDestroy = function () {
                    this._stateChanges.unsubscribe();
                };
                /**
                 * @return {?}
                 */
                MatDatepickerToggle.prototype.ngAfterContentInit = function () {
                    this._watchStateChanges();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDatepickerToggle.prototype._open = function (event) {
                    if (this.datepicker && !this.disabled) {
                        this.datepicker.open();
                        event.stopPropagation();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatDatepickerToggle.prototype._watchStateChanges = function () {
                    var _this = this;
                    /** @type {?} */
                    var datepickerDisabled = this.datepicker ? this.datepicker._disabledChange : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    /** @type {?} */
                    var inputDisabled = this.datepicker && this.datepicker._datepickerInput ?
                        this.datepicker._datepickerInput._disabledChange : Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    /** @type {?} */
                    var datepickerToggled = this.datepicker ?
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this.datepicker.openedStream, this.datepicker.closedStream) :
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["of"])();
                    this._stateChanges.unsubscribe();
                    this._stateChanges = Object(rxjs__WEBPACK_IMPORTED_MODULE_1__["merge"])(this._intl.changes, datepickerDisabled, inputDisabled, datepickerToggled).subscribe(( /**
                     * @return {?}
                     */function () { return _this._changeDetectorRef.markForCheck(); }));
                };
                return MatDatepickerToggle;
            }());
            MatDatepickerToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-datepicker-toggle',
                            template: "<button #button mat-icon-button type=\"button\" [attr.aria-haspopup]=\"datepicker ? 'dialog' : null\" [attr.aria-label]=\"_intl.openCalendarLabel\" [attr.tabindex]=\"disabled ? -1 : tabIndex\" [disabled]=\"disabled\" [disableRipple]=\"disableRipple\" (click)=\"_open($event)\"><svg *ngIf=\"!_customIcon\" class=\"mat-datepicker-toggle-default-icon\" viewBox=\"0 0 24 24\" width=\"24px\" height=\"24px\" fill=\"currentColor\" focusable=\"false\"><path d=\"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"/></svg><ng-content select=\"[matDatepickerToggleIcon]\"></ng-content></button>",
                            styles: [".mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}"],
                            host: {
                                'class': 'mat-datepicker-toggle',
                                // Always set the tabindex to -1 so that it doesn't overlap with any custom tabindex the
                                // consumer may have provided, while still being able to receive focus.
                                '[attr.tabindex]': '-1',
                                '[class.mat-datepicker-toggle-active]': 'datepicker && datepicker.opened',
                                '[class.mat-accent]': 'datepicker && datepicker.color === "accent"',
                                '[class.mat-warn]': 'datepicker && datepicker.color === "warn"',
                                '(focus)': '_button.focus()',
                            },
                            exportAs: 'matDatepickerToggle',
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatDatepickerToggle.ctorParameters = function () { return [
                { type: MatDatepickerIntl },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] }
            ]; };
            MatDatepickerToggle.propDecorators = {
                datepicker: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['for',] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                _customIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatDatepickerToggleIcon, { static: false },] }],
                _button: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['button', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatDatepickerModule = /** @class */ (function () {
                function MatDatepickerModule() {
                }
                return MatDatepickerModule;
            }());
            MatDatepickerModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_10__["CommonModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_15__["MatButtonModule"],
                                _angular_material_dialog__WEBPACK_IMPORTED_MODULE_11__["MatDialogModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayModule"],
                                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_16__["A11yModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_6__["PortalModule"],
                            ],
                            exports: [
                                MatCalendar,
                                MatCalendarBody,
                                MatDatepicker,
                                MatDatepickerContent,
                                MatDatepickerInput,
                                MatDatepickerToggle,
                                MatDatepickerToggleIcon,
                                MatMonthView,
                                MatYearView,
                                MatMultiYearView,
                                MatCalendarHeader,
                            ],
                            declarations: [
                                MatCalendar,
                                MatCalendarBody,
                                MatDatepicker,
                                MatDatepickerContent,
                                MatDatepickerInput,
                                MatDatepickerToggle,
                                MatDatepickerToggleIcon,
                                MatMonthView,
                                MatYearView,
                                MatMultiYearView,
                                MatCalendarHeader,
                            ],
                            providers: [
                                MatDatepickerIntl,
                                MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER,
                            ],
                            entryComponents: [
                                MatDatepickerContent,
                                MatCalendarHeader,
                            ]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=datepicker.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/dialog.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/dialog.js ***!
          \**********************************************************/
        /*! exports provided: MatDialogModule, MAT_DIALOG_SCROLL_STRATEGY_FACTORY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_DIALOG_DATA, MAT_DIALOG_DEFAULT_OPTIONS, MAT_DIALOG_SCROLL_STRATEGY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER, MatDialog, throwMatDialogContentAlreadyAttachedError, MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogContent, MatDialogActions, MatDialogConfig, MatDialogRef, matDialogAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogModule", function () { return MatDialogModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_FACTORY", function () { return MAT_DIALOG_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY", function () { return MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_DATA", function () { return MAT_DIALOG_DATA; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_DEFAULT_OPTIONS", function () { return MAT_DIALOG_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY", function () { return MAT_DIALOG_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER", function () { return MAT_DIALOG_SCROLL_STRATEGY_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialog", function () { return MatDialog; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwMatDialogContentAlreadyAttachedError", function () { return throwMatDialogContentAlreadyAttachedError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogContainer", function () { return MatDialogContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogClose", function () { return MatDialogClose; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogTitle", function () { return MatDialogTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogContent", function () { return MatDialogContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogActions", function () { return MatDialogActions; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogConfig", function () { return MatDialogConfig; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDialogRef", function () { return MatDialogRef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matDialogAnimations", function () { return matDialogAnimations; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Configuration for opening a modal dialog with the MatDialog service.
             * @template D
             */
            var MatDialogConfig = /** @class */ (function () {
                function MatDialogConfig() {
                    /**
                     * The ARIA role of the dialog element.
                     */
                    this.role = 'dialog';
                    /**
                     * Custom class for the overlay pane.
                     */
                    this.panelClass = '';
                    /**
                     * Whether the dialog has a backdrop.
                     */
                    this.hasBackdrop = true;
                    /**
                     * Custom class for the backdrop.
                     */
                    this.backdropClass = '';
                    /**
                     * Whether the user can use escape or clicking on the backdrop to close the modal.
                     */
                    this.disableClose = false;
                    /**
                     * Width of the dialog.
                     */
                    this.width = '';
                    /**
                     * Height of the dialog.
                     */
                    this.height = '';
                    /**
                     * Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw.
                     */
                    this.maxWidth = '80vw';
                    /**
                     * Data being injected into the child component.
                     */
                    this.data = null;
                    /**
                     * ID of the element that describes the dialog.
                     */
                    this.ariaDescribedBy = null;
                    /**
                     * ID of the element that labels the dialog.
                     */
                    this.ariaLabelledBy = null;
                    /**
                     * Aria label to assign to the dialog element.
                     */
                    this.ariaLabel = null;
                    /**
                     * Whether the dialog should focus the first focusable element on open.
                     */
                    this.autoFocus = true;
                    /**
                     * Whether the dialog should restore focus to the
                     * previously-focused element, after it's closed.
                     */
                    this.restoreFocus = true;
                    /**
                     * Whether the dialog should close when the user goes backwards/forwards in history.
                     * Note that this usually doesn't include clicking on links (unless the user is using
                     * the `HashLocationStrategy`).
                     */
                    this.closeOnNavigation = true;
                    // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.
                }
                return MatDialogConfig;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var animationBody = [
                // Note: The `enter` animation transitions to `transform: none`, because for some reason
                // specifying the transform explicitly, causes IE both to blur the dialog content and
                // decimate the animation performance. Leaving it as `none` solves both issues.
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('void, exit', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0, transform: 'scale(0.7)' })),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'none' })),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('150ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'none', opacity: 1 }))),
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void, * => exit', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 }))),
            ];
            /**
             * Animations used by MatDialog.
             * \@docs-private
             * @type {?}
             */
            var matDialogAnimations = {
                /**
                 * Animation that is applied on the dialog container by defalt.
                 */
                dialogContainer: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('dialogContainer', animationBody),
                /**
                 * @deprecated \@breaking-change 8.0.0 Use `matDialogAnimations.dialogContainer` instead.
                 */
                slideDialog: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('slideDialog', animationBody)
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Throws an exception for the case when a ComponentPortal is
             * attached to a DomPortalOutlet without an origin.
             * \@docs-private
             * @return {?}
             */
            function throwMatDialogContentAlreadyAttachedError() {
                throw Error('Attempting to attach dialog content after content is already attached');
            }
            /**
             * Internal component that wraps user-provided dialog content.
             * Animation is based on https://material.io/guidelines/motion/choreography.html.
             * \@docs-private
             */
            var MatDialogContainer = /** @class */ (function (_super) {
                __extends(MatDialogContainer, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _focusTrapFactory
                 * @param {?} _changeDetectorRef
                 * @param {?} _document
                 * @param {?} _config
                 */
                function MatDialogContainer(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, _config) {
                    var _this = _super.call(this) || this;
                    _this._elementRef = _elementRef;
                    _this._focusTrapFactory = _focusTrapFactory;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._document = _document;
                    _this._config = _config;
                    /**
                     * Element that was focused before the dialog was opened. Save this to restore upon close.
                     */
                    _this._elementFocusedBeforeDialogWasOpened = null;
                    /**
                     * State of the dialog animation.
                     */
                    _this._state = 'enter';
                    /**
                     * Emits when an animation state changes.
                     */
                    _this._animationStateChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    _this._ariaLabelledBy = _config.ariaLabelledBy || null;
                    return _this;
                }
                /**
                 * Attach a ComponentPortal as content to this dialog container.
                 * @template T
                 * @param {?} portal Portal to be attached as the dialog content.
                 * @return {?}
                 */
                MatDialogContainer.prototype.attachComponentPortal = function (portal) {
                    if (this._portalOutlet.hasAttached()) {
                        throwMatDialogContentAlreadyAttachedError();
                    }
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachComponentPortal(portal);
                };
                /**
                 * Attach a TemplatePortal as content to this dialog container.
                 * @template C
                 * @param {?} portal Portal to be attached as the dialog content.
                 * @return {?}
                 */
                MatDialogContainer.prototype.attachTemplatePortal = function (portal) {
                    if (this._portalOutlet.hasAttached()) {
                        throwMatDialogContentAlreadyAttachedError();
                    }
                    this._savePreviouslyFocusedElement();
                    return this._portalOutlet.attachTemplatePortal(portal);
                };
                /**
                 * Moves the focus inside the focus trap.
                 * @private
                 * @return {?}
                 */
                MatDialogContainer.prototype._trapFocus = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    if (!this._focusTrap) {
                        this._focusTrap = this._focusTrapFactory.create(element);
                    }
                    // If we were to attempt to focus immediately, then the content of the dialog would not yet be
                    // ready in instances where change detection has to run first. To deal with this, we simply
                    // wait for the microtask queue to be empty.
                    if (this._config.autoFocus) {
                        this._focusTrap.focusInitialElementWhenReady();
                    }
                    else {
                        /** @type {?} */
                        var activeElement = this._document.activeElement;
                        // Otherwise ensure that focus is on the dialog container. It's possible that a different
                        // component tried to move focus while the open animation was running. See:
                        // https://github.com/angular/components/issues/16215. Note that we only want to do this
                        // if the focus isn't inside the dialog already, because it's possible that the consumer
                        // turned off `autoFocus` in order to move focus themselves.
                        if (activeElement !== element && !element.contains(activeElement)) {
                            element.focus();
                        }
                    }
                };
                /**
                 * Restores focus to the element that was focused before the dialog opened.
                 * @private
                 * @return {?}
                 */
                MatDialogContainer.prototype._restoreFocus = function () {
                    /** @type {?} */
                    var toFocus = this._elementFocusedBeforeDialogWasOpened;
                    // We need the extra check, because IE can set the `activeElement` to null in some cases.
                    if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
                        toFocus.focus();
                    }
                    if (this._focusTrap) {
                        this._focusTrap.destroy();
                    }
                };
                /**
                 * Saves a reference to the element that was focused before the dialog was opened.
                 * @private
                 * @return {?}
                 */
                MatDialogContainer.prototype._savePreviouslyFocusedElement = function () {
                    var _this = this;
                    if (this._document) {
                        this._elementFocusedBeforeDialogWasOpened = ( /** @type {?} */(this._document.activeElement));
                        // Note that there is no focus method when rendering on the server.
                        if (this._elementRef.nativeElement.focus) {
                            // Move focus onto the dialog immediately in order to prevent the user from accidentally
                            // opening multiple dialogs at the same time. Needs to be async, because the element
                            // may not be focusable immediately.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () { return _this._elementRef.nativeElement.focus(); }));
                        }
                    }
                };
                /**
                 * Callback, invoked whenever an animation on the host completes.
                 * @param {?} event
                 * @return {?}
                 */
                MatDialogContainer.prototype._onAnimationDone = function (event) {
                    if (event.toState === 'enter') {
                        this._trapFocus();
                    }
                    else if (event.toState === 'exit') {
                        this._restoreFocus();
                    }
                    this._animationStateChanged.emit(event);
                };
                /**
                 * Callback, invoked when an animation on the host starts.
                 * @param {?} event
                 * @return {?}
                 */
                MatDialogContainer.prototype._onAnimationStart = function (event) {
                    this._animationStateChanged.emit(event);
                };
                /**
                 * Starts the dialog exit animation.
                 * @return {?}
                 */
                MatDialogContainer.prototype._startExitAnimation = function () {
                    this._state = 'exit';
                    // Mark the container for check so it can react if the
                    // view container is using OnPush change detection.
                    this._changeDetectorRef.markForCheck();
                };
                return MatDialogContainer;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["BasePortalOutlet"]));
            MatDialogContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-dialog-container',
                            template: "<ng-template cdkPortalOutlet></ng-template>",
                            styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}@media (-ms-high-contrast:active){.mat-dialog-container{outline:solid 1px}}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base{margin-left:0;margin-right:8px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            animations: [matDialogAnimations.dialogContainer],
                            host: {
                                'class': 'mat-dialog-container',
                                'tabindex': '-1',
                                'aria-modal': 'true',
                                '[attr.id]': '_id',
                                '[attr.role]': '_config.role',
                                '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',
                                '[attr.aria-label]': '_config.ariaLabel',
                                '[attr.aria-describedby]': '_config.ariaDescribedBy || null',
                                '[@dialogContainer]': '_state',
                                '(@dialogContainer.start)': '_onAnimationStart($event)',
                                '(@dialogContainer.done)': '_onAnimationDone($event)',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatDialogContainer.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_4__["FocusTrapFactory"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: MatDialogConfig }
            ]; };
            MatDialogContainer.propDecorators = {
                _portalOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["CdkPortalOutlet"], { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO(jelbourn): resizing
            // Counter for unique dialog ids.
            /** @type {?} */
            var uniqueId = 0;
            /**
             * Reference to a dialog opened via the MatDialog service.
             * @template T, R
             */
            var MatDialogRef = /** @class */ (function () {
                /**
                 * @param {?} _overlayRef
                 * @param {?} _containerInstance
                 * @param {?=} _location
                 * @param {?=} id
                 */
                function MatDialogRef(_overlayRef, _containerInstance, 
                // @breaking-change 8.0.0 `_location` parameter to be removed.
                _location, id) {
                    var _this = this;
                    if (id === void 0) { id = "mat-dialog-" + uniqueId++; }
                    this._overlayRef = _overlayRef;
                    this._containerInstance = _containerInstance;
                    this.id = id;
                    /**
                     * Whether the user is allowed to close the dialog.
                     */
                    this.disableClose = this._containerInstance._config.disableClose;
                    /**
                     * Subject for notifying the user that the dialog has finished opening.
                     */
                    this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Subject for notifying the user that the dialog has finished closing.
                     */
                    this._afterClosed = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Subject for notifying the user that the dialog has started closing.
                     */
                    this._beforeClosed = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    /**
                     * Current state of the dialog.
                     */
                    this._state = 0 /* OPEN */;
                    // Pass the id along to the container.
                    _containerInstance._id = id;
                    // Emit when opening animation completes
                    _containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'done' && event.toState === 'enter'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["take"])(1))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._afterOpened.next();
                        _this._afterOpened.complete();
                    }));
                    // Dispose overlay when closing animation is complete
                    _containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'done' && event.toState === 'exit'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        clearTimeout(_this._closeFallbackTimeout);
                        _this._overlayRef.dispose();
                    }));
                    _overlayRef.detachments().subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._beforeClosed.next(_this._result);
                        _this._beforeClosed.complete();
                        _this._afterClosed.next(_this._result);
                        _this._afterClosed.complete();
                        _this.componentInstance = ( /** @type {?} */(null));
                        _this._overlayRef.dispose();
                    }));
                    _overlayRef.keydownEvents()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["ESCAPE"] && !_this.disableClose && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__["hasModifierKey"])(event);
                    })))
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        event.preventDefault();
                        _this.close();
                    }));
                }
                /**
                 * Close the dialog.
                 * @param {?=} dialogResult Optional result to return to the dialog opener.
                 * @return {?}
                 */
                MatDialogRef.prototype.close = function (dialogResult) {
                    var _this = this;
                    this._result = dialogResult;
                    // Transition the backdrop in parallel to the dialog.
                    this._containerInstance._animationStateChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) { return event.phaseName === 'start'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["take"])(1))
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (/**
                 * @param {?} event
                 * @return {?}
                 */ event) {
                        _this._beforeClosed.next(dialogResult);
                        _this._beforeClosed.complete();
                        _this._state = 2 /* CLOSED */;
                        _this._overlayRef.detachBackdrop();
                        // The logic that disposes of the overlay depends on the exit animation completing, however
                        // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
                        // timeout which will clean everything up if the animation hasn't fired within the specified
                        // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
                        // vast majority of cases the timeout will have been cleared before it has the chance to fire.
                        _this._closeFallbackTimeout = setTimeout(( /**
                         * @return {?}
                         */function () {
                            _this._overlayRef.dispose();
                        }), event.totalTime + 100);
                    }));
                    this._containerInstance._startExitAnimation();
                    this._state = 1 /* CLOSING */;
                };
                /**
                 * Gets an observable that is notified when the dialog is finished opening.
                 * @return {?}
                 */
                MatDialogRef.prototype.afterOpened = function () {
                    return this._afterOpened.asObservable();
                };
                /**
                 * Gets an observable that is notified when the dialog is finished closing.
                 * @return {?}
                 */
                MatDialogRef.prototype.afterClosed = function () {
                    return this._afterClosed.asObservable();
                };
                /**
                 * Gets an observable that is notified when the dialog has started closing.
                 * @return {?}
                 */
                MatDialogRef.prototype.beforeClosed = function () {
                    return this._beforeClosed.asObservable();
                };
                /**
                 * Gets an observable that emits when the overlay's backdrop has been clicked.
                 * @return {?}
                 */
                MatDialogRef.prototype.backdropClick = function () {
                    return this._overlayRef.backdropClick();
                };
                /**
                 * Gets an observable that emits when keydown events are targeted on the overlay.
                 * @return {?}
                 */
                MatDialogRef.prototype.keydownEvents = function () {
                    return this._overlayRef.keydownEvents();
                };
                /**
                 * Updates the dialog's position.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} position New dialog position.
                 * @return {THIS}
                 */
                MatDialogRef.prototype.updatePosition = function (position) {
                    /** @type {?} */
                    var strategy = ( /** @type {?} */(this))._getPositionStrategy();
                    if (position && (position.left || position.right)) {
                        position.left ? strategy.left(position.left) : strategy.right(position.right);
                    }
                    else {
                        strategy.centerHorizontally();
                    }
                    if (position && (position.top || position.bottom)) {
                        position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
                    }
                    else {
                        strategy.centerVertically();
                    }
                    ( /** @type {?} */(this))._overlayRef.updatePosition();
                    return ( /** @type {?} */(this));
                };
                /**
                 * Updates the dialog's width and height.
                 * @template THIS
                 * @this {THIS}
                 * @param {?=} width New width of the dialog.
                 * @param {?=} height New height of the dialog.
                 * @return {THIS}
                 */
                MatDialogRef.prototype.updateSize = function (width, height) {
                    if (width === void 0) { width = ''; }
                    if (height === void 0) { height = ''; }
                    ( /** @type {?} */(this))._getPositionStrategy().width(width).height(height);
                    ( /** @type {?} */(this))._overlayRef.updatePosition();
                    return ( /** @type {?} */(this));
                };
                /**
                 * Add a CSS class or an array of classes to the overlay pane.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} classes
                 * @return {THIS}
                 */
                MatDialogRef.prototype.addPanelClass = function (classes) {
                    ( /** @type {?} */(this))._overlayRef.addPanelClass(classes);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Remove a CSS class or an array of classes from the overlay pane.
                 * @template THIS
                 * @this {THIS}
                 * @param {?} classes
                 * @return {THIS}
                 */
                MatDialogRef.prototype.removePanelClass = function (classes) {
                    ( /** @type {?} */(this))._overlayRef.removePanelClass(classes);
                    return ( /** @type {?} */(this));
                };
                /**
                 * Gets an observable that is notified when the dialog is finished opening.
                 * @deprecated Use `afterOpened` instead.
                 * \@breaking-change 8.0.0
                 * @return {?}
                 */
                MatDialogRef.prototype.afterOpen = function () {
                    return this.afterOpened();
                };
                /**
                 * Gets an observable that is notified when the dialog has started closing.
                 * @deprecated Use `beforeClosed` instead.
                 * \@breaking-change 8.0.0
                 * @return {?}
                 */
                MatDialogRef.prototype.beforeClose = function () {
                    return this.beforeClosed();
                };
                /**
                 * Gets the current state of the dialog's lifecycle.
                 * @return {?}
                 */
                MatDialogRef.prototype.getState = function () {
                    return this._state;
                };
                /**
                 * Fetches the position strategy object from the overlay ref.
                 * @private
                 * @return {?}
                 */
                MatDialogRef.prototype._getPositionStrategy = function () {
                    return ( /** @type {?} */(this._overlayRef.getConfig().positionStrategy));
                };
                return MatDialogRef;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to access the data that was passed in to a dialog.
             * @type {?}
             */
            var MAT_DIALOG_DATA = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('MatDialogData');
            /**
             * Injection token that can be used to specify default dialog options.
             * @type {?}
             */
            var MAT_DIALOG_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('mat-dialog-default-options');
            /**
             * Injection token that determines the scroll handling while the dialog is open.
             * @type {?}
             */
            var MAT_DIALOG_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('mat-dialog-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_DIALOG_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.block(); });
            }
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.block(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_DIALOG_SCROLL_STRATEGY_PROVIDER = {
                provide: MAT_DIALOG_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"]],
                useFactory: MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,
            };
            /**
             * Service to open Material Design modal dialogs.
             */
            var MatDialog = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _injector
                 * @param {?} _location
                 * @param {?} _defaultOptions
                 * @param {?} scrollStrategy
                 * @param {?} _parentDialog
                 * @param {?} _overlayContainer
                 */
                function MatDialog(_overlay, _injector, _location, _defaultOptions, scrollStrategy, _parentDialog, _overlayContainer) {
                    var _this = this;
                    this._overlay = _overlay;
                    this._injector = _injector;
                    this._location = _location;
                    this._defaultOptions = _defaultOptions;
                    this._parentDialog = _parentDialog;
                    this._overlayContainer = _overlayContainer;
                    this._openDialogsAtThisLevel = [];
                    this._afterAllClosedAtThisLevel = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    this._afterOpenedAtThisLevel = new rxjs__WEBPACK_IMPORTED_MODULE_6__["Subject"]();
                    this._ariaHiddenElements = new Map();
                    // TODO (jelbourn): tighten the typing right-hand side of this expression.
                    /**
                     * Stream that emits when all open dialog have finished closing.
                     * Will emit on subscribe if there are no open dialogs to begin with.
                     */
                    this.afterAllClosed = ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["defer"])(( /**
                     * @return {?}
                     */function () { return _this.openDialogs.length ?
                        _this._afterAllClosed :
                        _this._afterAllClosed.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["startWith"])(undefined)); }))));
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatDialog.prototype, "openDialogs", {
                    /**
                     * Keeps track of the currently-open dialogs.
                     * @return {?}
                     */
                    get: function () {
                        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDialog.prototype, "afterOpened", {
                    /**
                     * Stream that emits when a dialog has been opened.
                     * @return {?}
                     */
                    get: function () {
                        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDialog.prototype, "afterOpen", {
                    /**
                     * Stream that emits when a dialog has been opened.
                     * @deprecated Use `afterOpened` instead.
                     * \@breaking-change 8.0.0
                     * @return {?}
                     */
                    get: function () {
                        return this.afterOpened;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDialog.prototype, "_afterAllClosed", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var parent = this._parentDialog;
                        return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Opens a modal dialog containing the given component.
                 * @template T, D, R
                 * @param {?} componentOrTemplateRef Type of the component to load into the dialog,
                 *     or a TemplateRef to instantiate as the dialog content.
                 * @param {?=} config Extra configuration options.
                 * @return {?} Reference to the newly-opened dialog.
                 */
                MatDialog.prototype.open = function (componentOrTemplateRef, config) {
                    var _this = this;
                    config = _applyConfigDefaults(config, this._defaultOptions || new MatDialogConfig());
                    if (config.id && this.getDialogById(config.id)) {
                        throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
                    }
                    /** @type {?} */
                    var overlayRef = this._createOverlay(config);
                    /** @type {?} */
                    var dialogContainer = this._attachDialogContainer(overlayRef, config);
                    /** @type {?} */
                    var dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);
                    // If this is the first dialog that we're opening, hide all the non-overlay content.
                    if (!this.openDialogs.length) {
                        this._hideNonDialogContentFromAssistiveTechnology();
                    }
                    this.openDialogs.push(dialogRef);
                    dialogRef.afterClosed().subscribe(( /**
                     * @return {?}
                     */function () { return _this._removeOpenDialog(dialogRef); }));
                    this.afterOpened.next(dialogRef);
                    return dialogRef;
                };
                /**
                 * Closes all of the currently-open dialogs.
                 * @return {?}
                 */
                MatDialog.prototype.closeAll = function () {
                    this._closeDialogs(this.openDialogs);
                };
                /**
                 * Finds an open dialog by its id.
                 * @param {?} id ID to use when looking up the dialog.
                 * @return {?}
                 */
                MatDialog.prototype.getDialogById = function (id) {
                    return this.openDialogs.find(( /**
                     * @param {?} dialog
                     * @return {?}
                     */function (/**
                     * @param {?} dialog
                     * @return {?}
                     */ dialog) { return dialog.id === id; }));
                };
                /**
                 * @return {?}
                 */
                MatDialog.prototype.ngOnDestroy = function () {
                    // Only close the dialogs at this level on destroy
                    // since the parent service may still be active.
                    this._closeDialogs(this._openDialogsAtThisLevel);
                    this._afterAllClosedAtThisLevel.complete();
                    this._afterOpenedAtThisLevel.complete();
                };
                /**
                 * Creates the overlay into which the dialog will be loaded.
                 * @private
                 * @param {?} config The dialog configuration.
                 * @return {?} A promise resolving to the OverlayRef for the created overlay.
                 */
                MatDialog.prototype._createOverlay = function (config) {
                    /** @type {?} */
                    var overlayConfig = this._getOverlayConfig(config);
                    return this._overlay.create(overlayConfig);
                };
                /**
                 * Creates an overlay config from a dialog config.
                 * @private
                 * @param {?} dialogConfig The dialog configuration.
                 * @return {?} The overlay configuration.
                 */
                MatDialog.prototype._getOverlayConfig = function (dialogConfig) {
                    /** @type {?} */
                    var state$$1 = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayConfig"]({
                        positionStrategy: this._overlay.position().global(),
                        scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),
                        panelClass: dialogConfig.panelClass,
                        hasBackdrop: dialogConfig.hasBackdrop,
                        direction: dialogConfig.direction,
                        minWidth: dialogConfig.minWidth,
                        minHeight: dialogConfig.minHeight,
                        maxWidth: dialogConfig.maxWidth,
                        maxHeight: dialogConfig.maxHeight,
                        disposeOnNavigation: dialogConfig.closeOnNavigation
                    });
                    if (dialogConfig.backdropClass) {
                        state$$1.backdropClass = dialogConfig.backdropClass;
                    }
                    return state$$1;
                };
                /**
                 * Attaches an MatDialogContainer to a dialog's already-created overlay.
                 * @private
                 * @param {?} overlay Reference to the dialog's underlying overlay.
                 * @param {?} config The dialog configuration.
                 * @return {?} A promise resolving to a ComponentRef for the attached container.
                 */
                MatDialog.prototype._attachDialogContainer = function (overlay, config) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injector = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatDialogConfig, config]
                    ]));
                    /** @type {?} */
                    var containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](MatDialogContainer, config.viewContainerRef, injector, config.componentFactoryResolver);
                    /** @type {?} */
                    var containerRef = overlay.attach(containerPortal);
                    return containerRef.instance;
                };
                /**
                 * Attaches the user-provided component to the already-created MatDialogContainer.
                 * @private
                 * @template T, R
                 * @param {?} componentOrTemplateRef The type of component being loaded into the dialog,
                 *     or a TemplateRef to instantiate as the content.
                 * @param {?} dialogContainer Reference to the wrapping MatDialogContainer.
                 * @param {?} overlayRef Reference to the overlay in which the dialog resides.
                 * @param {?} config The dialog configuration.
                 * @return {?} A promise resolving to the MatDialogRef that should be returned to the user.
                 */
                MatDialog.prototype._attachDialogContent = function (componentOrTemplateRef, dialogContainer, overlayRef, config) {
                    // Create a reference to the dialog we're creating in order to give the user a handle
                    // to modify and close it.
                    /** @type {?} */
                    var dialogRef = new MatDialogRef(overlayRef, dialogContainer, this._location, config.id);
                    // When the dialog backdrop is clicked, we want to close it.
                    if (config.hasBackdrop) {
                        overlayRef.backdropClick().subscribe(( /**
                         * @return {?}
                         */function () {
                            if (!dialogRef.disableClose) {
                                dialogRef.close();
                            }
                        }));
                    }
                    if (componentOrTemplateRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]) {
                        dialogContainer.attachTemplatePortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["TemplatePortal"](componentOrTemplateRef, ( /** @type {?} */(null)), ( /** @type {?} */({ $implicit: config.data, dialogRef: dialogRef }))));
                    }
                    else {
                        /** @type {?} */
                        var injector = this._createInjector(config, dialogRef, dialogContainer);
                        /** @type {?} */
                        var contentRef = dialogContainer.attachComponentPortal(new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](componentOrTemplateRef, undefined, injector));
                        dialogRef.componentInstance = contentRef.instance;
                    }
                    dialogRef
                        .updateSize(config.width, config.height)
                        .updatePosition(config.position);
                    return dialogRef;
                };
                /**
                 * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
                 * of a dialog to close itself and, optionally, to return a value.
                 * @private
                 * @template T
                 * @param {?} config Config object that is used to construct the dialog.
                 * @param {?} dialogRef Reference to the dialog.
                 * @param {?} dialogContainer
                 * @return {?} The custom injector that can be used inside the dialog.
                 */
                MatDialog.prototype._createInjector = function (config, dialogRef, dialogContainer) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    // The MatDialogContainer is injected in the portal as the MatDialogContainer and the dialog's
                    // content are created out of the same ViewContainerRef and as such, are siblings for injector
                    // purposes. To allow the hierarchy that is expected, the MatDialogContainer is explicitly
                    // added to the injection tokens.
                    /** @type {?} */
                    var injectionTokens = new WeakMap([
                        [MatDialogContainer, dialogContainer],
                        [MAT_DIALOG_DATA, config.data],
                        [MatDialogRef, dialogRef]
                    ]);
                    if (config.direction &&
                        (!userInjector || !userInjector.get(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_8__["Directionality"], null))) {
                        injectionTokens.set(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_8__["Directionality"], {
                            value: config.direction,
                            change: Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["of"])()
                        });
                    }
                    return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, injectionTokens);
                };
                /**
                 * Removes a dialog from the array of open dialogs.
                 * @private
                 * @param {?} dialogRef Dialog to be removed.
                 * @return {?}
                 */
                MatDialog.prototype._removeOpenDialog = function (dialogRef) {
                    /** @type {?} */
                    var index = this.openDialogs.indexOf(dialogRef);
                    if (index > -1) {
                        this.openDialogs.splice(index, 1);
                        // If all the dialogs were closed, remove/restore the `aria-hidden`
                        // to a the siblings and emit to the `afterAllClosed` stream.
                        if (!this.openDialogs.length) {
                            this._ariaHiddenElements.forEach(( /**
                             * @param {?} previousValue
                             * @param {?} element
                             * @return {?}
                             */function (previousValue, element) {
                                if (previousValue) {
                                    element.setAttribute('aria-hidden', previousValue);
                                }
                                else {
                                    element.removeAttribute('aria-hidden');
                                }
                            }));
                            this._ariaHiddenElements.clear();
                            this._afterAllClosed.next();
                        }
                    }
                };
                /**
                 * Hides all of the content that isn't an overlay from assistive technology.
                 * @private
                 * @return {?}
                 */
                MatDialog.prototype._hideNonDialogContentFromAssistiveTechnology = function () {
                    /** @type {?} */
                    var overlayContainer = this._overlayContainer.getContainerElement();
                    // Ensure that the overlay container is attached to the DOM.
                    if (overlayContainer.parentElement) {
                        /** @type {?} */
                        var siblings = overlayContainer.parentElement.children;
                        for (var i = siblings.length - 1; i > -1; i--) {
                            /** @type {?} */
                            var sibling = siblings[i];
                            if (sibling !== overlayContainer &&
                                sibling.nodeName !== 'SCRIPT' &&
                                sibling.nodeName !== 'STYLE' &&
                                !sibling.hasAttribute('aria-live')) {
                                this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                                sibling.setAttribute('aria-hidden', 'true');
                            }
                        }
                    }
                };
                /**
                 * Closes all of the dialogs in an array.
                 * @private
                 * @param {?} dialogs
                 * @return {?}
                 */
                MatDialog.prototype._closeDialogs = function (dialogs) {
                    /** @type {?} */
                    var i = dialogs.length;
                    while (i--) {
                        // The `_openDialogs` property isn't updated after close until the rxjs subscription
                        // runs on the next microtask, in addition to modifying the array as we're going
                        // through it. We loop through all of them and call close without assuming that
                        // they'll be removed from the list instantaneously.
                        dialogs[i].close();
                    }
                };
                return MatDialog;
            }());
            MatDialog.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"] },
            ];
            /** @nocollapse */
            MatDialog.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"] },
                { type: _angular_common__WEBPACK_IMPORTED_MODULE_2__["Location"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: MatDialogConfig, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_DIALOG_DEFAULT_OPTIONS,] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_DIALOG_SCROLL_STRATEGY,] }] },
                { type: MatDialog, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"] }] },
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayContainer"] }
            ]; };
            /**
             * Applies default options to the dialog config.
             * @param {?=} config Config to be modified.
             * @param {?=} defaultOptions Default options provided.
             * @return {?} The new configuration object.
             */
            function _applyConfigDefaults(config, defaultOptions) {
                return Object.assign({}, defaultOptions, config);
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Counter used to generate unique IDs for dialog elements.
             * @type {?}
             */
            var dialogElementUid = 0;
            /**
             * Button that will close the current dialog.
             */
            var MatDialogClose = /** @class */ (function () {
                /**
                 * @param {?} dialogRef
                 * @param {?} _elementRef
                 * @param {?} _dialog
                 */
                function MatDialogClose(dialogRef, _elementRef, _dialog) {
                    this.dialogRef = dialogRef;
                    this._elementRef = _elementRef;
                    this._dialog = _dialog;
                    /**
                     * Default to "button" to prevents accidental form submits.
                     */
                    this.type = 'button';
                }
                /**
                 * @return {?}
                 */
                MatDialogClose.prototype.ngOnInit = function () {
                    if (!this.dialogRef) {
                        // When this directive is included in a dialog via TemplateRef (rather than being
                        // in a Component), the DialogRef isn't available via injection because embedded
                        // views cannot be given a custom injector. Instead, we look up the DialogRef by
                        // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
                        // be resolved at constructor time.
                        this.dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatDialogClose.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];
                    if (proxiedChange) {
                        this.dialogResult = proxiedChange.currentValue;
                    }
                };
                return MatDialogClose;
            }());
            MatDialogClose.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[mat-dialog-close], [matDialogClose]',
                            exportAs: 'matDialogClose',
                            host: {
                                '(click)': 'dialogRef.close(dialogResult)',
                                '[attr.aria-label]': 'ariaLabel || null',
                                '[attr.type]': 'type',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatDialogClose.ctorParameters = function () { return [
                { type: MatDialogRef, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: MatDialog }
            ]; };
            MatDialogClose.propDecorators = {
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['aria-label',] }],
                type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                dialogResult: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['mat-dialog-close',] }],
                _matDialogClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matDialogClose',] }]
            };
            /**
             * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.
             */
            var MatDialogTitle = /** @class */ (function () {
                /**
                 * @param {?} _dialogRef
                 * @param {?} _elementRef
                 * @param {?} _dialog
                 */
                function MatDialogTitle(_dialogRef, _elementRef, _dialog) {
                    this._dialogRef = _dialogRef;
                    this._elementRef = _elementRef;
                    this._dialog = _dialog;
                    this.id = "mat-dialog-title-" + dialogElementUid++;
                }
                /**
                 * @return {?}
                 */
                MatDialogTitle.prototype.ngOnInit = function () {
                    var _this = this;
                    if (!this._dialogRef) {
                        this._dialogRef = ( /** @type {?} */(getClosestDialog(this._elementRef, this._dialog.openDialogs)));
                    }
                    if (this._dialogRef) {
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () {
                            /** @type {?} */
                            var container = _this._dialogRef._containerInstance;
                            if (container && !container._ariaLabelledBy) {
                                container._ariaLabelledBy = _this.id;
                            }
                        }));
                    }
                };
                return MatDialogTitle;
            }());
            MatDialogTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[mat-dialog-title], [matDialogTitle]',
                            exportAs: 'matDialogTitle',
                            host: {
                                'class': 'mat-dialog-title',
                                '[id]': 'id',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatDialogTitle.ctorParameters = function () { return [
                { type: MatDialogRef, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: MatDialog }
            ]; };
            MatDialogTitle.propDecorators = {
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * Scrollable content container of a dialog.
             */
            var MatDialogContent = /** @class */ (function () {
                function MatDialogContent() {
                }
                return MatDialogContent;
            }());
            MatDialogContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]",
                            host: { 'class': 'mat-dialog-content' }
                        },] },
            ];
            /**
             * Container for the bottom action buttons in a dialog.
             * Stays fixed to the bottom when scrolling.
             */
            var MatDialogActions = /** @class */ (function () {
                function MatDialogActions() {
                }
                return MatDialogActions;
            }());
            MatDialogActions.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]",
                            host: { 'class': 'mat-dialog-actions' }
                        },] },
            ];
            /**
             * Finds the closest MatDialogRef to an element by looking at the DOM.
             * @param {?} element Element relative to which to look for a dialog.
             * @param {?} openDialogs References to the currently-open dialogs.
             * @return {?}
             */
            function getClosestDialog(element, openDialogs) {
                /** @type {?} */
                var parent = element.nativeElement.parentElement;
                while (parent && !parent.classList.contains('mat-dialog-container')) {
                    parent = parent.parentElement;
                }
                return parent ? openDialogs.find(( /**
                 * @param {?} dialog
                 * @return {?}
                 */function (/**
                 * @param {?} dialog
                 * @return {?}
                 */ dialog) { return dialog.id === ( /** @type {?} */(parent)).id; })) : null;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatDialogModule = /** @class */ (function () {
                function MatDialogModule() {
                }
                return MatDialogModule;
            }());
            MatDialogModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_9__["OverlayModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatCommonModule"],
                            ],
                            exports: [
                                MatDialogContainer,
                                MatDialogClose,
                                MatDialogTitle,
                                MatDialogContent,
                                MatDialogActions,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_10__["MatCommonModule"],
                            ],
                            declarations: [
                                MatDialogContainer,
                                MatDialogClose,
                                MatDialogTitle,
                                MatDialogActions,
                                MatDialogContent,
                            ],
                            providers: [
                                MatDialog,
                                MAT_DIALOG_SCROLL_STRATEGY_PROVIDER,
                            ],
                            entryComponents: [MatDialogContainer],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=dialog.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/divider.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/divider.js ***!
          \***********************************************************/
        /*! exports provided: MatDivider, MatDividerModule */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDivider", function () { return MatDivider; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDividerModule", function () { return MatDividerModule; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatDivider = /** @class */ (function () {
                function MatDivider() {
                    this._vertical = false;
                    this._inset = false;
                }
                Object.defineProperty(MatDivider.prototype, "vertical", {
                    /**
                     * Whether the divider is vertically aligned.
                     * @return {?}
                     */
                    get: function () { return this._vertical; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._vertical = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDivider.prototype, "inset", {
                    /**
                     * Whether the divider is an inset divider.
                     * @return {?}
                     */
                    get: function () { return this._inset; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._inset = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                return MatDivider;
            }());
            MatDivider.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-divider',
                            host: {
                                'role': 'separator',
                                '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                                '[class.mat-divider-vertical]': 'vertical',
                                '[class.mat-divider-horizontal]': '!vertical',
                                '[class.mat-divider-inset]': 'inset',
                                'class': 'mat-divider'
                            },
                            template: '',
                            styles: [".mat-divider{display:block;margin:0;border-top-width:1px;border-top-style:solid}.mat-divider.mat-divider-vertical{border-top:0;border-right-width:1px;border-right-style:solid}.mat-divider.mat-divider-inset{margin-left:80px}[dir=rtl] .mat-divider.mat-divider-inset{margin-left:auto;margin-right:80px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            MatDivider.propDecorators = {
                vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                inset: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatDividerModule = /** @class */ (function () {
                function MatDividerModule() {
                }
                return MatDividerModule;
            }());
            MatDividerModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"], _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"]],
                            exports: [MatDivider, _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]],
                            declarations: [MatDivider],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=divider.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/expansion.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/expansion.js ***!
          \*************************************************************/
        /*! exports provided: MatExpansionModule, MatAccordion, MAT_ACCORDION, MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelDescription, MatExpansionPanelTitle, MatExpansionPanelContent, EXPANSION_PANEL_ANIMATION_TIMING, matExpansionAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionModule", function () { return MatExpansionModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatAccordion", function () { return MatAccordion; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_ACCORDION", function () { return MAT_ACCORDION; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_EXPANSION_PANEL_DEFAULT_OPTIONS", function () { return MAT_EXPANSION_PANEL_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanel", function () { return MatExpansionPanel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelActionRow", function () { return MatExpansionPanelActionRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelHeader", function () { return MatExpansionPanelHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelDescription", function () { return MatExpansionPanelDescription; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelTitle", function () { return MatExpansionPanelTitle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelContent", function () { return MatExpansionPanelContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXPANSION_PANEL_ANIMATION_TIMING", function () { return EXPANSION_PANEL_ANIMATION_TIMING; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matExpansionAnimations", function () { return matExpansionAnimations; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/accordion */ "./node_modules/@angular/cdk/esm2015/accordion.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Token used to provide a `MatAccordion` to `MatExpansionPanel`.
             * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.
             * @type {?}
             */
            var MAT_ACCORDION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_ACCORDION');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Time and timing curve for expansion panel animations.
             * @type {?}
             */
            var EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
            /**
             * Animations used by the Material expansion panel.
             *
             * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()
             * causes the animation state of moved components to become `void` upon exit, and not update again
             * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state
             * of the panel is `expanded` or `collapsed` but the animation state is `void`.
             *
             * To correctly handle animating to the next state, we animate between `void` and `collapsed` which
             * are defined to have the same styles. Since angular animates from the current styles to the
             * destination state's style definition, in situations where we are moving from `void`'s styles to
             * `collapsed` this acts a noop since no style values change.
             *
             * In the case where angular's animation state is out of sync with the expansion panel's state, the
             * expansion panel being `expanded` and angular animations being `void`, the animation from the
             * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will
             * occur as expected.
             *
             * Angular Bug: https://github.com/angular/angular/issues/18847
             *
             * \@docs-private
             * @type {?}
             */
            var matExpansionAnimations = {
                /**
                 * Animation that rotates the indicator arrow.
                 */
                indicatorRotate: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('indicatorRotate', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'rotate(0deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ transform: 'rotate(180deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING)),
                ]),
                /**
                 * Animation that expands and collapses the panel header height.
                 */
                expansionHeaderHeight: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('expansionHeight', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({
                        height: '{{collapsedHeight}}',
                    }), {
                        params: { collapsedHeight: '48px' },
                    }),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({
                        height: '{{expandedHeight}}'
                    }), {
                        params: { expandedHeight: '64px' }
                    }),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["group"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["query"])('@indicatorRotate', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animateChild"])(), { optional: true }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING),
                    ])),
                ]),
                /**
                 * Animation that expands and collapses the panel content.
                 */
                bodyExpansion: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["trigger"])('bodyExpansion', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('collapsed, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["state"])('expanded', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["style"])({ height: '*', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["transition"])('expanded <=> collapsed, void => collapsed', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_1__["animate"])(EXPANSION_PANEL_ANIMATION_TIMING)),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Expansion panel content that will be rendered lazily
             * after the panel is opened for the first time.
             */
            var MatExpansionPanelContent = /** @class */ (function () {
                /**
                 * @param {?} _template
                 */
                function MatExpansionPanelContent(_template) {
                    this._template = _template;
                }
                return MatExpansionPanelContent;
            }());
            MatExpansionPanelContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'ng-template[matExpansionPanelContent]'
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanelContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Counter for generating unique element ids.
             * @type {?}
             */
            var uniqueId = 0;
            /**
             * Injection token that can be used to configure the defalt
             * options for the expansion panel component.
             * @type {?}
             */
            var MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');
            var ɵ0 = undefined;
            /**
             * `<mat-expansion-panel>`
             *
             * This component can be used as a single element to show expandable content, or as one of
             * multiple children of an element with the MatAccordion directive attached.
             */
            var MatExpansionPanel = /** @class */ (function (_super) {
                __extends(MatExpansionPanel, _super);
                /**
                 * @param {?} accordion
                 * @param {?} _changeDetectorRef
                 * @param {?} _uniqueSelectionDispatcher
                 * @param {?} _viewContainerRef
                 * @param {?} _document
                 * @param {?} _animationMode
                 * @param {?=} defaultOptions
                 */
                function MatExpansionPanel(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {
                    var _this = _super.call(this, accordion, _changeDetectorRef, _uniqueSelectionDispatcher) || this;
                    _this._viewContainerRef = _viewContainerRef;
                    _this._animationMode = _animationMode;
                    _this._hideToggle = false;
                    /**
                     * An event emitted after the body's expansion animation happens.
                     */
                    _this.afterExpand = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event emitted after the body's collapse animation happens.
                     */
                    _this.afterCollapse = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Stream that emits for changes in `\@Input` properties.
                     */
                    _this._inputChanges = new rxjs__WEBPACK_IMPORTED_MODULE_8__["Subject"]();
                    /**
                     * ID for the associated header element. Used for a11y labelling.
                     */
                    _this._headerId = "mat-expansion-panel-header-" + uniqueId++;
                    /**
                     * Stream of body animation done events.
                     */
                    _this._bodyAnimationDone = new rxjs__WEBPACK_IMPORTED_MODULE_8__["Subject"]();
                    _this.accordion = accordion;
                    _this._document = _document;
                    // We need a Subject with distinctUntilChanged, because the `done` event
                    // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
                    _this._bodyAnimationDone.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) {
                        return x.fromState === y.fromState && x.toState === y.toState;
                    }))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if (event.fromState !== 'void') {
                            if (event.toState === 'expanded') {
                                _this.afterExpand.emit();
                            }
                            else if (event.toState === 'collapsed') {
                                _this.afterCollapse.emit();
                            }
                        }
                    }));
                    if (defaultOptions) {
                        _this.hideToggle = defaultOptions.hideToggle;
                    }
                    return _this;
                }
                Object.defineProperty(MatExpansionPanel.prototype, "hideToggle", {
                    /**
                     * Whether the toggle indicator should be hidden.
                     * @return {?}
                     */
                    get: function () {
                        return this._hideToggle || (this.accordion && this.accordion.hideToggle);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._hideToggle = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatExpansionPanel.prototype, "togglePosition", {
                    /**
                     * The position of the expansion indicator.
                     * @return {?}
                     */
                    get: function () {
                        return this._togglePosition || (this.accordion && this.accordion.togglePosition);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._togglePosition = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Determines whether the expansion panel should have spacing between it and its siblings.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._hasSpacing = function () {
                    if (this.accordion) {
                        // We don't need to subscribe to the `stateChanges` of the parent accordion because each time
                        // the [displayMode] input changes, the change detection will also cover the host bindings
                        // of this expansion panel.
                        return (this.expanded ? this.accordion.displayMode : this._getExpandedState()) === 'default';
                    }
                    return false;
                };
                /**
                 * Gets the expanded state string.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._getExpandedState = function () {
                    return this.expanded ? 'expanded' : 'collapsed';
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    if (this._lazyContent) {
                        // Render the content as soon as the panel becomes open.
                        this.opened.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["startWith"])(( /** @type {?} */(null))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @return {?}
                         */function () { return _this.expanded && !_this._portal; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["TemplatePortal"](_this._lazyContent._template, _this._viewContainerRef);
                        }));
                    }
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngOnChanges = function (changes) {
                    this._inputChanges.next(changes);
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanel.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                    this._bodyAnimationDone.complete();
                    this._inputChanges.complete();
                };
                /**
                 * Checks whether the expansion panel's content contains the currently-focused element.
                 * @return {?}
                 */
                MatExpansionPanel.prototype._containsFocus = function () {
                    if (this._body) {
                        /** @type {?} */
                        var focusedElement = this._document.activeElement;
                        /** @type {?} */
                        var bodyElement = this._body.nativeElement;
                        return focusedElement === bodyElement || bodyElement.contains(focusedElement);
                    }
                    return false;
                };
                return MatExpansionPanel;
            }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordionItem"]));
            MatExpansionPanel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(.4,0,.2,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}@media (-ms-high-contrast:active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel._mat-animation-noopable,.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}"],
                            selector: 'mat-expansion-panel',
                            exportAs: 'matExpansionPanel',
                            template: "<ng-content select=\"mat-expansion-panel-header\"></ng-content><div class=\"mat-expansion-panel-content\" role=\"region\" [@bodyExpansion]=\"_getExpandedState()\" (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\" [attr.aria-labelledby]=\"_headerId\" [id]=\"id\" #body><div class=\"mat-expansion-panel-body\"><ng-content></ng-content><ng-template [cdkPortalOutlet]=\"_portal\"></ng-template></div><ng-content select=\"mat-action-row\"></ng-content></div>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disabled', 'expanded'],
                            outputs: ['opened', 'closed', 'expandedChange'],
                            animations: [matExpansionAnimations.bodyExpansion],
                            providers: [
                                // Provide MatAccordion as undefined to prevent nested expansion panels from registering
                                // to the same accordion.
                                { provide: MAT_ACCORDION, useValue: ɵ0 },
                            ],
                            host: {
                                'class': 'mat-expansion-panel',
                                '[class.mat-expanded]': 'expanded',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '[class.mat-expansion-panel-spacing]': '_hasSpacing()',
                            }
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanel.ctorParameters = function () { return [
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_ACCORDION,] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_4__["UniqueSelectionDispatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["DOCUMENT"],] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatExpansionPanel.propDecorators = {
                hideToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                togglePosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                afterExpand: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                afterCollapse: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _lazyContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatExpansionPanelContent, { static: false },] }],
                _body: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['body', { static: false },] }]
            };
            var MatExpansionPanelActionRow = /** @class */ (function () {
                function MatExpansionPanelActionRow() {
                }
                return MatExpansionPanelActionRow;
            }());
            MatExpansionPanelActionRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-action-row',
                            host: {
                                class: 'mat-action-row'
                            }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * `<mat-expansion-panel-header>`
             *
             * This component corresponds to the header element of an `<mat-expansion-panel>`.
             */
            var MatExpansionPanelHeader = /** @class */ (function () {
                /**
                 * @param {?} panel
                 * @param {?} _element
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?=} defaultOptions
                 */
                function MatExpansionPanelHeader(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {
                    var _this = this;
                    this.panel = panel;
                    this._element = _element;
                    this._focusMonitor = _focusMonitor;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._parentChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__["Subscription"].EMPTY;
                    /**
                     * Whether Angular animations in the panel header should be disabled.
                     */
                    this._animationsDisabled = true;
                    /** @type {?} */
                    var accordionHideToggleChange = panel.accordion ?
                        panel.accordion._stateChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} changes
                         * @return {?}
                         */function (/**
                         * @param {?} changes
                         * @return {?}
                         */ changes) { return !!(changes['hideToggle'] || changes['togglePosition']); }))) :
                        rxjs__WEBPACK_IMPORTED_MODULE_8__["EMPTY"];
                    // Since the toggle state depends on an @Input on the panel, we
                    // need to subscribe and trigger change detection manually.
                    this._parentChangeSubscription =
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_8__["merge"])(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} changes
                         * @return {?}
                         */function (/**
                         * @param {?} changes
                         * @return {?}
                         */ changes) {
                            return !!(changes['hideToggle'] ||
                                changes['disabled'] ||
                                changes['togglePosition']);
                        }))))
                            .subscribe(( /**
                     * @return {?}
                     */function () { return _this._changeDetectorRef.markForCheck(); }));
                    // Avoids focus being lost if the panel contained the focused element and was closed.
                    panel.closed
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                 * @return {?}
                 */function () { return panel._containsFocus(); })))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _focusMonitor.focusVia(_element, 'program'); }));
                    _focusMonitor.monitor(_element).subscribe(( /**
                     * @param {?} origin
                     * @return {?}
                     */function (/**
                     * @param {?} origin
                     * @return {?}
                     */ origin) {
                        if (origin && panel.accordion) {
                            panel.accordion._handleHeaderFocus(_this);
                        }
                    }));
                    if (defaultOptions) {
                        this.expandedHeight = defaultOptions.expandedHeight;
                        this.collapsedHeight = defaultOptions.collapsedHeight;
                    }
                }
                /**
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._animationStarted = function () {
                    // Currently the `expansionHeight` animation has a `void => collapsed` transition which is
                    // there to work around a bug in Angular (see #13088), however this introduces a different
                    // issue. The new transition will cause the header to animate in on init (see #16067), if the
                    // consumer has set a header height that is different from the default one. We work around it
                    // by disabling animations on the header and re-enabling them after the first animation has run.
                    // Note that Angular dispatches animation events even if animations are disabled. Ideally this
                    // wouldn't be necessary if we remove the `void => collapsed` transition, but we have to wait
                    // for https://github.com/angular/angular/issues/18847 to be resolved.
                    this._animationsDisabled = false;
                };
                Object.defineProperty(MatExpansionPanelHeader.prototype, "disabled", {
                    /**
                     * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
                     * \@docs-private
                     * @return {?}
                     */
                    get: function () {
                        return this.panel.disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Toggles the expanded state of the panel.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._toggle = function () {
                    this.panel.toggle();
                };
                /**
                 * Gets whether the panel is expanded.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._isExpanded = function () {
                    return this.panel.expanded;
                };
                /**
                 * Gets the expanded state string of the panel.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getExpandedState = function () {
                    return this.panel._getExpandedState();
                };
                /**
                 * Gets the panel id.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getPanelId = function () {
                    return this.panel.id;
                };
                /**
                 * Gets the toggle position for the header.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._getTogglePosition = function () {
                    return this.panel.togglePosition;
                };
                /**
                 * Gets whether the expand indicator should be shown.
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._showToggle = function () {
                    return !this.panel.hideToggle && !this.panel.disabled;
                };
                /**
                 * Handle keydown event calling to toggle() if appropriate.
                 * @param {?} event
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype._keydown = function (event) {
                    switch (event.keyCode) {
                        // Toggle for space and enter keys.
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["SPACE"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["ENTER"]:
                            if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                                event.preventDefault();
                                this._toggle();
                            }
                            break;
                        default:
                            if (this.panel.accordion) {
                                this.panel.accordion._handleHeaderKeydown(event);
                            }
                            return;
                    }
                };
                /**
                 * Focuses the panel header. Implemented as a part of `FocusableOption`.
                 * \@docs-private
                 * @param {?=} origin Origin of the action that triggered the focus.
                 * @param {?=} options
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    this._focusMonitor.focusVia(this._element, origin, options);
                };
                /**
                 * @return {?}
                 */
                MatExpansionPanelHeader.prototype.ngOnDestroy = function () {
                    this._parentChangeSubscription.unsubscribe();
                    this._focusMonitor.stopMonitoring(this._element);
                };
                return MatExpansionPanelHeader;
            }());
            MatExpansionPanelHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-expansion-panel-header',
                            styles: [".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-description,.mat-expansion-panel-header-title{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-description,[dir=rtl] .mat-expansion-panel-header-title{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:'';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}"],
                            template: "<span class=\"mat-content\"><ng-content select=\"mat-panel-title\"></ng-content><ng-content select=\"mat-panel-description\"></ng-content><ng-content></ng-content></span><span [@indicatorRotate]=\"_getExpandedState()\" *ngIf=\"_showToggle()\" class=\"mat-expansion-indicator\"></span>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            animations: [
                                matExpansionAnimations.indicatorRotate,
                                matExpansionAnimations.expansionHeaderHeight
                            ],
                            host: {
                                'class': 'mat-expansion-panel-header',
                                'role': 'button',
                                '[attr.id]': 'panel._headerId',
                                '[attr.tabindex]': 'disabled ? -1 : 0',
                                '[attr.aria-controls]': '_getPanelId()',
                                '[attr.aria-expanded]': '_isExpanded()',
                                '[attr.aria-disabled]': 'panel.disabled',
                                '[class.mat-expanded]': '_isExpanded()',
                                '[class.mat-expansion-toggle-indicator-after]': "_getTogglePosition() === 'after'",
                                '[class.mat-expansion-toggle-indicator-before]': "_getTogglePosition() === 'before'",
                                '(click)': '_toggle()',
                                '(keydown)': '_keydown($event)',
                                '[@.disabled]': '_animationsDisabled',
                                '(@expansionHeight.start)': '_animationStarted()',
                                '[@expansionHeight]': "{\n        value: _getExpandedState(),\n        params: {\n          collapsedHeight: collapsedHeight,\n          expandedHeight: expandedHeight\n        }\n    }",
                            },
                        },] },
            ];
            /** @nocollapse */
            MatExpansionPanelHeader.ctorParameters = function () { return [
                { type: MatExpansionPanel, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Host"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatExpansionPanelHeader.propDecorators = {
                expandedHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                collapsedHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * `<mat-panel-description>`
             *
             * This directive is to be used inside of the MatExpansionPanelHeader component.
             */
            var MatExpansionPanelDescription = /** @class */ (function () {
                function MatExpansionPanelDescription() {
                }
                return MatExpansionPanelDescription;
            }());
            MatExpansionPanelDescription.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-panel-description',
                            host: {
                                class: 'mat-expansion-panel-header-description'
                            }
                        },] },
            ];
            /**
             * `<mat-panel-title>`
             *
             * This directive is to be used inside of the MatExpansionPanelHeader component.
             */
            var MatExpansionPanelTitle = /** @class */ (function () {
                function MatExpansionPanelTitle() {
                }
                return MatExpansionPanelTitle;
            }());
            MatExpansionPanelTitle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-panel-title',
                            host: {
                                class: 'mat-expansion-panel-header-title'
                            }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Directive for a Material Design Accordion.
             */
            var MatAccordion = /** @class */ (function (_super) {
                __extends(MatAccordion, _super);
                function MatAccordion() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    _this._hideToggle = false;
                    /**
                     * Display mode used for all expansion panels in the accordion. Currently two display
                     * modes exist:
                     *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded
                     *     panel at a different elevation from the rest of the accordion.
                     *  flat - no spacing is placed around expanded panels, showing all panels at the same
                     *     elevation.
                     */
                    _this.displayMode = 'default';
                    /**
                     * The position of the expansion indicator.
                     */
                    _this.togglePosition = 'after';
                    return _this;
                }
                Object.defineProperty(MatAccordion.prototype, "hideToggle", {
                    /**
                     * Whether the expansion indicator should be hidden.
                     * @return {?}
                     */
                    get: function () { return this._hideToggle; },
                    /**
                     * @param {?} show
                     * @return {?}
                     */
                    set: function (show) { this._hideToggle = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(show); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatAccordion.prototype.ngAfterContentInit = function () {
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_10__["FocusKeyManager"](this._headers).withWrap();
                };
                /**
                 * Handles keyboard events coming in from the panel headers.
                 * @param {?} event
                 * @return {?}
                 */
                MatAccordion.prototype._handleHeaderKeydown = function (event) {
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["HOME"]) {
                        if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                            manager.setFirstItemActive();
                            event.preventDefault();
                        }
                    }
                    else if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["END"]) {
                        if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_11__["hasModifierKey"])(event)) {
                            manager.setLastItemActive();
                            event.preventDefault();
                        }
                    }
                    else {
                        this._keyManager.onKeydown(event);
                    }
                };
                /**
                 * @param {?} header
                 * @return {?}
                 */
                MatAccordion.prototype._handleHeaderFocus = function (header) {
                    this._keyManager.updateActiveItem(header);
                };
                return MatAccordion;
            }(_angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordion"]));
            MatAccordion.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-accordion',
                            exportAs: 'matAccordion',
                            inputs: ['multi'],
                            providers: [{
                                    provide: MAT_ACCORDION,
                                    useExisting: MatAccordion
                                }],
                            host: {
                                class: 'mat-accordion'
                            }
                        },] },
            ];
            MatAccordion.propDecorators = {
                _headers: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatExpansionPanelHeader, { descendants: true },] }],
                hideToggle: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                displayMode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                togglePosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatExpansionModule = /** @class */ (function () {
                function MatExpansionModule() {
                }
                return MatExpansionModule;
            }());
            MatExpansionModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"], _angular_cdk_accordion__WEBPACK_IMPORTED_MODULE_2__["CdkAccordionModule"], _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_5__["PortalModule"]],
                            exports: [
                                MatAccordion,
                                MatExpansionPanel,
                                MatExpansionPanelActionRow,
                                MatExpansionPanelHeader,
                                MatExpansionPanelTitle,
                                MatExpansionPanelDescription,
                                MatExpansionPanelContent,
                            ],
                            declarations: [
                                MatAccordion,
                                MatExpansionPanel,
                                MatExpansionPanelActionRow,
                                MatExpansionPanelHeader,
                                MatExpansionPanelTitle,
                                MatExpansionPanelDescription,
                                MatExpansionPanelContent,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=expansion.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/grid-list.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/grid-list.js ***!
          \*************************************************************/
        /*! exports provided: MatGridListModule, MatGridList, MatGridTile, MatGridTileText, MatGridAvatarCssMatStyler, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, ɵa11 */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridListModule", function () { return MatGridListModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridList", function () { return MatGridList; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTile", function () { return MatGridTile; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTileText", function () { return MatGridTileText; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridAvatarCssMatStyler", function () { return MatGridAvatarCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTileHeaderCssMatStyler", function () { return MatGridTileHeaderCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatGridTileFooterCssMatStyler", function () { return MatGridTileFooterCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa11", function () { return MAT_GRID_LIST; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token used to provide a grid list to a tile and to avoid circular imports.
             * \@docs-private
             * @type {?}
             */
            var MAT_GRID_LIST = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('MAT_GRID_LIST');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatGridTile = /** @class */ (function () {
                /**
                 * @param {?} _element
                 * @param {?=} _gridList
                 */
                function MatGridTile(_element, _gridList) {
                    this._element = _element;
                    this._gridList = _gridList;
                    this._rowspan = 1;
                    this._colspan = 1;
                }
                Object.defineProperty(MatGridTile.prototype, "rowspan", {
                    /**
                     * Amount of rows that the grid tile takes up.
                     * @return {?}
                     */
                    get: function () { return this._rowspan; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._rowspan = Math.round(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value)); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatGridTile.prototype, "colspan", {
                    /**
                     * Amount of columns that the grid tile takes up.
                     * @return {?}
                     */
                    get: function () { return this._colspan; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._colspan = Math.round(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value)); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the style of the grid-tile element.  Needs to be set manually to avoid
                 * "Changed after checked" errors that would occur with HostBinding.
                 * @param {?} property
                 * @param {?} value
                 * @return {?}
                 */
                MatGridTile.prototype._setStyle = function (property, value) {
                    (( /** @type {?} */(this._element.nativeElement.style)))[property] = value;
                };
                return MatGridTile;
            }());
            MatGridTile.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-grid-tile',
                            exportAs: 'matGridTile',
                            host: {
                                'class': 'mat-grid-tile',
                            },
                            template: "<figure class=\"mat-figure\"><ng-content></ng-content></figure>",
                            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatGridTile.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_GRID_LIST,] }] }
            ]; };
            MatGridTile.propDecorators = {
                rowspan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                colspan: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatGridTileText = /** @class */ (function () {
                /**
                 * @param {?} _element
                 */
                function MatGridTileText(_element) {
                    this._element = _element;
                }
                /**
                 * @return {?}
                 */
                MatGridTileText.prototype.ngAfterContentInit = function () {
                    Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["setLines"])(this._lines, this._element);
                };
                return MatGridTileText;
            }());
            MatGridTileText.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-grid-tile-header, mat-grid-tile-footer',
                            template: "<ng-content select=\"[mat-grid-avatar], [matGridAvatar]\"></ng-content><div class=\"mat-grid-list-text\"><ng-content select=\"[mat-line], [matLine]\"></ng-content></div><ng-content></ng-content>",
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatGridTileText.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            MatGridTileText.propDecorators = {
                _lines: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLine"],] }]
            };
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatGridAvatarCssMatStyler = /** @class */ (function () {
                function MatGridAvatarCssMatStyler() {
                }
                return MatGridAvatarCssMatStyler;
            }());
            MatGridAvatarCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-grid-avatar], [matGridAvatar]',
                            host: { 'class': 'mat-grid-avatar' }
                        },] },
            ];
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatGridTileHeaderCssMatStyler = /** @class */ (function () {
                function MatGridTileHeaderCssMatStyler() {
                }
                return MatGridTileHeaderCssMatStyler;
            }());
            MatGridTileHeaderCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-grid-tile-header',
                            host: { 'class': 'mat-grid-tile-header' }
                        },] },
            ];
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatGridTileFooterCssMatStyler = /** @class */ (function () {
                function MatGridTileFooterCssMatStyler() {
                }
                return MatGridTileFooterCssMatStyler;
            }());
            MatGridTileFooterCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'mat-grid-tile-footer',
                            host: { 'class': 'mat-grid-tile-footer' }
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Class for determining, from a list of tiles, the (row, col) position of each of those tiles
             * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)
             * because the tiles can have a rowspan.
             *
             * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid
             * large enough to accommodate it so that the tiles still render in the same order in which they
             * are given.
             *
             * The basis of the algorithm is the use of an array to track the already placed tiles. Each
             * element of the array corresponds to a column, and the value indicates how many cells in that
             * column are already occupied; zero indicates an empty cell. Moving "down" to the next row
             * decrements each value in the tracking array (indicating that the column is one cell closer to
             * being free).
             *
             * \@docs-private
             */
            var TileCoordinator = /** @class */ (function () {
                function TileCoordinator() {
                    /**
                     * Index at which the search for the next gap will start.
                     */
                    this.columnIndex = 0;
                    /**
                     * The current row index.
                     */
                    this.rowIndex = 0;
                }
                Object.defineProperty(TileCoordinator.prototype, "rowCount", {
                    /**
                     * Gets the total number of rows occupied by tiles
                     * @return {?}
                     */
                    get: function () { return this.rowIndex + 1; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TileCoordinator.prototype, "rowspan", {
                    /**
                     * Gets the total span of rows occupied by tiles.
                     * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var lastRowMax = Math.max.apply(Math, __spread(this.tracker));
                        // if any of the tiles has a rowspan that pushes it beyond the total row count,
                        // add the difference to the rowcount
                        return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Updates the tile positions.
                 * @param {?} numColumns Amount of columns in the grid.
                 * @param {?} tiles
                 * @return {?}
                 */
                TileCoordinator.prototype.update = function (numColumns, tiles) {
                    var _this = this;
                    this.columnIndex = 0;
                    this.rowIndex = 0;
                    this.tracker = new Array(numColumns);
                    this.tracker.fill(0, 0, this.tracker.length);
                    this.positions = tiles.map(( /**
                     * @param {?} tile
                     * @return {?}
                     */function (/**
                     * @param {?} tile
                     * @return {?}
                     */ tile) { return _this._trackTile(tile); }));
                };
                /**
                 * Calculates the row and col position of a tile.
                 * @private
                 * @param {?} tile
                 * @return {?}
                 */
                TileCoordinator.prototype._trackTile = function (tile) {
                    // Find a gap large enough for this tile.
                    /** @type {?} */
                    var gapStartIndex = this._findMatchingGap(tile.colspan);
                    // Place tile in the resulting gap.
                    this._markTilePosition(gapStartIndex, tile);
                    // The next time we look for a gap, the search will start at columnIndex, which should be
                    // immediately after the tile that has just been placed.
                    this.columnIndex = gapStartIndex + tile.colspan;
                    return new TilePosition(this.rowIndex, gapStartIndex);
                };
                /**
                 * Finds the next available space large enough to fit the tile.
                 * @private
                 * @param {?} tileCols
                 * @return {?}
                 */
                TileCoordinator.prototype._findMatchingGap = function (tileCols) {
                    if (tileCols > this.tracker.length) {
                        throw Error("mat-grid-list: tile with colspan " + tileCols + " is wider than " +
                            ("grid with cols=\"" + this.tracker.length + "\"."));
                    }
                    // Start index is inclusive, end index is exclusive.
                    /** @type {?} */
                    var gapStartIndex = -1;
                    /** @type {?} */
                    var gapEndIndex = -1;
                    // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.
                    do {
                        // If we've reached the end of the row, go to the next row.
                        if (this.columnIndex + tileCols > this.tracker.length) {
                            this._nextRow();
                            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                            gapEndIndex = this._findGapEndIndex(gapStartIndex);
                            continue;
                        }
                        gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                        // If there are no more empty spaces in this row at all, move on to the next row.
                        if (gapStartIndex == -1) {
                            this._nextRow();
                            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
                            gapEndIndex = this._findGapEndIndex(gapStartIndex);
                            continue;
                        }
                        gapEndIndex = this._findGapEndIndex(gapStartIndex);
                        // If a gap large enough isn't found, we want to start looking immediately after the current
                        // gap on the next iteration.
                        this.columnIndex = gapStartIndex + 1;
                        // Continue iterating until we find a gap wide enough for this tile. Since gapEndIndex is
                        // exclusive, gapEndIndex is 0 means we didn't find a gap and should continue.
                    } while ((gapEndIndex - gapStartIndex < tileCols) || (gapEndIndex == 0));
                    // If we still didn't manage to find a gap, ensure that the index is
                    // at least zero so the tile doesn't get pulled out of the grid.
                    return Math.max(gapStartIndex, 0);
                };
                /**
                 * Move "down" to the next row.
                 * @private
                 * @return {?}
                 */
                TileCoordinator.prototype._nextRow = function () {
                    this.columnIndex = 0;
                    this.rowIndex++;
                    // Decrement all spaces by one to reflect moving down one row.
                    for (var i = 0; i < this.tracker.length; i++) {
                        this.tracker[i] = Math.max(0, this.tracker[i] - 1);
                    }
                };
                /**
                 * Finds the end index (exclusive) of a gap given the index from which to start looking.
                 * The gap ends when a non-zero value is found.
                 * @private
                 * @param {?} gapStartIndex
                 * @return {?}
                 */
                TileCoordinator.prototype._findGapEndIndex = function (gapStartIndex) {
                    for (var i = gapStartIndex + 1; i < this.tracker.length; i++) {
                        if (this.tracker[i] != 0) {
                            return i;
                        }
                    }
                    // The gap ends with the end of the row.
                    return this.tracker.length;
                };
                /**
                 * Update the tile tracker to account for the given tile in the given space.
                 * @private
                 * @param {?} start
                 * @param {?} tile
                 * @return {?}
                 */
                TileCoordinator.prototype._markTilePosition = function (start, tile) {
                    for (var i = 0; i < tile.colspan; i++) {
                        this.tracker[start + i] = tile.rowspan;
                    }
                };
                return TileCoordinator;
            }());
            /**
             * Simple data structure for tile position (row, col).
             * \@docs-private
             */
            var TilePosition = /** @class */ (function () {
                /**
                 * @param {?} row
                 * @param {?} col
                 */
                function TilePosition(row, col) {
                    this.row = row;
                    this.col = col;
                }
                return TilePosition;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * RegExp that can be used to check whether a value will
             * be allowed inside a CSS `calc()` expression.
             * @type {?}
             */
            var cssCalcAllowedValue = /^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;
            /**
             * Sets the style properties for an individual tile, given the position calculated by the
             * Tile Coordinator.
             * \@docs-private
             * @abstract
             */
            var TileStyler = /** @class */ (function () {
                function TileStyler() {
                    this._rows = 0;
                    this._rowspan = 0;
                }
                /**
                 * Adds grid-list layout info once it is available. Cannot be processed in the constructor
                 * because these properties haven't been calculated by that point.
                 *
                 * @param {?} gutterSize Size of the grid's gutter.
                 * @param {?} tracker Instance of the TileCoordinator.
                 * @param {?} cols Amount of columns in the grid.
                 * @param {?} direction Layout direction of the grid.
                 * @return {?}
                 */
                TileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
                    this._gutterSize = normalizeUnits(gutterSize);
                    this._rows = tracker.rowCount;
                    this._rowspan = tracker.rowspan;
                    this._cols = cols;
                    this._direction = direction;
                };
                /**
                 * Computes the amount of space a single 1x1 tile would take up (width or height).
                 * Used as a basis for other calculations.
                 * @param {?} sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
                 * @param {?} gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
                 * @return {?} The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
                 */
                TileStyler.prototype.getBaseTileSize = function (sizePercent, gutterFraction) {
                    // Take the base size percent (as would be if evenly dividing the size between cells),
                    // and then subtracting the size of one gutter. However, since there are no gutters on the
                    // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter
                    // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the
                    // edge evenly among the cells).
                    return "(" + sizePercent + "% - (" + this._gutterSize + " * " + gutterFraction + "))";
                };
                /**
                 * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
                 * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
                 * @param {?} offset Number of tiles that have already been rendered in the row/column.
                 * @return {?} Position of the tile as a CSS calc() expression.
                 */
                TileStyler.prototype.getTilePosition = function (baseSize, offset) {
                    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
                    // row/column (offset).
                    return offset === 0 ? '0' : calc("(" + baseSize + " + " + this._gutterSize + ") * " + offset);
                };
                /**
                 * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
                 * @param {?} baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
                 * @param {?} span The tile's rowspan or colspan.
                 * @return {?} Size of the tile as a CSS calc() expression.
                 */
                TileStyler.prototype.getTileSize = function (baseSize, span) {
                    return "(" + baseSize + " * " + span + ") + (" + (span - 1) + " * " + this._gutterSize + ")";
                };
                /**
                 * Sets the style properties to be applied to a tile for the given row and column index.
                 * @param {?} tile Tile to which to apply the styling.
                 * @param {?} rowIndex Index of the tile's row.
                 * @param {?} colIndex Index of the tile's column.
                 * @return {?}
                 */
                TileStyler.prototype.setStyle = function (tile, rowIndex, colIndex) {
                    // Percent of the available horizontal space that one column takes up.
                    /** @type {?} */
                    var percentWidthPerTile = 100 / this._cols;
                    // Fraction of the vertical gutter size that each column takes up.
                    // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.
                    /** @type {?} */
                    var gutterWidthFractionPerTile = (this._cols - 1) / this._cols;
                    this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);
                    this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);
                };
                /**
                 * Sets the horizontal placement of the tile in the list.
                 * @param {?} tile
                 * @param {?} colIndex
                 * @param {?} percentWidth
                 * @param {?} gutterWidth
                 * @return {?}
                 */
                TileStyler.prototype.setColStyles = function (tile, colIndex, percentWidth, gutterWidth) {
                    // Base horizontal size of a column.
                    /** @type {?} */
                    var baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);
                    // The width and horizontal position of each tile is always calculated the same way, but the
                    // height and vertical position depends on the rowMode.
                    /** @type {?} */
                    var side = this._direction === 'rtl' ? 'right' : 'left';
                    tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));
                    tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));
                };
                /**
                 * Calculates the total size taken up by gutters across one axis of a list.
                 * @return {?}
                 */
                TileStyler.prototype.getGutterSpan = function () {
                    return this._gutterSize + " * (" + this._rowspan + " - 1)";
                };
                /**
                 * Calculates the total size taken up by tiles across one axis of a list.
                 * @param {?} tileHeight Height of the tile.
                 * @return {?}
                 */
                TileStyler.prototype.getTileSpan = function (tileHeight) {
                    return this._rowspan + " * " + this.getTileSize(tileHeight, 1);
                };
                /**
                 * Calculates the computed height and returns the correct style property to set.
                 * This method can be implemented by each type of TileStyler.
                 * \@docs-private
                 * @return {?}
                 */
                TileStyler.prototype.getComputedHeight = function () { return null; };
                return TileStyler;
            }());
            /**
             * This type of styler is instantiated when the user passes in a fixed row height.
             * Example `<mat-grid-list cols="3" rowHeight="100px">`
             * \@docs-private
             */
            var FixedTileStyler = /** @class */ (function (_super) {
                __extends(FixedTileStyler, _super);
                /**
                 * @param {?} fixedRowHeight
                 */
                function FixedTileStyler(fixedRowHeight) {
                    var _this = _super.call(this) || this;
                    _this.fixedRowHeight = fixedRowHeight;
                    return _this;
                }
                /**
                 * @param {?} gutterSize
                 * @param {?} tracker
                 * @param {?} cols
                 * @param {?} direction
                 * @return {?}
                 */
                FixedTileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {
                    _super.prototype.init.call(this, gutterSize, tracker, cols, direction);
                    this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);
                    if (!cssCalcAllowedValue.test(this.fixedRowHeight)) {
                        throw Error("Invalid value \"" + this.fixedRowHeight + "\" set as rowHeight.");
                    }
                };
                /**
                 * @param {?} tile
                 * @param {?} rowIndex
                 * @return {?}
                 */
                FixedTileStyler.prototype.setRowStyles = function (tile, rowIndex) {
                    tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));
                    tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));
                };
                /**
                 * @return {?}
                 */
                FixedTileStyler.prototype.getComputedHeight = function () {
                    return [
                        'height', calc(this.getTileSpan(this.fixedRowHeight) + " + " + this.getGutterSpan())
                    ];
                };
                /**
                 * @param {?} list
                 * @return {?}
                 */
                FixedTileStyler.prototype.reset = function (list) {
                    list._setListStyle(['height', null]);
                    if (list._tiles) {
                        list._tiles.forEach(( /**
                         * @param {?} tile
                         * @return {?}
                         */function (/**
                         * @param {?} tile
                         * @return {?}
                         */ tile) {
                            tile._setStyle('top', null);
                            tile._setStyle('height', null);
                        }));
                    }
                };
                return FixedTileStyler;
            }(TileStyler));
            /**
             * This type of styler is instantiated when the user passes in a width:height ratio
             * for the row height.  Example `<mat-grid-list cols="3" rowHeight="3:1">`
             * \@docs-private
             */
            var RatioTileStyler = /** @class */ (function (_super) {
                __extends(RatioTileStyler, _super);
                /**
                 * @param {?} value
                 */
                function RatioTileStyler(value) {
                    var _this = _super.call(this) || this;
                    _this._parseRatio(value);
                    return _this;
                }
                /**
                 * @param {?} tile
                 * @param {?} rowIndex
                 * @param {?} percentWidth
                 * @param {?} gutterWidth
                 * @return {?}
                 */
                RatioTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {
                    /** @type {?} */
                    var percentHeightPerTile = percentWidth / this.rowHeightRatio;
                    this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);
                    // Use padding-top and margin-top to maintain the given aspect ratio, as
                    // a percentage-based value for these properties is applied versus the *width* of the
                    // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
                    tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));
                    tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));
                };
                /**
                 * @return {?}
                 */
                RatioTileStyler.prototype.getComputedHeight = function () {
                    return [
                        'paddingBottom', calc(this.getTileSpan(this.baseTileHeight) + " + " + this.getGutterSpan())
                    ];
                };
                /**
                 * @param {?} list
                 * @return {?}
                 */
                RatioTileStyler.prototype.reset = function (list) {
                    list._setListStyle(['paddingBottom', null]);
                    list._tiles.forEach(( /**
                     * @param {?} tile
                     * @return {?}
                     */function (/**
                     * @param {?} tile
                     * @return {?}
                     */ tile) {
                        tile._setStyle('marginTop', null);
                        tile._setStyle('paddingTop', null);
                    }));
                };
                /**
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                RatioTileStyler.prototype._parseRatio = function (value) {
                    /** @type {?} */
                    var ratioParts = value.split(':');
                    if (ratioParts.length !== 2) {
                        throw Error("mat-grid-list: invalid ratio given for row-height: \"" + value + "\"");
                    }
                    this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);
                };
                return RatioTileStyler;
            }(TileStyler));
            /**
             * This type of styler is instantiated when the user selects a "fit" row height mode.
             * In other words, the row height will reflect the total height of the container divided
             * by the number of rows.  Example `<mat-grid-list cols="3" rowHeight="fit">`
             *
             * \@docs-private
             */
            var FitTileStyler = /** @class */ (function (_super) {
                __extends(FitTileStyler, _super);
                function FitTileStyler() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                /**
                 * @param {?} tile
                 * @param {?} rowIndex
                 * @return {?}
                 */
                FitTileStyler.prototype.setRowStyles = function (tile, rowIndex) {
                    // Percent of the available vertical space that one row takes up.
                    /** @type {?} */
                    var percentHeightPerTile = 100 / this._rowspan;
                    // Fraction of the horizontal gutter size that each column takes up.
                    /** @type {?} */
                    var gutterHeightPerTile = (this._rows - 1) / this._rows;
                    // Base vertical size of a column.
                    /** @type {?} */
                    var baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);
                    tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));
                    tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));
                };
                /**
                 * @param {?} list
                 * @return {?}
                 */
                FitTileStyler.prototype.reset = function (list) {
                    if (list._tiles) {
                        list._tiles.forEach(( /**
                         * @param {?} tile
                         * @return {?}
                         */function (/**
                         * @param {?} tile
                         * @return {?}
                         */ tile) {
                            tile._setStyle('top', null);
                            tile._setStyle('height', null);
                        }));
                    }
                };
                return FitTileStyler;
            }(TileStyler));
            /**
             * Wraps a CSS string in a calc function
             * @param {?} exp
             * @return {?}
             */
            function calc(exp) {
                return "calc(" + exp + ")";
            }
            /**
             * Appends pixels to a CSS string if no units are given.
             * @param {?} value
             * @return {?}
             */
            function normalizeUnits(value) {
                return value.match(/([A-Za-z%]+)$/) ? value : value + "px";
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // TODO(kara): Conditional (responsive) column count / row size.
            // TODO(kara): Re-layout on window resize / media change (debounced).
            // TODO(kara): gridTileHeader and gridTileFooter.
            /** @type {?} */
            var MAT_FIT_MODE = 'fit';
            var MatGridList = /** @class */ (function () {
                /**
                 * @param {?} _element
                 * @param {?} _dir
                 */
                function MatGridList(_element, _dir) {
                    this._element = _element;
                    this._dir = _dir;
                    /**
                     * The amount of space between tiles. This will be something like '5px' or '2em'.
                     */
                    this._gutter = '1px';
                }
                Object.defineProperty(MatGridList.prototype, "cols", {
                    /**
                     * Amount of columns in the grid list.
                     * @return {?}
                     */
                    get: function () { return this._cols; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._cols = Math.max(1, Math.round(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value)));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatGridList.prototype, "gutterSize", {
                    /**
                     * Size of the grid list's gutter in pixels.
                     * @return {?}
                     */
                    get: function () { return this._gutter; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._gutter = "" + (value == null ? '' : value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatGridList.prototype, "rowHeight", {
                    /**
                     * Set internal representation of row height from the user-provided value.
                     * @return {?}
                     */
                    get: function () { return this._rowHeight; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = "" + (value == null ? '' : value);
                        if (newValue !== this._rowHeight) {
                            this._rowHeight = newValue;
                            this._setTileStyler(this._rowHeight);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatGridList.prototype.ngOnInit = function () {
                    this._checkCols();
                    this._checkRowHeight();
                };
                /**
                 * The layout calculation is fairly cheap if nothing changes, so there's little cost
                 * to run it frequently.
                 * @return {?}
                 */
                MatGridList.prototype.ngAfterContentChecked = function () {
                    this._layoutTiles();
                };
                /**
                 * Throw a friendly error if cols property is missing
                 * @private
                 * @return {?}
                 */
                MatGridList.prototype._checkCols = function () {
                    if (!this.cols) {
                        throw Error("mat-grid-list: must pass in number of columns. " +
                            "Example: <mat-grid-list cols=\"3\">");
                    }
                };
                /**
                 * Default to equal width:height if rowHeight property is missing
                 * @private
                 * @return {?}
                 */
                MatGridList.prototype._checkRowHeight = function () {
                    if (!this._rowHeight) {
                        this._setTileStyler('1:1');
                    }
                };
                /**
                 * Creates correct Tile Styler subtype based on rowHeight passed in by user
                 * @private
                 * @param {?} rowHeight
                 * @return {?}
                 */
                MatGridList.prototype._setTileStyler = function (rowHeight) {
                    if (this._tileStyler) {
                        this._tileStyler.reset(this);
                    }
                    if (rowHeight === MAT_FIT_MODE) {
                        this._tileStyler = new FitTileStyler();
                    }
                    else if (rowHeight && rowHeight.indexOf(':') > -1) {
                        this._tileStyler = new RatioTileStyler(rowHeight);
                    }
                    else {
                        this._tileStyler = new FixedTileStyler(rowHeight);
                    }
                };
                /**
                 * Computes and applies the size and position for all children grid tiles.
                 * @private
                 * @return {?}
                 */
                MatGridList.prototype._layoutTiles = function () {
                    var _this = this;
                    if (!this._tileCoordinator) {
                        this._tileCoordinator = new TileCoordinator();
                    }
                    /** @type {?} */
                    var tracker = this._tileCoordinator;
                    /** @type {?} */
                    var tiles = this._tiles.filter(( /**
                     * @param {?} tile
                     * @return {?}
                     */function (/**
                     * @param {?} tile
                     * @return {?}
                     */ tile) { return !tile._gridList || tile._gridList === _this; }));
                    /** @type {?} */
                    var direction = this._dir ? this._dir.value : 'ltr';
                    this._tileCoordinator.update(this.cols, tiles);
                    this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);
                    tiles.forEach(( /**
                     * @param {?} tile
                     * @param {?} index
                     * @return {?}
                     */function (tile, index) {
                        /** @type {?} */
                        var pos = tracker.positions[index];
                        _this._tileStyler.setStyle(tile, pos.row, pos.col);
                    }));
                    this._setListStyle(this._tileStyler.getComputedHeight());
                };
                /**
                 * Sets style on the main grid-list element, given the style name and value.
                 * @param {?} style
                 * @return {?}
                 */
                MatGridList.prototype._setListStyle = function (style) {
                    if (style) {
                        (( /** @type {?} */(this._element.nativeElement.style)))[style[0]] = style[1];
                    }
                };
                return MatGridList;
            }());
            MatGridList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-grid-list',
                            exportAs: 'matGridList',
                            template: "<div><ng-content></ng-content></div>",
                            styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-figure{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}.mat-grid-tile .mat-grid-tile-footer,.mat-grid-tile .mat-grid-tile-header{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-footer>*,.mat-grid-tile .mat-grid-tile-header>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-tile-footer.mat-2-line,.mat-grid-tile .mat-grid-tile-header.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}"],
                            host: {
                                'class': 'mat-grid-list',
                            },
                            providers: [{
                                    provide: MAT_GRID_LIST,
                                    useExisting: MatGridList
                                }],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatGridList.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_3__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatGridList.propDecorators = {
                _tiles: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatGridTile, { descendants: true },] }],
                cols: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                gutterSize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                rowHeight: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatGridListModule = /** @class */ (function () {
                function MatGridListModule() {
                }
                return MatGridListModule;
            }());
            MatGridListModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLineModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatCommonModule"]],
                            exports: [
                                MatGridList,
                                MatGridTile,
                                MatGridTileText,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLineModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatCommonModule"],
                                MatGridTileHeaderCssMatStyler,
                                MatGridTileFooterCssMatStyler,
                                MatGridAvatarCssMatStyler
                            ],
                            declarations: [
                                MatGridList,
                                MatGridTile,
                                MatGridTileText,
                                MatGridTileHeaderCssMatStyler,
                                MatGridTileFooterCssMatStyler,
                                MatGridAvatarCssMatStyler
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=grid-list.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/list.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/list.js ***!
          \********************************************************/
        /*! exports provided: MatListModule, MatNavList, MatList, MatListAvatarCssMatStyler, MatListIconCssMatStyler, MatListSubheaderCssMatStyler, MatListItem, MAT_SELECTION_LIST_VALUE_ACCESSOR, MatSelectionListChange, MatListOption, MatSelectionList */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatListModule", function () { return MatListModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatNavList", function () { return MatNavList; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatList", function () { return MatList; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatListAvatarCssMatStyler", function () { return MatListAvatarCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatListIconCssMatStyler", function () { return MatListIconCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatListSubheaderCssMatStyler", function () { return MatListSubheaderCssMatStyler; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatListItem", function () { return MatListItem; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECTION_LIST_VALUE_ACCESSOR", function () { return MAT_SELECTION_LIST_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSelectionListChange", function () { return MatSelectionListChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatListOption", function () { return MatListOption; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSelectionList", function () { return MatSelectionList; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_divider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/divider */ "./node_modules/@angular/material/esm2015/divider.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatList.
            /**
             * \@docs-private
             */
            var MatListBase = /** @class */ (function () {
                function MatListBase() {
                }
                return MatListBase;
            }());
            /** @type {?} */
            var _MatListMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["mixinDisableRipple"])(MatListBase);
            // Boilerplate for applying mixins to MatListItem.
            /**
             * \@docs-private
             */
            var MatListItemBase = /** @class */ (function () {
                function MatListItemBase() {
                }
                return MatListItemBase;
            }());
            /** @type {?} */
            var _MatListItemMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["mixinDisableRipple"])(MatListItemBase);
            var MatNavList = /** @class */ (function (_super) {
                __extends(MatNavList, _super);
                function MatNavList() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    /**
                     * Emits when the state of the list changes.
                     */
                    _this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatNavList.prototype.ngOnChanges = function () {
                    this._stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatNavList.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                return MatNavList;
            }(_MatListMixinBase));
            MatNavList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-nav-list',
                            exportAs: 'matNavList',
                            host: {
                                'role': 'navigation',
                                'class': 'mat-nav-list mat-list-base'
                            },
                            template: "<ng-content></ng-content>",
                            styles: [".mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:0}mat-action-list button{background:0 0;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:0}@media (-ms-high-contrast:active){.mat-selection-list:focus{outline-style:dotted}.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover,mat-action-list .mat-list-item:focus,mat-action-list .mat-list-item:hover{outline:dotted 1px}}@media (hover:none){.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover{background:0 0}}"],
                            inputs: ['disableRipple'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            var MatList = /** @class */ (function (_super) {
                __extends(MatList, _super);
                /**
                 * @param {?} _elementRef
                 */
                function MatList(_elementRef) {
                    var _this = _super.call(this) || this;
                    _this._elementRef = _elementRef;
                    /**
                     * Emits when the state of the list changes.
                     */
                    _this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    if (_this._getListType() === 'action-list') {
                        _elementRef.nativeElement.classList.add('mat-action-list');
                    }
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatList.prototype._getListType = function () {
                    /** @type {?} */
                    var nodeName = this._elementRef.nativeElement.nodeName.toLowerCase();
                    if (nodeName === 'mat-list') {
                        return 'list';
                    }
                    if (nodeName === 'mat-action-list') {
                        return 'action-list';
                    }
                    return null;
                };
                /**
                 * @return {?}
                 */
                MatList.prototype.ngOnChanges = function () {
                    this._stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatList.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                return MatList;
            }(_MatListMixinBase));
            MatList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-list, mat-action-list',
                            exportAs: 'matList',
                            template: "<ng-content></ng-content>",
                            host: {
                                'class': 'mat-list mat-list-base'
                            },
                            styles: [".mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:0}mat-action-list button{background:0 0;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:0}@media (-ms-high-contrast:active){.mat-selection-list:focus{outline-style:dotted}.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover,mat-action-list .mat-list-item:focus,mat-action-list .mat-list-item:hover{outline:dotted 1px}}@media (hover:none){.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover{background:0 0}}"],
                            inputs: ['disableRipple'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatList.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] }
            ]; };
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatListAvatarCssMatStyler = /** @class */ (function () {
                function MatListAvatarCssMatStyler() {
                }
                return MatListAvatarCssMatStyler;
            }());
            MatListAvatarCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-list-avatar], [matListAvatar]',
                            host: { 'class': 'mat-list-avatar' }
                        },] },
            ];
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatListIconCssMatStyler = /** @class */ (function () {
                function MatListIconCssMatStyler() {
                }
                return MatListIconCssMatStyler;
            }());
            MatListIconCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-list-icon], [matListIcon]',
                            host: { 'class': 'mat-list-icon' }
                        },] },
            ];
            /**
             * Directive whose purpose is to add the mat- CSS styling to this selector.
             * \@docs-private
             */
            var MatListSubheaderCssMatStyler = /** @class */ (function () {
                function MatListSubheaderCssMatStyler() {
                }
                return MatListSubheaderCssMatStyler;
            }());
            MatListSubheaderCssMatStyler.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[mat-subheader], [matSubheader]',
                            host: { 'class': 'mat-subheader' }
                        },] },
            ];
            /**
             * An item within a Material Design list.
             */
            var MatListItem = /** @class */ (function (_super) {
                __extends(MatListItem, _super);
                /**
                 * @param {?} _element
                 * @param {?} _changeDetectorRef
                 * @param {?=} navList
                 * @param {?=} list
                 */
                function MatListItem(_element, _changeDetectorRef, navList, list) {
                    var _this = _super.call(this) || this;
                    _this._element = _element;
                    _this._isInteractiveList = false;
                    _this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    _this._isInteractiveList = !!(navList || (list && list._getListType() === 'action-list'));
                    _this._list = navList || list;
                    // If no type attributed is specified for <button>, set it to "button".
                    // If a type attribute is already specified, do nothing.
                    /** @type {?} */
                    var element = _this._getHostElement();
                    if (element.nodeName.toLowerCase() === 'button' && !element.hasAttribute('type')) {
                        element.setAttribute('type', 'button');
                    }
                    if (_this._list) {
                        // React to changes in the state of the parent list since
                        // some of the item's properties depend on it (e.g. `disableRipple`).
                        _this._list._stateChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(_this._destroyed)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _changeDetectorRef.markForCheck();
                        }));
                    }
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatListItem.prototype.ngAfterContentInit = function () {
                    Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["setLines"])(this._lines, this._element);
                };
                /**
                 * @return {?}
                 */
                MatListItem.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Whether this list item should show a ripple effect when clicked.
                 * @return {?}
                 */
                MatListItem.prototype._isRippleDisabled = function () {
                    return !this._isInteractiveList || this.disableRipple ||
                        !!(this._list && this._list.disableRipple);
                };
                /**
                 * Retrieves the DOM element of the component host.
                 * @return {?}
                 */
                MatListItem.prototype._getHostElement = function () {
                    return this._element.nativeElement;
                };
                return MatListItem;
            }(_MatListItemMixinBase));
            MatListItem.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-list-item, a[mat-list-item], button[mat-list-item]',
                            exportAs: 'matListItem',
                            host: {
                                'class': 'mat-list-item',
                                // @breaking-change 8.0.0 Remove `mat-list-item-avatar` in favor of `mat-list-item-with-avatar`.
                                '[class.mat-list-item-avatar]': '_avatar || _icon',
                                '[class.mat-list-item-with-avatar]': '_avatar || _icon',
                            },
                            inputs: ['disableRipple'],
                            template: "<div class=\"mat-list-item-content\"><div class=\"mat-list-item-ripple\" mat-ripple [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"_isRippleDisabled()\"></div><ng-content select=\"[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]\"></ng-content><div class=\"mat-list-text\"><ng-content select=\"[mat-line], [matLine]\"></ng-content></div><ng-content></ng-content></div>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatListItem.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: MatNavList, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: MatList, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatListItem.propDecorators = {
                _lines: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLine"], { descendants: true },] }],
                _avatar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatListAvatarCssMatStyler, { static: false },] }],
                _icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatListIconCssMatStyler, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             */
            var MatSelectionListBase = /** @class */ (function () {
                function MatSelectionListBase() {
                }
                return MatSelectionListBase;
            }());
            /** @type {?} */
            var _MatSelectionListMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["mixinDisableRipple"])(MatSelectionListBase);
            /**
             * \@docs-private
             */
            var MatListOptionBase = /** @class */ (function () {
                function MatListOptionBase() {
                }
                return MatListOptionBase;
            }());
            /** @type {?} */
            var _MatListOptionMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["mixinDisableRipple"])(MatListOptionBase);
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_SELECTION_LIST_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_8__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSelectionList; })),
                multi: true
            };
            /**
             * Change event that is being fired whenever the selected state of an option changes.
             */
            var MatSelectionListChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} option
                 */
                function MatSelectionListChange(source, option) {
                    this.source = source;
                    this.option = option;
                }
                return MatSelectionListChange;
            }());
            /**
             * Component for list-options of selection-list. Each list-option can automatically
             * generate a checkbox and can put current item into the selectionModel of selection-list
             * if the current item is selected.
             */
            var MatListOption = /** @class */ (function (_super) {
                __extends(MatListOption, _super);
                /**
                 * @param {?} _element
                 * @param {?} _changeDetector
                 * @param {?} selectionList
                 */
                function MatListOption(_element, _changeDetector, selectionList) {
                    var _this = _super.call(this) || this;
                    _this._element = _element;
                    _this._changeDetector = _changeDetector;
                    _this.selectionList = selectionList;
                    _this._selected = false;
                    _this._disabled = false;
                    _this._hasFocus = false;
                    /**
                     * Whether the label should appear before or after the checkbox. Defaults to 'after'
                     */
                    _this.checkboxPosition = 'after';
                    return _this;
                }
                Object.defineProperty(MatListOption.prototype, "color", {
                    /**
                     * Theme color of the list option. This sets the color of the checkbox.
                     * @return {?}
                     */
                    get: function () { return this._color || this.selectionList.color; },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) { this._color = newValue; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatListOption.prototype, "value", {
                    /**
                     * Value of the option
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        if (this.selected && newValue !== this.value) {
                            this.selected = false;
                        }
                        this._value = newValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatListOption.prototype, "disabled", {
                    /**
                     * Whether the option is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled || (this.selectionList && this.selectionList.disabled); },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newValue = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__["coerceBooleanProperty"])(value);
                        if (newValue !== this._disabled) {
                            this._disabled = newValue;
                            this._changeDetector.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatListOption.prototype, "selected", {
                    /**
                     * Whether the option is selected.
                     * @return {?}
                     */
                    get: function () { return this.selectionList.selectedOptions.isSelected(this); },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var isSelected = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__["coerceBooleanProperty"])(value);
                        if (isSelected !== this._selected) {
                            this._setSelected(isSelected);
                            this.selectionList._reportValueChange();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatListOption.prototype.ngOnInit = function () {
                    var _this = this;
                    /** @type {?} */
                    var list = this.selectionList;
                    if (list._value && list._value.some(( /**
                     * @param {?} value
                     * @return {?}
                     */function (/**
                     * @param {?} value
                     * @return {?}
                     */ value) { return list.compareWith(value, _this._value); }))) {
                        this._setSelected(true);
                    }
                    /** @type {?} */
                    var wasSelected = this._selected;
                    // List options that are selected at initialization can't be reported properly to the form
                    // control. This is because it takes some time until the selection-list knows about all
                    // available options. Also it can happen that the ControlValueAccessor has an initial value
                    // that should be used instead. Deferring the value change report to the next tick ensures
                    // that the form control value is not being overwritten.
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        if (_this._selected || wasSelected) {
                            _this.selected = true;
                            _this._changeDetector.markForCheck();
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatListOption.prototype.ngAfterContentInit = function () {
                    Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["setLines"])(this._lines, this._element);
                };
                /**
                 * @return {?}
                 */
                MatListOption.prototype.ngOnDestroy = function () {
                    var _this = this;
                    if (this.selected) {
                        // We have to delay this until the next tick in order
                        // to avoid changed after checked errors.
                        Promise.resolve().then(( /**
                         * @return {?}
                         */function () {
                            _this.selected = false;
                        }));
                    }
                    /** @type {?} */
                    var hadFocus = this._hasFocus;
                    /** @type {?} */
                    var newActiveItem = this.selectionList._removeOptionFromList(this);
                    // Only move focus if this option was focused at the time it was destroyed.
                    if (hadFocus && newActiveItem) {
                        newActiveItem.focus();
                    }
                };
                /**
                 * Toggles the selection state of the option.
                 * @return {?}
                 */
                MatListOption.prototype.toggle = function () {
                    this.selected = !this.selected;
                };
                /**
                 * Allows for programmatic focusing of the option.
                 * @return {?}
                 */
                MatListOption.prototype.focus = function () {
                    this._element.nativeElement.focus();
                };
                /**
                 * Returns the list item's text label. Implemented as a part of the FocusKeyManager.
                 * \@docs-private
                 * @return {?}
                 */
                MatListOption.prototype.getLabel = function () {
                    return this._text ? (this._text.nativeElement.textContent || '') : '';
                };
                /**
                 * Whether this list item should show a ripple effect when clicked.
                 * @return {?}
                 */
                MatListOption.prototype._isRippleDisabled = function () {
                    return this.disabled || this.disableRipple || this.selectionList.disableRipple;
                };
                /**
                 * @return {?}
                 */
                MatListOption.prototype._handleClick = function () {
                    if (!this.disabled) {
                        this.toggle();
                        // Emit a change event if the selected state of the option changed through user interaction.
                        this.selectionList._emitChangeEvent(this);
                    }
                };
                /**
                 * @return {?}
                 */
                MatListOption.prototype._handleFocus = function () {
                    this.selectionList._setFocusedOption(this);
                    this._hasFocus = true;
                };
                /**
                 * @return {?}
                 */
                MatListOption.prototype._handleBlur = function () {
                    this.selectionList._onTouched();
                    this._hasFocus = false;
                };
                /**
                 * Retrieves the DOM element of the component host.
                 * @return {?}
                 */
                MatListOption.prototype._getHostElement = function () {
                    return this._element.nativeElement;
                };
                /**
                 * Sets the selected state of the option. Returns whether the value has changed.
                 * @param {?} selected
                 * @return {?}
                 */
                MatListOption.prototype._setSelected = function (selected) {
                    if (selected === this._selected) {
                        return false;
                    }
                    this._selected = selected;
                    if (selected) {
                        this.selectionList.selectedOptions.select(this);
                    }
                    else {
                        this.selectionList.selectedOptions.deselect(this);
                    }
                    this._changeDetector.markForCheck();
                    return true;
                };
                /**
                 * Notifies Angular that the option needs to be checked in the next change detection run. Mainly
                 * used to trigger an update of the list option if the disabled state of the selection list
                 * changed.
                 * @return {?}
                 */
                MatListOption.prototype._markForCheck = function () {
                    this._changeDetector.markForCheck();
                };
                return MatListOption;
            }(_MatListOptionMixinBase));
            MatListOption.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-list-option',
                            exportAs: 'matListOption',
                            inputs: ['disableRipple'],
                            host: {
                                'role': 'option',
                                'class': 'mat-list-item mat-list-option',
                                '(focus)': '_handleFocus()',
                                '(blur)': '_handleBlur()',
                                '(click)': '_handleClick()',
                                'tabindex': '-1',
                                '[class.mat-list-item-disabled]': 'disabled',
                                '[class.mat-list-item-with-avatar]': '_avatar || _icon',
                                // Manually set the "primary" or "warn" class if the color has been explicitly
                                // set to "primary" or "warn". The pseudo checkbox picks up these classes for
                                // its theme.
                                '[class.mat-primary]': 'color === "primary"',
                                // Even though accent is the default, we need to set this class anyway, because the  list might
                                // be placed inside a parent that has one of the other colors with a higher specificity.
                                '[class.mat-accent]': 'color !== "primary" && color !== "warn"',
                                '[class.mat-warn]': 'color === "warn"',
                                '[attr.aria-selected]': 'selected',
                                '[attr.aria-disabled]': 'disabled',
                            },
                            template: "<div class=\"mat-list-item-content\" [class.mat-list-item-content-reverse]=\"checkboxPosition == 'after'\"><div mat-ripple class=\"mat-list-item-ripple\" [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"_isRippleDisabled()\"></div><mat-pseudo-checkbox [state]=\"selected ? 'checked' : 'unchecked'\" [disabled]=\"disabled\"></mat-pseudo-checkbox><div class=\"mat-list-text\" #text><ng-content></ng-content></div><ng-content select=\"[mat-list-avatar], [mat-list-icon], [matListAvatar], [matListIcon]\"></ng-content></div>",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatListOption.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: MatSelectionList, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatSelectionList; })),] }] }
            ]; };
            MatListOption.propDecorators = {
                _avatar: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatListAvatarCssMatStyler, { static: false },] }],
                _icon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatListIconCssMatStyler, { static: false },] }],
                _lines: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLine"],] }],
                _text: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['text', { static: false },] }],
                checkboxPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * Material Design list component where each item is a selectable option. Behaves as a listbox.
             */
            var MatSelectionList = /** @class */ (function (_super) {
                __extends(MatSelectionList, _super);
                /**
                 * @param {?} _element
                 * @param {?} tabIndex
                 */
                function MatSelectionList(_element, tabIndex) {
                    var _this = _super.call(this) || this;
                    _this._element = _element;
                    /**
                     * Emits a change event whenever the selected state of an option changes.
                     */
                    _this.selectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Tabindex of the selection list.
                     */
                    _this.tabIndex = 0;
                    /**
                     * Theme color of the selection list. This sets the checkbox color for all list options.
                     */
                    _this.color = 'accent';
                    /**
                     * Function used for comparing an option against the selected value when determining which
                     * options should appear as selected. The first argument is the value of an options. The second
                     * one is a value from the selected value. A boolean must be returned.
                     */
                    _this.compareWith = ( /**
                     * @param {?} a1
                     * @param {?} a2
                     * @return {?}
                     */function (a1, a2) { return a1 === a2; });
                    _this._disabled = false;
                    /**
                     * The currently selected options.
                     */
                    _this.selectedOptions = new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_6__["SelectionModel"](true);
                    /**
                     * View to model callback that should be called whenever the selected options change.
                     */
                    _this._onChange = ( /**
                     * @param {?} _
                     * @return {?}
                     */function (_) { });
                    /**
                     * Emits when the list has been destroyed.
                     */
                    _this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * View to model callback that should be called if the list or its options lost focus.
                     */
                    _this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    return _this;
                }
                Object.defineProperty(MatSelectionList.prototype, "disabled", {
                    /**
                     * Whether the selection list is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__["coerceBooleanProperty"])(value);
                        // The `MatSelectionList` and `MatListOption` are using the `OnPush` change detection
                        // strategy. Therefore the options will not check for any changes if the `MatSelectionList`
                        // changed its state. Since we know that a change to `disabled` property of the list affects
                        // the state of the options, we manually mark each option for check.
                        this._markOptionsForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatSelectionList.prototype.ngAfterContentInit = function () {
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_4__["FocusKeyManager"](this.options)
                        .withWrap()
                        .withTypeAhead()
                        // Allow disabled items to be focusable. For accessibility reasons, there must be a way for
                        // screenreader users, that allows reading the different options of the list.
                        .skipPredicate(( /**
                 * @return {?}
                 */function () { return false; }))
                        .withAllowedModifierKeys(['shiftKey']);
                    if (this._value) {
                        this._setOptionsFromValues(this._value);
                    }
                    // Sync external changes to the model back to the options.
                    this.selectedOptions.onChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        var e_8, _a, e_9, _b;
                        if (event.added) {
                            try {
                                for (var _c = __values(event.added), _d = _c.next(); !_d.done; _d = _c.next()) {
                                    var item = _d.value;
                                    item.selected = true;
                                }
                            }
                            catch (e_8_1) { e_8 = { error: e_8_1 }; }
                            finally {
                                try {
                                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                                }
                                finally { if (e_8) throw e_8.error; }
                            }
                        }
                        if (event.removed) {
                            try {
                                for (var _e = __values(event.removed), _f = _e.next(); !_f.done; _f = _e.next()) {
                                    var item = _f.value;
                                    item.selected = false;
                                }
                            }
                            catch (e_9_1) { e_9 = { error: e_9_1 }; }
                            finally {
                                try {
                                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                                }
                                finally { if (e_9) throw e_9.error; }
                            }
                        }
                    }));
                };
                /**
                 * @param {?} changes
                 * @return {?}
                 */
                MatSelectionList.prototype.ngOnChanges = function (changes) {
                    /** @type {?} */
                    var disableRippleChanges = changes['disableRipple'];
                    /** @type {?} */
                    var colorChanges = changes['color'];
                    if ((disableRippleChanges && !disableRippleChanges.firstChange) ||
                        (colorChanges && !colorChanges.firstChange)) {
                        this._markOptionsForCheck();
                    }
                };
                /**
                 * @return {?}
                 */
                MatSelectionList.prototype.ngOnDestroy = function () {
                    this._destroyed.next();
                    this._destroyed.complete();
                    this._isDestroyed = true;
                };
                /**
                 * Focuses the selection list.
                 * @param {?=} options
                 * @return {?}
                 */
                MatSelectionList.prototype.focus = function (options) {
                    this._element.nativeElement.focus(options);
                };
                /**
                 * Selects all of the options.
                 * @return {?}
                 */
                MatSelectionList.prototype.selectAll = function () {
                    this._setAllOptionsSelected(true);
                };
                /**
                 * Deselects all of the options.
                 * @return {?}
                 */
                MatSelectionList.prototype.deselectAll = function () {
                    this._setAllOptionsSelected(false);
                };
                /**
                 * Sets the focused option of the selection-list.
                 * @param {?} option
                 * @return {?}
                 */
                MatSelectionList.prototype._setFocusedOption = function (option) {
                    this._keyManager.updateActiveItem(option);
                };
                /**
                 * Removes an option from the selection list and updates the active item.
                 * @param {?} option
                 * @return {?} Currently-active item.
                 */
                MatSelectionList.prototype._removeOptionFromList = function (option) {
                    /** @type {?} */
                    var optionIndex = this._getOptionIndex(option);
                    if (optionIndex > -1 && this._keyManager.activeItemIndex === optionIndex) {
                        // Check whether the option is the last item
                        if (optionIndex > 0) {
                            this._keyManager.updateActiveItem(optionIndex - 1);
                        }
                        else if (optionIndex === 0 && this.options.length > 1) {
                            this._keyManager.updateActiveItem(Math.min(optionIndex + 1, this.options.length - 1));
                        }
                    }
                    return this._keyManager.activeItem;
                };
                /**
                 * Passes relevant key presses to our key manager.
                 * @param {?} event
                 * @return {?}
                 */
                MatSelectionList.prototype._keydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    /** @type {?} */
                    var previousFocusIndex = manager.activeItemIndex;
                    /** @type {?} */
                    var hasModifier = Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["hasModifierKey"])(event);
                    switch (keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["SPACE"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["ENTER"]:
                            if (!hasModifier) {
                                this._toggleFocusedOption();
                                // Always prevent space from scrolling the page since the list has focus
                                event.preventDefault();
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["HOME"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["END"]:
                            if (!hasModifier) {
                                keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["HOME"] ? manager.setFirstItemActive() : manager.setLastItemActive();
                                event.preventDefault();
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["A"]:
                            if (Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["hasModifierKey"])(event, 'ctrlKey')) {
                                this.options.find(( /**
                                 * @param {?} option
                                 * @return {?}
                                 */function (/**
                                 * @param {?} option
                                 * @return {?}
                                 */ option) { return !option.selected; })) ? this.selectAll() : this.deselectAll();
                                event.preventDefault();
                            }
                            break;
                        default:
                            manager.onKeydown(event);
                    }
                    if ((keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__["DOWN_ARROW"]) && event.shiftKey &&
                        manager.activeItemIndex !== previousFocusIndex) {
                        this._toggleFocusedOption();
                    }
                };
                /**
                 * Reports a value change to the ControlValueAccessor
                 * @return {?}
                 */
                MatSelectionList.prototype._reportValueChange = function () {
                    // Stop reporting value changes after the list has been destroyed. This avoids
                    // cases where the list might wrongly reset its value once it is removed, but
                    // the form control is still live.
                    if (this.options && !this._isDestroyed) {
                        /** @type {?} */
                        var value = this._getSelectedOptionValues();
                        this._onChange(value);
                        this._value = value;
                    }
                };
                /**
                 * Emits a change event if the selected state of an option changed.
                 * @param {?} option
                 * @return {?}
                 */
                MatSelectionList.prototype._emitChangeEvent = function (option) {
                    this.selectionChange.emit(new MatSelectionListChange(this, option));
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} values
                 * @return {?}
                 */
                MatSelectionList.prototype.writeValue = function (values) {
                    this._value = values;
                    if (this.options) {
                        this._setOptionsFromValues(values || []);
                    }
                };
                /**
                 * Implemented as a part of ControlValueAccessor.
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatSelectionList.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSelectionList.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSelectionList.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                /**
                 * Sets the selected options based on the specified values.
                 * @private
                 * @param {?} values
                 * @return {?}
                 */
                MatSelectionList.prototype._setOptionsFromValues = function (values) {
                    var _this = this;
                    this.options.forEach(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) { return option._setSelected(false); }));
                    values.forEach(( /**
                     * @param {?} value
                     * @return {?}
                     */function (/**
                     * @param {?} value
                     * @return {?}
                     */ value) {
                        /** @type {?} */
                        var correspondingOption = _this.options.find(( /**
                         * @param {?} option
                         * @return {?}
                         */function (/**
                         * @param {?} option
                         * @return {?}
                         */ option) {
                            // Skip options that are already in the model. This allows us to handle cases
                            // where the same primitive value is selected multiple times.
                            return option.selected ? false : _this.compareWith(option.value, value);
                        }));
                        if (correspondingOption) {
                            correspondingOption._setSelected(true);
                        }
                    }));
                };
                /**
                 * Returns the values of the selected options.
                 * @private
                 * @return {?}
                 */
                MatSelectionList.prototype._getSelectedOptionValues = function () {
                    return this.options.filter(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) { return option.selected; })).map(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) { return option.value; }));
                };
                /**
                 * Toggles the state of the currently focused option if enabled.
                 * @private
                 * @return {?}
                 */
                MatSelectionList.prototype._toggleFocusedOption = function () {
                    /** @type {?} */
                    var focusedIndex = this._keyManager.activeItemIndex;
                    if (focusedIndex != null && this._isValidIndex(focusedIndex)) {
                        /** @type {?} */
                        var focusedOption = this.options.toArray()[focusedIndex];
                        if (focusedOption && !focusedOption.disabled) {
                            focusedOption.toggle();
                            // Emit a change event because the focused option changed its state through user
                            // interaction.
                            this._emitChangeEvent(focusedOption);
                        }
                    }
                };
                /**
                 * Sets the selected state on all of the options
                 * and emits an event if anything changed.
                 * @private
                 * @param {?} isSelected
                 * @return {?}
                 */
                MatSelectionList.prototype._setAllOptionsSelected = function (isSelected) {
                    // Keep track of whether anything changed, because we only want to
                    // emit the changed event when something actually changed.
                    /** @type {?} */
                    var hasChanged = false;
                    this.options.forEach(( /**
                     * @param {?} option
                     * @return {?}
                     */function (/**
                     * @param {?} option
                     * @return {?}
                     */ option) {
                        if (option._setSelected(isSelected)) {
                            hasChanged = true;
                        }
                    }));
                    if (hasChanged) {
                        this._reportValueChange();
                    }
                };
                /**
                 * Utility to ensure all indexes are valid.
                 * @private
                 * @param {?} index The index to be checked.
                 * @return {?} True if the index is valid for our list of options.
                 */
                MatSelectionList.prototype._isValidIndex = function (index) {
                    return index >= 0 && index < this.options.length;
                };
                /**
                 * Returns the index of the specified list option.
                 * @private
                 * @param {?} option
                 * @return {?}
                 */
                MatSelectionList.prototype._getOptionIndex = function (option) {
                    return this.options.toArray().indexOf(option);
                };
                /**
                 * Marks all the options to be checked in the next change detection run.
                 * @private
                 * @return {?}
                 */
                MatSelectionList.prototype._markOptionsForCheck = function () {
                    if (this.options) {
                        this.options.forEach(( /**
                         * @param {?} option
                         * @return {?}
                         */function (/**
                         * @param {?} option
                         * @return {?}
                         */ option) { return option._markForCheck(); }));
                    }
                };
                return MatSelectionList;
            }(_MatSelectionListMixinBase));
            MatSelectionList.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-selection-list',
                            exportAs: 'matSelectionList',
                            inputs: ['disableRipple'],
                            host: {
                                'role': 'listbox',
                                '[tabIndex]': 'tabIndex',
                                'class': 'mat-selection-list mat-list-base',
                                '(blur)': '_onTouched()',
                                '(keydown)': '_keydown($event)',
                                'aria-multiselectable': 'true',
                                '[attr.aria-disabled]': 'disabled.toString()',
                            },
                            template: '<ng-content></ng-content>',
                            styles: [".mat-subheader{display:flex;box-sizing:border-box;padding:16px;align-items:center}.mat-list-base .mat-subheader{margin:0}.mat-list-base{padding-top:8px;display:block;-webkit-tap-highlight-color:transparent}.mat-list-base .mat-subheader{height:48px;line-height:16px}.mat-list-base .mat-subheader:first-child{margin-top:-8px}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{display:block;height:48px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base .mat-list-item .mat-list-item-content,.mat-list-base .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base .mat-list-item .mat-list-item-content-reverse,.mat-list-base .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base .mat-list-item .mat-list-item-ripple,.mat-list-base .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar,.mat-list-base .mat-list-option.mat-list-item-with-avatar{height:56px}.mat-list-base .mat-list-item.mat-2-line,.mat-list-base .mat-list-option.mat-2-line{height:72px}.mat-list-base .mat-list-item.mat-3-line,.mat-list-base .mat-list-option.mat-3-line{height:88px}.mat-list-base .mat-list-item.mat-multi-line,.mat-list-base .mat-list-option.mat-multi-line{height:auto}.mat-list-base .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base .mat-list-item .mat-list-text,.mat-list-base .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base .mat-list-item .mat-list-text>*,.mat-list-base .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base .mat-list-item .mat-list-text:empty,.mat-list-base .mat-list-option .mat-list-text:empty{display:none}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base .mat-list-item .mat-list-avatar,.mat-list-base .mat-list-option .mat-list-avatar{flex-shrink:0;width:40px;height:40px;border-radius:50%;object-fit:cover}.mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:72px;width:calc(100% - 72px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:72px}.mat-list-base .mat-list-item .mat-list-icon,.mat-list-base .mat-list-option .mat-list-icon{flex-shrink:0;width:24px;height:24px;font-size:24px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:64px;width:calc(100% - 64px)}[dir=rtl] .mat-list-base .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:64px}.mat-list-base .mat-list-item .mat-divider,.mat-list-base .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base .mat-list-item .mat-divider,[dir=rtl] .mat-list-base .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-list-base[dense]{padding-top:4px;display:block}.mat-list-base[dense] .mat-subheader{height:40px;line-height:8px}.mat-list-base[dense] .mat-subheader:first-child{margin-top:-4px}.mat-list-base[dense] .mat-list-item,.mat-list-base[dense] .mat-list-option{display:block;height:40px;-webkit-tap-highlight-color:transparent;width:100%;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-item-content,.mat-list-base[dense] .mat-list-option .mat-list-item-content{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;padding:0 16px;position:relative;height:inherit}.mat-list-base[dense] .mat-list-item .mat-list-item-content-reverse,.mat-list-base[dense] .mat-list-option .mat-list-item-content-reverse{display:flex;align-items:center;padding:0 16px;flex-direction:row-reverse;justify-content:space-around}.mat-list-base[dense] .mat-list-item .mat-list-item-ripple,.mat-list-base[dense] .mat-list-option .mat-list-item-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar{height:48px}.mat-list-base[dense] .mat-list-item.mat-2-line,.mat-list-base[dense] .mat-list-option.mat-2-line{height:60px}.mat-list-base[dense] .mat-list-item.mat-3-line,.mat-list-base[dense] .mat-list-option.mat-3-line{height:76px}.mat-list-base[dense] .mat-list-item.mat-multi-line,.mat-list-base[dense] .mat-list-option.mat-multi-line{height:auto}.mat-list-base[dense] .mat-list-item.mat-multi-line .mat-list-item-content,.mat-list-base[dense] .mat-list-option.mat-multi-line .mat-list-item-content{padding-top:16px;padding-bottom:16px}.mat-list-base[dense] .mat-list-item .mat-list-text,.mat-list-base[dense] .mat-list-option .mat-list-text{display:flex;flex-direction:column;width:100%;box-sizing:border-box;overflow:hidden;padding:0}.mat-list-base[dense] .mat-list-item .mat-list-text>*,.mat-list-base[dense] .mat-list-option .mat-list-text>*{margin:0;padding:0;font-weight:400;font-size:inherit}.mat-list-base[dense] .mat-list-item .mat-list-text:empty,.mat-list-base[dense] .mat-list-option .mat-list-text:empty{display:none}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:0;padding-left:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content .mat-list-text{padding-right:16px;padding-left:0}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-left:0;padding-right:16px}[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-item.mat-list-option .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar .mat-list-item-content-reverse .mat-list-text,[dir=rtl] .mat-list-base[dense] .mat-list-option.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:0;padding-left:16px}.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-item.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content .mat-list-text,.mat-list-base[dense] .mat-list-option.mat-list-item-with-avatar.mat-list-option .mat-list-item-content-reverse .mat-list-text{padding-right:16px;padding-left:16px}.mat-list-base[dense] .mat-list-item .mat-list-avatar,.mat-list-base[dense] .mat-list-option .mat-list-avatar{flex-shrink:0;width:36px;height:36px;border-radius:50%;object-fit:cover}.mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:68px;width:calc(100% - 68px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-avatar~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-avatar~.mat-divider-inset{margin-left:auto;margin-right:68px}.mat-list-base[dense] .mat-list-item .mat-list-icon,.mat-list-base[dense] .mat-list-option .mat-list-icon{flex-shrink:0;width:20px;height:20px;font-size:20px;box-sizing:content-box;border-radius:50%;padding:4px}.mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:60px;width:calc(100% - 60px)}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-list-icon~.mat-divider-inset,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-list-icon~.mat-divider-inset{margin-left:auto;margin-right:60px}.mat-list-base[dense] .mat-list-item .mat-divider,.mat-list-base[dense] .mat-list-option .mat-divider{position:absolute;bottom:0;left:0;width:100%;margin:0}[dir=rtl] .mat-list-base[dense] .mat-list-item .mat-divider,[dir=rtl] .mat-list-base[dense] .mat-list-option .mat-divider{margin-left:auto;margin-right:0}.mat-list-base[dense] .mat-list-item .mat-divider.mat-divider-inset,.mat-list-base[dense] .mat-list-option .mat-divider.mat-divider-inset{position:absolute}.mat-nav-list a{text-decoration:none;color:inherit}.mat-nav-list .mat-list-item{cursor:pointer;outline:0}mat-action-list button{background:0 0;color:inherit;border:none;font:inherit;outline:inherit;-webkit-tap-highlight-color:transparent;text-align:left}[dir=rtl] mat-action-list button{text-align:right}mat-action-list button::-moz-focus-inner{border:0}mat-action-list .mat-list-item{cursor:pointer;outline:inherit}.mat-list-option:not(.mat-list-item-disabled){cursor:pointer;outline:0}@media (-ms-high-contrast:active){.mat-selection-list:focus{outline-style:dotted}.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover,mat-action-list .mat-list-item:focus,mat-action-list .mat-list-item:hover{outline:dotted 1px}}@media (hover:none){.mat-action-list .mat-list-item:not(.mat-list-item-disabled):hover,.mat-list-option:not(.mat-list-item-disabled):hover,.mat-nav-list .mat-list-item:not(.mat-list-item-disabled):hover{background:0 0}}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            providers: [MAT_SELECTION_LIST_VALUE_ACCESSOR],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush
                        },] },
            ];
            /** @nocollapse */
            MatSelectionList.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] }
            ]; };
            MatSelectionList.propDecorators = {
                options: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatListOption, { descendants: true },] }],
                selectionChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                compareWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatListModule = /** @class */ (function () {
                function MatListModule() {
                }
                return MatListModule;
            }());
            MatListModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLineModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatCommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatPseudoCheckboxModule"], _angular_common__WEBPACK_IMPORTED_MODULE_9__["CommonModule"]],
                            exports: [
                                MatList,
                                MatNavList,
                                MatListItem,
                                MatListAvatarCssMatStyler,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatLineModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatCommonModule"],
                                MatListIconCssMatStyler,
                                MatListSubheaderCssMatStyler,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_1__["MatPseudoCheckboxModule"],
                                MatSelectionList,
                                MatListOption,
                                _angular_material_divider__WEBPACK_IMPORTED_MODULE_10__["MatDividerModule"]
                            ],
                            declarations: [
                                MatList,
                                MatNavList,
                                MatListItem,
                                MatListAvatarCssMatStyler,
                                MatListIconCssMatStyler,
                                MatListSubheaderCssMatStyler,
                                MatSelectionList,
                                MatListOption
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=list.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/material.js": 
        /*!************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/material.js ***!
          \************************************************************/
        /*! exports provided: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MatAutocompleteSelectedEvent, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MatAutocomplete, MatAutocompleteModule, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, getMatAutocompleteMissingPanelError, AUTOCOMPLETE_OPTION_HEIGHT, AUTOCOMPLETE_PANEL_HEIGHT, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocompleteTrigger, MatAutocompleteOrigin, MatBadgeModule, MatBadge, MatBottomSheetModule, MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, MatBottomSheet, MAT_BOTTOM_SHEET_DATA, MatBottomSheetConfig, MatBottomSheetContainer, matBottomSheetAnimations, MatBottomSheetRef, MatButtonModule, MatButton, MatAnchor, MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS, MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR, MatButtonToggleGroupMultiple, MatButtonToggleChange, MatButtonToggleGroup, MatButtonToggle, MatButtonToggleModule, MatCardContent, MatCardTitle, MatCardSubtitle, MatCardActions, MatCardFooter, MatCardImage, MatCardSmImage, MatCardMdImage, MatCardLgImage, MatCardXlImage, MatCardAvatar, MatCard, MatCardHeader, MatCardTitleGroup, MatCardModule, MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, TransitionCheckState, MatCheckboxChange, MatCheckbox, MAT_CHECKBOX_CLICK_ACTION, _MatCheckboxRequiredValidatorModule, MatCheckboxModule, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckboxRequiredValidator, MatChipsModule, MatChipListChange, MatChipList, MatChipSelectionChange, MatChipAvatar, MatChipTrailingIcon, MatChip, MatChipRemove, MatChipInput, MAT_CHIPS_DEFAULT_OPTIONS, ɵa1, VERSION, AnimationCurves, AnimationDurations, MatCommonModule, MATERIAL_SANITY_CHECKS, mixinDisabled, mixinColor, mixinDisableRipple, mixinTabIndex, mixinErrorState, mixinInitialized, NativeDateModule, MatNativeDateModule, MAT_DATE_LOCALE_FACTORY, MAT_DATE_LOCALE, MAT_DATE_LOCALE_PROVIDER, DateAdapter, MAT_DATE_FORMATS, NativeDateAdapter, MAT_NATIVE_DATE_FORMATS, ShowOnDirtyErrorStateMatcher, ErrorStateMatcher, MAT_HAMMER_OPTIONS, GestureConfig, setLines, MatLine, MatLineSetter, MatLineModule, MatOptionModule, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionSelectionChange, MAT_OPTION_PARENT_COMPONENT, MatOption, MatOptgroup, MAT_LABEL_GLOBAL_OPTIONS, MatRippleModule, MAT_RIPPLE_GLOBAL_OPTIONS, MatRipple, RippleState, RippleRef, defaultRippleAnimationConfig, RippleRenderer, MatPseudoCheckboxModule, MatPseudoCheckbox, JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC, MatMultiYearView, yearsPerPage, yearsPerRow, MatDatepickerModule, MatCalendarHeader, MatCalendar, MatCalendarCell, MatCalendarBody, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER, MatDatepickerContent, MatDatepicker, matDatepickerAnimations, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, MatDatepickerInputEvent, MatDatepickerInput, MatDatepickerIntl, MatDatepickerToggleIcon, MatDatepickerToggle, MatMonthView, MatYearView, MatDialogModule, MAT_DIALOG_SCROLL_STRATEGY_FACTORY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_DIALOG_DATA, MAT_DIALOG_DEFAULT_OPTIONS, MAT_DIALOG_SCROLL_STRATEGY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER, MatDialog, throwMatDialogContentAlreadyAttachedError, MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogContent, MatDialogActions, MatDialogConfig, MatDialogRef, matDialogAnimations, MatDivider, MatDividerModule, MatExpansionModule, MatAccordion, MAT_ACCORDION, MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelDescription, MatExpansionPanelTitle, MatExpansionPanelContent, EXPANSION_PANEL_ANIMATION_TIMING, matExpansionAnimations, MatFormFieldModule, MatError, MAT_FORM_FIELD_DEFAULT_OPTIONS, MatFormField, MatFormFieldControl, getMatFormFieldPlaceholderConflictError, getMatFormFieldDuplicatedHintError, getMatFormFieldMissingControlError, MatHint, MatPlaceholder, MatPrefix, MatSuffix, MatLabel, matFormFieldAnimations, ɵa11, MatGridListModule, MatGridList, MatGridTile, MatGridTileText, MatGridAvatarCssMatStyler, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, MatIconModule, MAT_ICON_LOCATION_FACTORY, MAT_ICON_LOCATION, MatIcon, getMatIconNameNotFoundError, getMatIconNoHttpProviderError, getMatIconFailedToSanitizeUrlError, getMatIconFailedToSanitizeLiteralError, ICON_REGISTRY_PROVIDER_FACTORY, MatIconRegistry, ICON_REGISTRY_PROVIDER, MatTextareaAutosize, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR, MatListModule, MatNavList, MatList, MatListAvatarCssMatStyler, MatListIconCssMatStyler, MatListSubheaderCssMatStyler, MatListItem, MAT_SELECTION_LIST_VALUE_ACCESSOR, MatSelectionListChange, MatListOption, MatSelectionList, ɵa22, ɵb22, ɵc22, MatMenu, MAT_MENU_DEFAULT_OPTIONS, _MatMenu, _MatMenuBase, MatMenuItem, MatMenuTrigger, MAT_MENU_SCROLL_STRATEGY, MAT_MENU_PANEL, _MatMenuDirectivesModule, MatMenuModule, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MatPaginatorModule, PageEvent, MatPaginator, MAT_PAGINATOR_INTL_PROVIDER_FACTORY, MatPaginatorIntl, MAT_PAGINATOR_INTL_PROVIDER, MatProgressBarModule, MAT_PROGRESS_BAR_LOCATION_FACTORY, MAT_PROGRESS_BAR_LOCATION, MatProgressBar, MatProgressSpinner, MatSpinner, MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS, MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY, MatProgressSpinnerModule, MatRadioModule, MAT_RADIO_DEFAULT_OPTIONS_FACTORY, MAT_RADIO_DEFAULT_OPTIONS, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioChange, MatRadioGroup, MatRadioButton, MatSelectModule, MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY, SELECT_PANEL_MAX_HEIGHT, SELECT_PANEL_PADDING_X, SELECT_PANEL_INDENT_PADDING_X, SELECT_ITEM_HEIGHT_EM, SELECT_MULTIPLE_PANEL_PADDING_X, SELECT_PANEL_VIEWPORT_PADDING, MAT_SELECT_SCROLL_STRATEGY, MAT_SELECT_SCROLL_STRATEGY_PROVIDER, MatSelectChange, MatSelectTrigger, MatSelect, matSelectAnimations, transformPanel, fadeInContent, MatSidenavModule, throwMatDuplicatedDrawerError, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MAT_DRAWER_DEFAULT_AUTOSIZE, MatDrawerContent, MatDrawer, MatDrawerContainer, MatSidenavContent, MatSidenav, MatSidenavContainer, matDrawerAnimations, _MatSlideToggleRequiredValidatorModule, MatSlideToggleModule, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggleChange, MatSlideToggle, MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS, MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR, MatSlideToggleRequiredValidator, MatSliderModule, MAT_SLIDER_VALUE_ACCESSOR, MatSliderChange, MatSlider, MatSnackBarModule, MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY, MAT_SNACK_BAR_DEFAULT_OPTIONS, MatSnackBar, MatSnackBarContainer, MAT_SNACK_BAR_DATA, MatSnackBarConfig, MatSnackBarRef, SimpleSnackBar, matSnackBarAnimations, MatSortModule, MatSortHeader, MAT_SORT_HEADER_INTL_PROVIDER_FACTORY, MatSortHeaderIntl, MAT_SORT_HEADER_INTL_PROVIDER, MatSort, matSortAnimations, MatStepperModule, MatStepLabel, MatStep, MatStepper, MatHorizontalStepper, MatVerticalStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MAT_STEPPER_INTL_PROVIDER_FACTORY, MatStepperIntl, MAT_STEPPER_INTL_PROVIDER, matStepperAnimations, MatStepperIcon, MatTableModule, MatCellDef, MatHeaderCellDef, MatFooterCellDef, MatColumnDef, MatHeaderCell, MatFooterCell, MatCell, MatTable, MatHeaderRowDef, MatFooterRowDef, MatRowDef, MatHeaderRow, MatFooterRow, MatRow, MatTableDataSource, MatTextColumn, ɵa24, ɵb24, MatTabsModule, MatInkBar, _MAT_INK_BAR_POSITIONER, MatTabBody, _MatTabBodyBase, MatTabBodyPortal, MatTabHeader, _MatTabHeaderBase, MatTabLabelWrapper, MatTab, MatTabLabel, MatTabNav, MatTabLink, _MatTabNavBase, _MatTabLinkBase, MatTabContent, MatTabChangeEvent, MAT_TABS_CONFIG, _MatTabGroupBase, MatTabGroup, matTabsAnimations, MatToolbarModule, throwToolbarMixedModesError, MatToolbarRow, MatToolbar, MatTooltipModule, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY, MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_TOOLTIP_DEFAULT_OPTIONS, MatTooltip, TooltipComponent, matTooltipAnimations, MatTreeNode, MatTreeNodeDef, MatNestedTreeNode, MatTreeNodePadding, MatTree, MatTreeModule, MatTreeNodeToggle, MatTreeNodeOutlet, MatTreeFlattener, MatTreeFlatDataSource, MatTreeNestedDataSource */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony import */ var _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/material/autocomplete */ "./node_modules/@angular/material/esm2015/autocomplete.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteSelectedEvent", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MatAutocompleteSelectedEvent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_DEFAULT_OPTIONS", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MAT_AUTOCOMPLETE_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatAutocomplete", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MatAutocomplete"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteModule", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MatAutocompleteModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatAutocompleteMissingPanelError", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["getMatAutocompleteMissingPanelError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_OPTION_HEIGHT", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["AUTOCOMPLETE_OPTION_HEIGHT"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_PANEL_HEIGHT", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["AUTOCOMPLETE_PANEL_HEIGHT"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MAT_AUTOCOMPLETE_SCROLL_STRATEGY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_AUTOCOMPLETE_VALUE_ACCESSOR", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MAT_AUTOCOMPLETE_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteTrigger", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MatAutocompleteTrigger"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatAutocompleteOrigin", function () { return _angular_material_autocomplete__WEBPACK_IMPORTED_MODULE_0__["MatAutocompleteOrigin"]; });
            /* harmony import */ var _angular_material_badge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/material/badge */ "./node_modules/@angular/material/esm2015/badge.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatBadgeModule", function () { return _angular_material_badge__WEBPACK_IMPORTED_MODULE_1__["MatBadgeModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatBadge", function () { return _angular_material_badge__WEBPACK_IMPORTED_MODULE_1__["MatBadge"]; });
            /* harmony import */ var _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/bottom-sheet */ "./node_modules/@angular/material/esm2015/bottom-sheet.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetModule", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["MatBottomSheetModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_BOTTOM_SHEET_DEFAULT_OPTIONS", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["MAT_BOTTOM_SHEET_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheet", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["MatBottomSheet"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_BOTTOM_SHEET_DATA", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["MAT_BOTTOM_SHEET_DATA"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetConfig", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["MatBottomSheetConfig"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetContainer", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["MatBottomSheetContainer"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matBottomSheetAnimations", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["matBottomSheetAnimations"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatBottomSheetRef", function () { return _angular_material_bottom_sheet__WEBPACK_IMPORTED_MODULE_2__["MatBottomSheetRef"]; });
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatButtonModule", function () { return _angular_material_button__WEBPACK_IMPORTED_MODULE_3__["MatButtonModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatButton", function () { return _angular_material_button__WEBPACK_IMPORTED_MODULE_3__["MatButton"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatAnchor", function () { return _angular_material_button__WEBPACK_IMPORTED_MODULE_3__["MatAnchor"]; });
            /* harmony import */ var _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material/button-toggle */ "./node_modules/@angular/material/esm2015/button-toggle.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS", function () { return _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__["MAT_BUTTON_TOGGLE_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR", function () { return _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__["MAT_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroupMultiple", function () { return _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__["MatButtonToggleGroupMultiple"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleChange", function () { return _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__["MatButtonToggleChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleGroup", function () { return _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__["MatButtonToggleGroup"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggle", function () { return _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__["MatButtonToggle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatButtonToggleModule", function () { return _angular_material_button_toggle__WEBPACK_IMPORTED_MODULE_4__["MatButtonToggleModule"]; });
            /* harmony import */ var _angular_material_card__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/card */ "./node_modules/@angular/material/esm2015/card.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardContent", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardContent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardTitle", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardTitle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardSubtitle", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardSubtitle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardActions", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardActions"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardFooter", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardFooter"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardImage", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardImage"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardSmImage", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardSmImage"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardMdImage", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardMdImage"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardLgImage", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardLgImage"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardXlImage", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardXlImage"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardAvatar", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardAvatar"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCard", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCard"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardHeader", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardHeader"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardTitleGroup", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardTitleGroup"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCardModule", function () { return _angular_material_card__WEBPACK_IMPORTED_MODULE_5__["MatCardModule"]; });
            /* harmony import */ var _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/checkbox */ "./node_modules/@angular/material/esm2015/checkbox.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransitionCheckState", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["TransitionCheckState"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxChange", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["MatCheckboxChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCheckbox", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["MatCheckbox"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_CLICK_ACTION", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["MAT_CHECKBOX_CLICK_ACTION"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatCheckboxRequiredValidatorModule", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["_MatCheckboxRequiredValidatorModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxModule", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["MatCheckboxModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_CHECKBOX_REQUIRED_VALIDATOR", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["MAT_CHECKBOX_REQUIRED_VALIDATOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCheckboxRequiredValidator", function () { return _angular_material_checkbox__WEBPACK_IMPORTED_MODULE_6__["MatCheckboxRequiredValidator"]; });
            /* harmony import */ var _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/chips */ "./node_modules/@angular/material/esm2015/chips.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipsModule", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipsModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipListChange", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipListChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipList", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipList"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipSelectionChange", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipSelectionChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipAvatar", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipAvatar"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipTrailingIcon", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipTrailingIcon"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChip", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChip"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipRemove", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipRemove"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatChipInput", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MatChipInput"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_CHIPS_DEFAULT_OPTIONS", function () { return _angular_material_chips__WEBPACK_IMPORTED_MODULE_7__["MAT_CHIPS_DEFAULT_OPTIONS"]; });
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵa1", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["ɵa1"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["VERSION"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationCurves", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["AnimationCurves"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationDurations", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["AnimationDurations"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCommonModule", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatCommonModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MATERIAL_SANITY_CHECKS", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MATERIAL_SANITY_CHECKS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixinDisabled", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["mixinDisabled"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixinColor", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["mixinColor"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixinDisableRipple", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["mixinDisableRipple"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixinTabIndex", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["mixinTabIndex"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixinErrorState", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["mixinErrorState"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mixinInitialized", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["mixinInitialized"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NativeDateModule", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["NativeDateModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatNativeDateModule", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatNativeDateModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATE_LOCALE_FACTORY", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_LOCALE_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATE_LOCALE", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_LOCALE"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATE_LOCALE_PROVIDER", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_LOCALE_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DateAdapter", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DateAdapter"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATE_FORMATS", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_DATE_FORMATS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NativeDateAdapter", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["NativeDateAdapter"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_NATIVE_DATE_FORMATS", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_NATIVE_DATE_FORMATS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShowOnDirtyErrorStateMatcher", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["ShowOnDirtyErrorStateMatcher"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorStateMatcher", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["ErrorStateMatcher"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_HAMMER_OPTIONS", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_HAMMER_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GestureConfig", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["GestureConfig"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setLines", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["setLines"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatLine", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatLine"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatLineSetter", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatLineSetter"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatLineModule", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatLineModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatOptionModule", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatOptionModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_countGroupLabelsBeforeOption", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["_countGroupLabelsBeforeOption"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getOptionScrollPosition", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["_getOptionScrollPosition"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatOptionSelectionChange", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatOptionSelectionChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_OPTION_PARENT_COMPONENT", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_OPTION_PARENT_COMPONENT"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatOption", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatOption"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatOptgroup", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatOptgroup"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_LABEL_GLOBAL_OPTIONS", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_LABEL_GLOBAL_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRippleModule", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatRippleModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_RIPPLE_GLOBAL_OPTIONS", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAT_RIPPLE_GLOBAL_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRipple", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatRipple"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RippleState", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["RippleState"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RippleRef", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["RippleRef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultRippleAnimationConfig", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["defaultRippleAnimationConfig"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RippleRenderer", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["RippleRenderer"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatPseudoCheckboxModule", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatPseudoCheckboxModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatPseudoCheckbox", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MatPseudoCheckbox"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JAN", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["JAN"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FEB", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["FEB"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAR", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "APR", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["APR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAY", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["MAY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JUN", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["JUN"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JUL", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["JUL"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AUG", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["AUG"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SEP", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["SEP"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OCT", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["OCT"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NOV", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["NOV"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DEC", function () { return _angular_material_core__WEBPACK_IMPORTED_MODULE_8__["DEC"]; });
            /* harmony import */ var _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/material/datepicker */ "./node_modules/@angular/material/esm2015/datepicker.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatMultiYearView", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatMultiYearView"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "yearsPerPage", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["yearsPerPage"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "yearsPerRow", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["yearsPerRow"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerModule", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepickerModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCalendarHeader", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatCalendarHeader"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCalendar", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatCalendar"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCalendarCell", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatCalendarCell"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCalendarBody", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatCalendarBody"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MAT_DATEPICKER_SCROLL_STRATEGY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerContent", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepickerContent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepicker", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepicker"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matDatepickerAnimations", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["matDatepickerAnimations"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALUE_ACCESSOR", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MAT_DATEPICKER_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DATEPICKER_VALIDATORS", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MAT_DATEPICKER_VALIDATORS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInputEvent", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepickerInputEvent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerInput", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepickerInput"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerIntl", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepickerIntl"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggleIcon", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepickerToggleIcon"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDatepickerToggle", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatDatepickerToggle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatMonthView", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatMonthView"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatYearView", function () { return _angular_material_datepicker__WEBPACK_IMPORTED_MODULE_9__["MatYearView"]; });
            /* harmony import */ var _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/dialog */ "./node_modules/@angular/material/esm2015/dialog.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogModule", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_FACTORY", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MAT_DIALOG_SCROLL_STRATEGY_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_DATA", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MAT_DIALOG_DATA"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_DEFAULT_OPTIONS", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MAT_DIALOG_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MAT_DIALOG_SCROLL_STRATEGY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DIALOG_SCROLL_STRATEGY_PROVIDER", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MAT_DIALOG_SCROLL_STRATEGY_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialog", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialog"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throwMatDialogContentAlreadyAttachedError", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["throwMatDialogContentAlreadyAttachedError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogContainer", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogContainer"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogClose", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogClose"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogTitle", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogTitle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogContent", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogContent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogActions", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogActions"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogConfig", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogConfig"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDialogRef", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["MatDialogRef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matDialogAnimations", function () { return _angular_material_dialog__WEBPACK_IMPORTED_MODULE_10__["matDialogAnimations"]; });
            /* harmony import */ var _angular_material_divider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/divider */ "./node_modules/@angular/material/esm2015/divider.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDivider", function () { return _angular_material_divider__WEBPACK_IMPORTED_MODULE_11__["MatDivider"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDividerModule", function () { return _angular_material_divider__WEBPACK_IMPORTED_MODULE_11__["MatDividerModule"]; });
            /* harmony import */ var _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/expansion */ "./node_modules/@angular/material/esm2015/expansion.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatExpansionModule", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatExpansionModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatAccordion", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatAccordion"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_ACCORDION", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MAT_ACCORDION"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_EXPANSION_PANEL_DEFAULT_OPTIONS", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MAT_EXPANSION_PANEL_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanel", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatExpansionPanel"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelActionRow", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatExpansionPanelActionRow"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelHeader", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatExpansionPanelHeader"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelDescription", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatExpansionPanelDescription"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelTitle", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatExpansionPanelTitle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatExpansionPanelContent", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["MatExpansionPanelContent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EXPANSION_PANEL_ANIMATION_TIMING", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["EXPANSION_PANEL_ANIMATION_TIMING"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matExpansionAnimations", function () { return _angular_material_expansion__WEBPACK_IMPORTED_MODULE_12__["matExpansionAnimations"]; });
            /* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/material/form-field */ "./node_modules/@angular/material/esm2015/form-field.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatFormFieldModule", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatFormFieldModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatError", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_FORM_FIELD_DEFAULT_OPTIONS", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MAT_FORM_FIELD_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatFormField", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatFormField"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatFormFieldControl", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatFormFieldControl"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatFormFieldPlaceholderConflictError", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["getMatFormFieldPlaceholderConflictError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatFormFieldDuplicatedHintError", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["getMatFormFieldDuplicatedHintError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatFormFieldMissingControlError", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["getMatFormFieldMissingControlError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatHint", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatHint"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatPlaceholder", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatPlaceholder"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatPrefix", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatPrefix"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSuffix", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatSuffix"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatLabel", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["MatLabel"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matFormFieldAnimations", function () { return _angular_material_form_field__WEBPACK_IMPORTED_MODULE_13__["matFormFieldAnimations"]; });
            /* harmony import */ var _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/material/grid-list */ "./node_modules/@angular/material/esm2015/grid-list.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵa11", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["ɵa11"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatGridListModule", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["MatGridListModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatGridList", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["MatGridList"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatGridTile", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["MatGridTile"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatGridTileText", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["MatGridTileText"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatGridAvatarCssMatStyler", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["MatGridAvatarCssMatStyler"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatGridTileHeaderCssMatStyler", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["MatGridTileHeaderCssMatStyler"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatGridTileFooterCssMatStyler", function () { return _angular_material_grid_list__WEBPACK_IMPORTED_MODULE_14__["MatGridTileFooterCssMatStyler"]; });
            /* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatIconModule", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["MatIconModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_ICON_LOCATION_FACTORY", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["MAT_ICON_LOCATION_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_ICON_LOCATION", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["MAT_ICON_LOCATION"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatIcon", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["MatIcon"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatIconNameNotFoundError", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["getMatIconNameNotFoundError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatIconNoHttpProviderError", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["getMatIconNoHttpProviderError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatIconFailedToSanitizeUrlError", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["getMatIconFailedToSanitizeUrlError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatIconFailedToSanitizeLiteralError", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["getMatIconFailedToSanitizeLiteralError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ICON_REGISTRY_PROVIDER_FACTORY", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["ICON_REGISTRY_PROVIDER_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatIconRegistry", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["MatIconRegistry"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ICON_REGISTRY_PROVIDER", function () { return _angular_material_icon__WEBPACK_IMPORTED_MODULE_15__["ICON_REGISTRY_PROVIDER"]; });
            /* harmony import */ var _angular_material_input__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/material/input */ "./node_modules/@angular/material/esm2015/input.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTextareaAutosize", function () { return _angular_material_input__WEBPACK_IMPORTED_MODULE_16__["MatTextareaAutosize"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatInput", function () { return _angular_material_input__WEBPACK_IMPORTED_MODULE_16__["MatInput"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatInputUnsupportedTypeError", function () { return _angular_material_input__WEBPACK_IMPORTED_MODULE_16__["getMatInputUnsupportedTypeError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatInputModule", function () { return _angular_material_input__WEBPACK_IMPORTED_MODULE_16__["MatInputModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_INPUT_VALUE_ACCESSOR", function () { return _angular_material_input__WEBPACK_IMPORTED_MODULE_16__["MAT_INPUT_VALUE_ACCESSOR"]; });
            /* harmony import */ var _angular_material_list__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @angular/material/list */ "./node_modules/@angular/material/esm2015/list.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatListModule", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatListModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatNavList", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatNavList"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatList", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatList"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatListAvatarCssMatStyler", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatListAvatarCssMatStyler"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatListIconCssMatStyler", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatListIconCssMatStyler"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatListSubheaderCssMatStyler", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatListSubheaderCssMatStyler"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatListItem", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatListItem"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECTION_LIST_VALUE_ACCESSOR", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MAT_SELECTION_LIST_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSelectionListChange", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatSelectionListChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatListOption", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatListOption"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSelectionList", function () { return _angular_material_list__WEBPACK_IMPORTED_MODULE_17__["MatSelectionList"]; });
            /* harmony import */ var _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @angular/material/menu */ "./node_modules/@angular/material/esm2015/menu.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵa22", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["ɵa22"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵb22", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["ɵb22"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵc22", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["ɵc22"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatMenu", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MatMenu"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_DEFAULT_OPTIONS", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MAT_MENU_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatMenu", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["_MatMenu"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatMenuBase", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["_MatMenuBase"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatMenuItem", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MatMenuItem"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatMenuTrigger", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MatMenuTrigger"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_SCROLL_STRATEGY", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MAT_MENU_SCROLL_STRATEGY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_PANEL", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MAT_MENU_PANEL"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatMenuDirectivesModule", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["_MatMenuDirectivesModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatMenuModule", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MatMenuModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matMenuAnimations", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["matMenuAnimations"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fadeInItems", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["fadeInItems"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformMenu", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["transformMenu"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatMenuContent", function () { return _angular_material_menu__WEBPACK_IMPORTED_MODULE_18__["MatMenuContent"]; });
            /* harmony import */ var _angular_material_paginator__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @angular/material/paginator */ "./node_modules/@angular/material/esm2015/paginator.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatPaginatorModule", function () { return _angular_material_paginator__WEBPACK_IMPORTED_MODULE_19__["MatPaginatorModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PageEvent", function () { return _angular_material_paginator__WEBPACK_IMPORTED_MODULE_19__["PageEvent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatPaginator", function () { return _angular_material_paginator__WEBPACK_IMPORTED_MODULE_19__["MatPaginator"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_PAGINATOR_INTL_PROVIDER_FACTORY", function () { return _angular_material_paginator__WEBPACK_IMPORTED_MODULE_19__["MAT_PAGINATOR_INTL_PROVIDER_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatPaginatorIntl", function () { return _angular_material_paginator__WEBPACK_IMPORTED_MODULE_19__["MatPaginatorIntl"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_PAGINATOR_INTL_PROVIDER", function () { return _angular_material_paginator__WEBPACK_IMPORTED_MODULE_19__["MAT_PAGINATOR_INTL_PROVIDER"]; });
            /* harmony import */ var _angular_material_progress_bar__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @angular/material/progress-bar */ "./node_modules/@angular/material/esm2015/progress-bar.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatProgressBarModule", function () { return _angular_material_progress_bar__WEBPACK_IMPORTED_MODULE_20__["MatProgressBarModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_BAR_LOCATION_FACTORY", function () { return _angular_material_progress_bar__WEBPACK_IMPORTED_MODULE_20__["MAT_PROGRESS_BAR_LOCATION_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_BAR_LOCATION", function () { return _angular_material_progress_bar__WEBPACK_IMPORTED_MODULE_20__["MAT_PROGRESS_BAR_LOCATION"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatProgressBar", function () { return _angular_material_progress_bar__WEBPACK_IMPORTED_MODULE_20__["MatProgressBar"]; });
            /* harmony import */ var _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @angular/material/progress-spinner */ "./node_modules/@angular/material/esm2015/progress-spinner.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatProgressSpinner", function () { return _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_21__["MatProgressSpinner"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSpinner", function () { return _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_21__["MatSpinner"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS", function () { return _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_21__["MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY", function () { return _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_21__["MAT_PROGRESS_SPINNER_DEFAULT_OPTIONS_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatProgressSpinnerModule", function () { return _angular_material_progress_spinner__WEBPACK_IMPORTED_MODULE_21__["MatProgressSpinnerModule"]; });
            /* harmony import */ var _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @angular/material/radio */ "./node_modules/@angular/material/esm2015/radio.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRadioModule", function () { return _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__["MatRadioModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS_FACTORY", function () { return _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__["MAT_RADIO_DEFAULT_OPTIONS_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS", function () { return _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__["MAT_RADIO_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR", function () { return _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__["MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRadioChange", function () { return _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__["MatRadioChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRadioGroup", function () { return _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__["MatRadioGroup"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRadioButton", function () { return _angular_material_radio__WEBPACK_IMPORTED_MODULE_22__["MatRadioButton"]; });
            /* harmony import */ var _angular_material_select__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @angular/material/select */ "./node_modules/@angular/material/esm2015/select.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSelectModule", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["MatSelectModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_MAX_HEIGHT", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["SELECT_PANEL_MAX_HEIGHT"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_PADDING_X", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["SELECT_PANEL_PADDING_X"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_INDENT_PADDING_X", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["SELECT_PANEL_INDENT_PADDING_X"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SELECT_ITEM_HEIGHT_EM", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["SELECT_ITEM_HEIGHT_EM"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SELECT_MULTIPLE_PANEL_PADDING_X", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["SELECT_MULTIPLE_PANEL_PADDING_X"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SELECT_PANEL_VIEWPORT_PADDING", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["SELECT_PANEL_VIEWPORT_PADDING"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECT_SCROLL_STRATEGY", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["MAT_SELECT_SCROLL_STRATEGY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SELECT_SCROLL_STRATEGY_PROVIDER", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["MAT_SELECT_SCROLL_STRATEGY_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSelectChange", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["MatSelectChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSelectTrigger", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["MatSelectTrigger"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSelect", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["MatSelect"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matSelectAnimations", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["matSelectAnimations"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformPanel", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["transformPanel"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fadeInContent", function () { return _angular_material_select__WEBPACK_IMPORTED_MODULE_23__["fadeInContent"]; });
            /* harmony import */ var _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @angular/material/sidenav */ "./node_modules/@angular/material/esm2015/sidenav.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSidenavModule", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MatSidenavModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throwMatDuplicatedDrawerError", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["throwMatDuplicatedDrawerError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_DRAWER_DEFAULT_AUTOSIZE", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MAT_DRAWER_DEFAULT_AUTOSIZE"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDrawerContent", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MatDrawerContent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDrawer", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MatDrawer"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatDrawerContainer", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MatDrawerContainer"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSidenavContent", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MatSidenavContent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSidenav", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MatSidenav"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSidenavContainer", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["MatSidenavContainer"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matDrawerAnimations", function () { return _angular_material_sidenav__WEBPACK_IMPORTED_MODULE_24__["matDrawerAnimations"]; });
            /* harmony import */ var _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @angular/material/slide-toggle */ "./node_modules/@angular/material/esm2015/slide-toggle.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatSlideToggleRequiredValidatorModule", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["_MatSlideToggleRequiredValidatorModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleModule", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["MatSlideToggleModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_VALUE_ACCESSOR", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["MAT_SLIDE_TOGGLE_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleChange", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["MatSlideToggleChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggle", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["MatSlideToggle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleRequiredValidator", function () { return _angular_material_slide_toggle__WEBPACK_IMPORTED_MODULE_25__["MatSlideToggleRequiredValidator"]; });
            /* harmony import */ var _angular_material_slider__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @angular/material/slider */ "./node_modules/@angular/material/esm2015/slider.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSliderModule", function () { return _angular_material_slider__WEBPACK_IMPORTED_MODULE_26__["MatSliderModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDER_VALUE_ACCESSOR", function () { return _angular_material_slider__WEBPACK_IMPORTED_MODULE_26__["MAT_SLIDER_VALUE_ACCESSOR"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSliderChange", function () { return _angular_material_slider__WEBPACK_IMPORTED_MODULE_26__["MatSliderChange"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSlider", function () { return _angular_material_slider__WEBPACK_IMPORTED_MODULE_26__["MatSlider"]; });
            /* harmony import */ var _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @angular/material/snack-bar */ "./node_modules/@angular/material/esm2015/snack-bar.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarModule", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MatSnackBarModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DEFAULT_OPTIONS", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MAT_SNACK_BAR_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSnackBar", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MatSnackBar"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarContainer", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MatSnackBarContainer"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DATA", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MAT_SNACK_BAR_DATA"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarConfig", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MatSnackBarConfig"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarRef", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["MatSnackBarRef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SimpleSnackBar", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["SimpleSnackBar"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matSnackBarAnimations", function () { return _angular_material_snack_bar__WEBPACK_IMPORTED_MODULE_27__["matSnackBarAnimations"]; });
            /* harmony import */ var _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @angular/material/sort */ "./node_modules/@angular/material/esm2015/sort.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSortModule", function () { return _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__["MatSortModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSortHeader", function () { return _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__["MatSortHeader"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SORT_HEADER_INTL_PROVIDER_FACTORY", function () { return _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__["MAT_SORT_HEADER_INTL_PROVIDER_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSortHeaderIntl", function () { return _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__["MatSortHeaderIntl"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_SORT_HEADER_INTL_PROVIDER", function () { return _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__["MAT_SORT_HEADER_INTL_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatSort", function () { return _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__["MatSort"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matSortAnimations", function () { return _angular_material_sort__WEBPACK_IMPORTED_MODULE_28__["matSortAnimations"]; });
            /* harmony import */ var _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @angular/material/stepper */ "./node_modules/@angular/material/esm2015/stepper.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepperModule", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepperModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepLabel", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepLabel"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStep", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStep"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepper", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepper"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatHorizontalStepper", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatHorizontalStepper"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatVerticalStepper", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatVerticalStepper"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepperNext", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepperNext"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepperPrevious", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepperPrevious"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepHeader", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepHeader"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER_FACTORY", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MAT_STEPPER_INTL_PROVIDER_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepperIntl", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepperIntl"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MAT_STEPPER_INTL_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matStepperAnimations", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["matStepperAnimations"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatStepperIcon", function () { return _angular_material_stepper__WEBPACK_IMPORTED_MODULE_29__["MatStepperIcon"]; });
            /* harmony import */ var _angular_material_table__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @angular/material/table */ "./node_modules/@angular/material/esm2015/table.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTableModule", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatTableModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCellDef", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatCellDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatHeaderCellDef", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatHeaderCellDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatFooterCellDef", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatFooterCellDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatColumnDef", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatColumnDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatHeaderCell", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatHeaderCell"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatFooterCell", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatFooterCell"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatCell", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatCell"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTable", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatTable"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatHeaderRowDef", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatHeaderRowDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatFooterRowDef", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatFooterRowDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRowDef", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatRowDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatHeaderRow", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatHeaderRow"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatFooterRow", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatFooterRow"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatRow", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatRow"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTableDataSource", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatTableDataSource"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTextColumn", function () { return _angular_material_table__WEBPACK_IMPORTED_MODULE_30__["MatTextColumn"]; });
            /* harmony import */ var _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @angular/material/tabs */ "./node_modules/@angular/material/esm2015/tabs.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵa24", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["ɵa24"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ɵb24", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["ɵb24"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabsModule", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabsModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatInkBar", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatInkBar"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MAT_INK_BAR_POSITIONER", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["_MAT_INK_BAR_POSITIONER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabBody", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabBody"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatTabBodyBase", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["_MatTabBodyBase"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabBodyPortal", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabBodyPortal"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabHeader", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabHeader"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatTabHeaderBase", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["_MatTabHeaderBase"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabLabelWrapper", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabLabelWrapper"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTab", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTab"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabLabel", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabLabel"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabNav", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabNav"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabLink", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabLink"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatTabNavBase", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["_MatTabNavBase"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatTabLinkBase", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["_MatTabLinkBase"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabContent", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabContent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabChangeEvent", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabChangeEvent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_TABS_CONFIG", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MAT_TABS_CONFIG"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MatTabGroupBase", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["_MatTabGroupBase"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTabGroup", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["MatTabGroup"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matTabsAnimations", function () { return _angular_material_tabs__WEBPACK_IMPORTED_MODULE_31__["matTabsAnimations"]; });
            /* harmony import */ var _angular_material_toolbar__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @angular/material/toolbar */ "./node_modules/@angular/material/esm2015/toolbar.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatToolbarModule", function () { return _angular_material_toolbar__WEBPACK_IMPORTED_MODULE_32__["MatToolbarModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throwToolbarMixedModesError", function () { return _angular_material_toolbar__WEBPACK_IMPORTED_MODULE_32__["throwToolbarMixedModesError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatToolbarRow", function () { return _angular_material_toolbar__WEBPACK_IMPORTED_MODULE_32__["MatToolbarRow"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatToolbar", function () { return _angular_material_toolbar__WEBPACK_IMPORTED_MODULE_32__["MatToolbar"]; });
            /* harmony import */ var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @angular/material/tooltip */ "./node_modules/@angular/material/esm2015/tooltip.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTooltipModule", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["MatTooltipModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMatTooltipInvalidPositionError", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["getMatTooltipInvalidPositionError"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SCROLL_THROTTLE_MS", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["SCROLL_THROTTLE_MS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TOOLTIP_PANEL_CLASS", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["TOOLTIP_PANEL_CLASS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["MAT_TOOLTIP_SCROLL_STRATEGY"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MAT_TOOLTIP_DEFAULT_OPTIONS", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["MAT_TOOLTIP_DEFAULT_OPTIONS"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTooltip", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["MatTooltip"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TooltipComponent", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["TooltipComponent"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matTooltipAnimations", function () { return _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_33__["matTooltipAnimations"]; });
            /* harmony import */ var _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @angular/material/tree */ "./node_modules/@angular/material/esm2015/tree.js");
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeNode", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeNode"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodeDef", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeNodeDef"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatNestedTreeNode", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatNestedTreeNode"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodePadding", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeNodePadding"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTree", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTree"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeModule", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeModule"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodeToggle", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeNodeToggle"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodeOutlet", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeNodeOutlet"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeFlattener", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeFlattener"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeFlatDataSource", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeFlatDataSource"]; });
            /* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MatTreeNestedDataSource", function () { return _angular_material_tree__WEBPACK_IMPORTED_MODULE_34__["MatTreeNestedDataSource"]; });
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=material.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/menu.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/menu.js ***!
          \********************************************************/
        /*! exports provided: MatMenu, MAT_MENU_DEFAULT_OPTIONS, _MatMenu, _MatMenuBase, MatMenuItem, MatMenuTrigger, MAT_MENU_SCROLL_STRATEGY, MAT_MENU_PANEL, _MatMenuDirectivesModule, MatMenuModule, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, ɵa22, ɵb22, ɵc22 */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenu", function () { return MatMenu; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_DEFAULT_OPTIONS", function () { return MAT_MENU_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatMenu", function () { return _MatMenu; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatMenuBase", function () { return _MatMenuBase; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuItem", function () { return MatMenuItem; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuTrigger", function () { return MatMenuTrigger; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_SCROLL_STRATEGY", function () { return MAT_MENU_SCROLL_STRATEGY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_MENU_PANEL", function () { return MAT_MENU_PANEL; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatMenuDirectivesModule", function () { return _MatMenuDirectivesModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuModule", function () { return MatMenuModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matMenuAnimations", function () { return matMenuAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fadeInItems", function () { return fadeInItems; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMenu", function () { return transformMenu; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatMenuContent", function () { return MatMenuContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵa22", function () { return MAT_MENU_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵb22", function () { return MAT_MENU_SCROLL_STRATEGY_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ɵc22", function () { return MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the mat-menu component.
             * Animation duration and timing values are based on:
             * https://material.io/guidelines/components/menus.html#menus-usage
             * \@docs-private
             * @type {?}
             */
            var matMenuAnimations = {
                /**
                 * This animation controls the menu panel's entry and exit from the page.
                 *
                 * When the menu panel is added to the DOM, it scales in and fades in its border.
                 *
                 * When the menu panel is removed from the DOM, it simply fades out after a brief
                 * delay to display the ripple.
                 */
                transformMenu: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('transformMenu', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                        opacity: 0,
                        transform: 'scale(0.8)'
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => enter', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["group"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["query"])('.mat-menu-content, .mat-mdc-menu-content', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('100ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                            opacity: 1
                        }))),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('120ms cubic-bezier(0, 0, 0.2, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ transform: 'scale(1)' })),
                    ])),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('* => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('100ms 25ms linear', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 })))
                ]),
                /**
                 * This animation fades in the background color and content of the menu panel
                 * after its containing element is scaled in.
                 */
                fadeInItems: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('fadeInItems', [
                    // TODO(crisbeto): this is inside the `transformMenu`
                    // now. Remove next time we do breaking changes.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('showing', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 1 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => *', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({ opacity: 0 }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                    ])
                ])
            };
            /**
             * @deprecated
             * \@breaking-change 8.0.0
             * \@docs-private
             * @type {?}
             */
            var fadeInItems = matMenuAnimations.fadeInItems;
            /**
             * @deprecated
             * \@breaking-change 8.0.0
             * \@docs-private
             * @type {?}
             */
            var transformMenu = matMenuAnimations.transformMenu;
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Menu content that will be rendered lazily once the menu is opened.
             */
            var MatMenuContent = /** @class */ (function () {
                /**
                 * @param {?} _template
                 * @param {?} _componentFactoryResolver
                 * @param {?} _appRef
                 * @param {?} _injector
                 * @param {?} _viewContainerRef
                 * @param {?} _document
                 * @param {?=} _changeDetectorRef
                 */
                function MatMenuContent(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document, _changeDetectorRef) {
                    this._template = _template;
                    this._componentFactoryResolver = _componentFactoryResolver;
                    this._appRef = _appRef;
                    this._injector = _injector;
                    this._viewContainerRef = _viewContainerRef;
                    this._document = _document;
                    this._changeDetectorRef = _changeDetectorRef;
                    /**
                     * Emits when the menu content has been attached.
                     */
                    this._attached = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                }
                /**
                 * Attaches the content with a particular context.
                 * \@docs-private
                 * @param {?=} context
                 * @return {?}
                 */
                MatMenuContent.prototype.attach = function (context) {
                    if (context === void 0) { context = {}; }
                    if (!this._portal) {
                        this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__["TemplatePortal"](this._template, this._viewContainerRef);
                    }
                    this.detach();
                    if (!this._outlet) {
                        this._outlet = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__["DomPortalOutlet"](this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);
                    }
                    /** @type {?} */
                    var element = this._template.elementRef.nativeElement;
                    // Because we support opening the same menu from different triggers (which in turn have their
                    // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we
                    // risk it staying attached to a pane that's no longer in the DOM.
                    ( /** @type {?} */(element.parentNode)).insertBefore(this._outlet.outletElement, element);
                    // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu
                    // content via `createEmbeddedView` does not cause the content to be seen as "dirty"
                    // by Angular. This causes the `@ContentChildren` for menu items within the menu to
                    // not be updated by Angular. By explicitly marking for check here, we tell Angular that
                    // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.
                    // @breaking-change 9.0.0 Make change detector ref required
                    if (this._changeDetectorRef) {
                        this._changeDetectorRef.markForCheck();
                    }
                    this._portal.attach(this._outlet, context);
                    this._attached.next();
                };
                /**
                 * Detaches the content.
                 * \@docs-private
                 * @return {?}
                 */
                MatMenuContent.prototype.detach = function () {
                    if (this._portal.isAttached) {
                        this._portal.detach();
                    }
                };
                /**
                 * @return {?}
                 */
                MatMenuContent.prototype.ngOnDestroy = function () {
                    if (this._outlet) {
                        this._outlet.dispose();
                    }
                };
                return MatMenuContent;
            }());
            MatMenuContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'ng-template[matMenuContent]'
                        },] },
            ];
            /** @nocollapse */
            MatMenuContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["TemplateRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ComponentFactoryResolver"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ApplicationRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Injector"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance
             * \@docs-private
             * @return {?}
             */
            function throwMatMenuMissingError() {
                throw Error("matMenuTriggerFor: must pass in an mat-menu instance.\n\n    Example:\n      <mat-menu #menu=\"matMenu\"></mat-menu>\n      <button [matMenuTriggerFor]=\"menu\"></button>");
            }
            /**
             * Throws an exception for the case when menu's x-position value isn't valid.
             * In other words, it doesn't match 'before' or 'after'.
             * \@docs-private
             * @return {?}
             */
            function throwMatMenuInvalidPositionX() {
                throw Error("xPosition value must be either 'before' or after'.\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>");
            }
            /**
             * Throws an exception for the case when menu's y-position value isn't valid.
             * In other words, it doesn't match 'above' or 'below'.
             * \@docs-private
             * @return {?}
             */
            function throwMatMenuInvalidPositionY() {
                throw Error("yPosition value must be either 'above' or below'.\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token used to provide the parent menu to menu-specific components.
             * \@docs-private
             * @type {?}
             */
            var MAT_MENU_PANEL = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('MAT_MENU_PANEL');
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatMenuItem.
            /**
             * \@docs-private
             */
            var MatMenuItemBase = /** @class */ (function () {
                function MatMenuItemBase() {
                }
                return MatMenuItemBase;
            }());
            /** @type {?} */
            var _MatMenuItemMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinDisabled"])(MatMenuItemBase));
            /**
             * This directive is intended to be used inside an mat-menu tag.
             * It exists mostly to set the role attribute.
             */
            var MatMenuItem = /** @class */ (function (_super) {
                __extends(MatMenuItem, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?=} document
                 * @param {?=} _focusMonitor
                 * @param {?=} _parentMenu
                 */
                function MatMenuItem(_elementRef, document, _focusMonitor, _parentMenu) {
                    var _this = 
                    // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.
                    _super.call(this) || this;
                    _this._elementRef = _elementRef;
                    _this._focusMonitor = _focusMonitor;
                    _this._parentMenu = _parentMenu;
                    /**
                     * ARIA role for the menu item.
                     */
                    _this.role = 'menuitem';
                    /**
                     * Stream that emits when the menu item is hovered.
                     */
                    _this._hovered = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Whether the menu item is highlighted.
                     */
                    _this._highlighted = false;
                    /**
                     * Whether the menu item acts as a trigger for a sub-menu.
                     */
                    _this._triggersSubmenu = false;
                    if (_focusMonitor) {
                        // Start monitoring the element so it gets the appropriate focused classes. We want
                        // to show the focus style for menu items only when the focus was not caused by a
                        // mouse or touch interaction.
                        _focusMonitor.monitor(_this._elementRef, false);
                    }
                    if (_parentMenu && _parentMenu.addItem) {
                        _parentMenu.addItem(_this);
                    }
                    _this._document = document;
                    return _this;
                }
                /**
                 * Focuses the menu item.
                 * @param {?=} origin
                 * @param {?=} options
                 * @return {?}
                 */
                MatMenuItem.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    if (this._focusMonitor) {
                        this._focusMonitor.focusVia(this._getHostElement(), origin, options);
                    }
                    else {
                        this._getHostElement().focus(options);
                    }
                };
                /**
                 * @return {?}
                 */
                MatMenuItem.prototype.ngOnDestroy = function () {
                    if (this._focusMonitor) {
                        this._focusMonitor.stopMonitoring(this._elementRef);
                    }
                    if (this._parentMenu && this._parentMenu.removeItem) {
                        this._parentMenu.removeItem(this);
                    }
                    this._hovered.complete();
                };
                /**
                 * Used to set the `tabindex`.
                 * @return {?}
                 */
                MatMenuItem.prototype._getTabIndex = function () {
                    return this.disabled ? '-1' : '0';
                };
                /**
                 * Returns the host DOM element.
                 * @return {?}
                 */
                MatMenuItem.prototype._getHostElement = function () {
                    return this._elementRef.nativeElement;
                };
                /**
                 * Prevents the default element actions if it is disabled.
                 * @param {?} event
                 * @return {?}
                 */
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                MatMenuItem.prototype._checkDisabled = function (event) {
                    if (this.disabled) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                };
                /**
                 * Emits to the hover stream.
                 * @return {?}
                 */
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                MatMenuItem.prototype._handleMouseEnter = function () {
                    this._hovered.next(this);
                };
                /**
                 * Gets the label to be used when determining whether the option should be focused.
                 * @return {?}
                 */
                MatMenuItem.prototype.getLabel = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var textNodeType = this._document ? this._document.TEXT_NODE : 3;
                    /** @type {?} */
                    var output = '';
                    if (element.childNodes) {
                        /** @type {?} */
                        var length = element.childNodes.length;
                        // Go through all the top-level text nodes and extract their text.
                        // We skip anything that's not a text node to prevent the text from
                        // being thrown off by something like an icon.
                        for (var i = 0; i < length; i++) {
                            if (element.childNodes[i].nodeType === textNodeType) {
                                output += element.childNodes[i].textContent;
                            }
                        }
                    }
                    return output.trim();
                };
                return MatMenuItem;
            }(_MatMenuItemMixinBase));
            MatMenuItem.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: '[mat-menu-item]',
                            exportAs: 'matMenuItem',
                            inputs: ['disabled', 'disableRipple'],
                            host: {
                                '[attr.role]': 'role',
                                'class': 'mat-menu-item',
                                '[class.mat-menu-item-highlighted]': '_highlighted',
                                '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',
                                '[attr.tabindex]': '_getTabIndex()',
                                '[attr.aria-disabled]': 'disabled.toString()',
                                '[attr.disabled]': 'disabled || null',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            template: "<ng-content></ng-content><div class=\"mat-menu-ripple\" matRipple [matRippleDisabled]=\"disableRipple || disabled\" [matRippleTrigger]=\"_getHostElement()\"></div>",
                        },] },
            ];
            /** @nocollapse */
            MatMenuItem.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["DOCUMENT"],] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["FocusMonitor"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_PANEL,] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] }
            ]; };
            MatMenuItem.propDecorators = {
                role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                _checkDisabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["HostListener"], args: ['click', ['$event'],] }],
                _handleMouseEnter: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["HostListener"], args: ['mouseenter',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for `mat-menu`.
             * @type {?}
             */
            var MAT_MENU_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-menu-default-options', {
                providedIn: 'root',
                factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_MENU_DEFAULT_OPTIONS_FACTORY() {
                return {
                    overlapTrigger: false,
                    xPosition: 'after',
                    yPosition: 'below',
                    backdropClass: 'cdk-overlay-transparent-backdrop',
                };
            }
            /**
             * Start elevation for the menu panel.
             * \@docs-private
             * @type {?}
             */
            var MAT_MENU_BASE_ELEVATION = 4;
            /**
             * Base class with all of the `MatMenu` functionality.
             */
            // tslint:disable-next-line:class-name
            var _MatMenuBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _ngZone
                 * @param {?} _defaultOptions
                 */
                function _MatMenuBase(_elementRef, _ngZone, _defaultOptions) {
                    this._elementRef = _elementRef;
                    this._ngZone = _ngZone;
                    this._defaultOptions = _defaultOptions;
                    this._xPosition = this._defaultOptions.xPosition;
                    this._yPosition = this._defaultOptions.yPosition;
                    /**
                     * Only the direct descendant menu items.
                     */
                    this._directDescendantItems = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["QueryList"]();
                    /**
                     * Subscription to tab events on the menu panel
                     */
                    this._tabSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Config object to be passed into the menu's ngClass
                     */
                    this._classList = {};
                    /**
                     * Current state of the panel animation.
                     */
                    this._panelAnimationState = 'void';
                    /**
                     * Emits whenever an animation on the menu completes.
                     */
                    this._animationDone = new rxjs__WEBPACK_IMPORTED_MODULE_4__["Subject"]();
                    /**
                     * Class to be added to the backdrop element.
                     */
                    this.backdropClass = this._defaultOptions.backdropClass;
                    this._overlapTrigger = this._defaultOptions.overlapTrigger;
                    this._hasBackdrop = this._defaultOptions.hasBackdrop;
                    /**
                     * Event emitted when the menu is closed.
                     */
                    this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the menu is closed.
                     * @deprecated Switch to `closed` instead
                     * \@breaking-change 8.0.0
                     */
                    this.close = this.closed;
                }
                Object.defineProperty(_MatMenuBase.prototype, "xPosition", {
                    /**
                     * Position of the menu in the X axis.
                     * @return {?}
                     */
                    get: function () { return this._xPosition; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== 'before' && value !== 'after') {
                            throwMatMenuInvalidPositionX();
                        }
                        this._xPosition = value;
                        this.setPositionClasses();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "yPosition", {
                    /**
                     * Position of the menu in the Y axis.
                     * @return {?}
                     */
                    get: function () { return this._yPosition; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value !== 'above' && value !== 'below') {
                            throwMatMenuInvalidPositionY();
                        }
                        this._yPosition = value;
                        this.setPositionClasses();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "overlapTrigger", {
                    /**
                     * Whether the menu should overlap its trigger.
                     * @return {?}
                     */
                    get: function () { return this._overlapTrigger; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._overlapTrigger = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "hasBackdrop", {
                    /**
                     * Whether the menu has a backdrop.
                     * @return {?}
                     */
                    get: function () { return this._hasBackdrop; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._hasBackdrop = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_7__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "panelClass", {
                    /**
                     * This method takes classes set on the host mat-menu element and applies them on the
                     * menu template that displays in the overlay container.  Otherwise, it's difficult
                     * to style the containing menu from outside the component.
                     * @param {?} classes list of class names
                     * @return {?}
                     */
                    set: function (classes) {
                        var _this = this;
                        /** @type {?} */
                        var previousPanelClass = this._previousPanelClass;
                        if (previousPanelClass && previousPanelClass.length) {
                            previousPanelClass.split(' ').forEach(( /**
                             * @param {?} className
                             * @return {?}
                             */function (className) {
                                _this._classList[className] = false;
                            }));
                        }
                        this._previousPanelClass = classes;
                        if (classes && classes.length) {
                            classes.split(' ').forEach(( /**
                             * @param {?} className
                             * @return {?}
                             */function (className) {
                                _this._classList[className] = true;
                            }));
                            this._elementRef.nativeElement.className = '';
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(_MatMenuBase.prototype, "classList", {
                    /**
                     * This method takes classes set on the host mat-menu element and applies them on the
                     * menu template that displays in the overlay container.  Otherwise, it's difficult
                     * to style the containing menu from outside the component.
                     * @deprecated Use `panelClass` instead.
                     * \@breaking-change 8.0.0
                     * @return {?}
                     */
                    get: function () { return this.panelClass; },
                    /**
                     * @param {?} classes
                     * @return {?}
                     */
                    set: function (classes) { this.panelClass = classes; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                _MatMenuBase.prototype.ngOnInit = function () {
                    this.setPositionClasses();
                };
                /**
                 * @return {?}
                 */
                _MatMenuBase.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._updateDirectDescendants();
                    this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["FocusKeyManager"](this._directDescendantItems).withWrap().withTypeAhead();
                    this._tabSubscription = this._keyManager.tabOut.subscribe(( /**
                     * @return {?}
                     */function () { return _this.closed.emit('tab'); }));
                };
                /**
                 * @return {?}
                 */
                _MatMenuBase.prototype.ngOnDestroy = function () {
                    this._directDescendantItems.destroy();
                    this._tabSubscription.unsubscribe();
                    this.closed.complete();
                };
                /**
                 * Stream that emits whenever the hovered menu item changes.
                 * @return {?}
                 */
                _MatMenuBase.prototype._hovered = function () {
                    // Coerce the `changes` property because Angular types it as `Observable<any>`
                    /** @type {?} */
                    var itemChanges = ( /** @type {?} */(this._directDescendantItems.changes));
                    return itemChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["startWith"])(this._directDescendantItems), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["switchMap"])(( /**
                     * @param {?} items
                     * @return {?}
                     */function (/**
                     * @param {?} items
                     * @return {?}
                     */ items) { return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"]).apply(void 0, __spread(items.map(( /**
                     * @param {?} item
                     * @return {?}
                     */function (item) { return item._hovered; })))); })));
                };
                /*
                   * Registers a menu item with the menu.
                   * @docs-private
                   * @deprecated No longer being used. To be removed.
                   * @breaking-change 9.0.0
                   */
                /**
                 * @param {?} _item
                 * @return {?}
                 */
                _MatMenuBase.prototype.addItem = function (_item) { };
                /**
                 * Removes an item from the menu.
                 * \@docs-private
                 * @deprecated No longer being used. To be removed.
                 * \@breaking-change 9.0.0
                 * @param {?} _item
                 * @return {?}
                 */
                _MatMenuBase.prototype.removeItem = function (_item) { };
                /**
                 * Handle a keyboard event from the menu, delegating to the appropriate action.
                 * @param {?} event
                 * @return {?}
                 */
                _MatMenuBase.prototype._handleKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    /** @type {?} */
                    var manager = this._keyManager;
                    switch (keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["ESCAPE"]:
                            if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["hasModifierKey"])(event)) {
                                event.preventDefault();
                                this.closed.emit('keydown');
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["LEFT_ARROW"]:
                            if (this.parentMenu && this.direction === 'ltr') {
                                this.closed.emit('keydown');
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["RIGHT_ARROW"]:
                            if (this.parentMenu && this.direction === 'rtl') {
                                this.closed.emit('keydown');
                            }
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["HOME"]:
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["END"]:
                            if (!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["hasModifierKey"])(event)) {
                                keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["HOME"] ? manager.setFirstItemActive() : manager.setLastItemActive();
                                event.preventDefault();
                            }
                            break;
                        default:
                            if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["UP_ARROW"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["DOWN_ARROW"]) {
                                manager.setFocusOrigin('keyboard');
                            }
                            manager.onKeydown(event);
                    }
                };
                /**
                 * Focus the first item in the menu.
                 * @param {?=} origin Action from which the focus originated. Used to set the correct styling.
                 * @return {?}
                 */
                _MatMenuBase.prototype.focusFirstItem = function (origin) {
                    if (origin === void 0) { origin = 'program'; }
                    /** @type {?} */
                    var manager = this._keyManager;
                    // When the content is rendered lazily, it takes a bit before the items are inside the DOM.
                    if (this.lazyContent) {
                        this._ngZone.onStable.asObservable()
                            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1))
                            .subscribe(( /**
                     * @return {?}
                     */function () { return manager.setFocusOrigin(origin).setFirstItemActive(); }));
                    }
                    else {
                        manager.setFocusOrigin(origin).setFirstItemActive();
                    }
                    // If there's no active item at this point, it means that all the items are disabled.
                    // Move focus to the menu panel so keyboard events like Escape still work. Also this will
                    // give _some_ feedback to screen readers.
                    if (!manager.activeItem && this._directDescendantItems.length) {
                        /** @type {?} */
                        var element = this._directDescendantItems.first._getHostElement().parentElement;
                        // Because the `mat-menu` is at the DOM insertion point, not inside the overlay, we don't
                        // have a nice way of getting a hold of the menu panel. We can't use a `ViewChild` either
                        // because the panel is inside an `ng-template`. We work around it by starting from one of
                        // the items and walking up the DOM.
                        while (element) {
                            if (element.getAttribute('role') === 'menu') {
                                element.focus();
                                break;
                            }
                            else {
                                element = element.parentElement;
                            }
                        }
                    }
                };
                /**
                 * Resets the active item in the menu. This is used when the menu is opened, allowing
                 * the user to start from the first option when pressing the down arrow.
                 * @return {?}
                 */
                _MatMenuBase.prototype.resetActiveItem = function () {
                    this._keyManager.setActiveItem(-1);
                };
                /**
                 * Sets the menu panel elevation.
                 * @param {?} depth Number of parent menus that come before the menu.
                 * @return {?}
                 */
                _MatMenuBase.prototype.setElevation = function (depth) {
                    // The elevation starts at the base and increases by one for each level.
                    /** @type {?} */
                    var newElevation = "mat-elevation-z" + (MAT_MENU_BASE_ELEVATION + depth);
                    /** @type {?} */
                    var customElevation = Object.keys(this._classList).find(( /**
                     * @param {?} c
                     * @return {?}
                     */function (/**
                     * @param {?} c
                     * @return {?}
                     */ c) { return c.startsWith('mat-elevation-z'); }));
                    if (!customElevation || customElevation === this._previousElevation) {
                        if (this._previousElevation) {
                            this._classList[this._previousElevation] = false;
                        }
                        this._classList[newElevation] = true;
                        this._previousElevation = newElevation;
                    }
                };
                /**
                 * Adds classes to the menu panel based on its position. Can be used by
                 * consumers to add specific styling based on the position.
                 * \@docs-private
                 * @param {?=} posX Position of the menu along the x axis.
                 * @param {?=} posY Position of the menu along the y axis.
                 * @return {?}
                 */
                _MatMenuBase.prototype.setPositionClasses = function (posX, posY) {
                    if (posX === void 0) { posX = this.xPosition; }
                    if (posY === void 0) { posY = this.yPosition; }
                    /** @type {?} */
                    var classes = this._classList;
                    classes['mat-menu-before'] = posX === 'before';
                    classes['mat-menu-after'] = posX === 'after';
                    classes['mat-menu-above'] = posY === 'above';
                    classes['mat-menu-below'] = posY === 'below';
                };
                /**
                 * Starts the enter animation.
                 * @return {?}
                 */
                _MatMenuBase.prototype._startAnimation = function () {
                    // @breaking-change 8.0.0 Combine with _resetAnimation.
                    this._panelAnimationState = 'enter';
                };
                /**
                 * Resets the panel animation to its initial state.
                 * @return {?}
                 */
                _MatMenuBase.prototype._resetAnimation = function () {
                    // @breaking-change 8.0.0 Combine with _startAnimation.
                    this._panelAnimationState = 'void';
                };
                /**
                 * Callback that is invoked when the panel animation completes.
                 * @param {?} event
                 * @return {?}
                 */
                _MatMenuBase.prototype._onAnimationDone = function (event) {
                    this._animationDone.next(event);
                    this._isAnimating = false;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                _MatMenuBase.prototype._onAnimationStart = function (event) {
                    this._isAnimating = true;
                    // Scroll the content element to the top as soon as the animation starts. This is necessary,
                    // because we move focus to the first item while it's still being animated, which can throw
                    // the browser off when it determines the scroll position. Alternatively we can move focus
                    // when the animation is done, however moving focus asynchronously will interrupt screen
                    // readers which are in the process of reading out the menu already. We take the `element`
                    // from the `event` since we can't use a `ViewChild` to access the pane.
                    if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
                        event.element.scrollTop = 0;
                    }
                };
                /**
                 * Sets up a stream that will keep track of any newly-added menu items and will update the list
                 * of direct descendants. We collect the descendants this way, because `_allItems` can include
                 * items that are part of child menus, and using a custom way of registering items is unreliable
                 * when it comes to maintaining the item order.
                 * @private
                 * @return {?}
                 */
                _MatMenuBase.prototype._updateDirectDescendants = function () {
                    var _this = this;
                    this._allItems.changes
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["startWith"])(this._allItems))
                        .subscribe(( /**
                 * @param {?} items
                 * @return {?}
                 */function (items) {
                        _this._directDescendantItems.reset(items.filter(( /**
                         * @param {?} item
                         * @return {?}
                         */function (/**
                         * @param {?} item
                         * @return {?}
                         */ item) { return item._parentMenu === _this; })));
                        _this._directDescendantItems.notifyOnChanges();
                    }));
                };
                return _MatMenuBase;
            }());
            /** @nocollapse */
            _MatMenuBase.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_DEFAULT_OPTIONS,] }] }
            ]; };
            _MatMenuBase.propDecorators = {
                _allItems: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [MatMenuItem, { descendants: true },] }],
                backdropClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                xPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                yPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                templateRef: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: [_angular_core__WEBPACK_IMPORTED_MODULE_3__["TemplateRef"], { static: false },] }],
                items: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [MatMenuItem,] }],
                lazyContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChild"], args: [MatMenuContent, { static: false },] }],
                overlapTrigger: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                hasBackdrop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                panelClass: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['class',] }],
                classList: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                closed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                close: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * \@docs-private We show the "_MatMenu" class as "MatMenu" in the docs.
             */
            var MatMenu = /** @class */ (function (_super) {
                __extends(MatMenu, _super);
                function MatMenu() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatMenu;
            }(_MatMenuBase));
            // Note on the weird inheritance setup: we need three classes, because the MDC-based menu has to
            // extend `MatMenu`, however keeping a reference to it will cause the inlined template and styles
            // to be retained as well. The MDC menu also has to provide itself as a `MatMenu` in order for
            // queries and DI to work correctly, while still not referencing the actual menu class.
            // Class responsibility is split up as follows:
            // * _MatMenuBase - provides all the functionality without any of the Angular metadata.
            // * MatMenu - keeps the same name symbol name as the current menu and
            // is used as a provider for DI and query purposes.
            // * _MatMenu - the actual menu component implementation with the Angular metadata that should
            // be tree shaken away for MDC.
            /**
             * \@docs-public MatMenu
             */
            // tslint:disable-next-line:class-name
            var _MatMenu = /** @class */ (function (_super) {
                __extends(_MatMenu, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} ngZone
                 * @param {?} defaultOptions
                 */
                function _MatMenu(elementRef, ngZone, defaultOptions) {
                    return _super.call(this, elementRef, ngZone, defaultOptions) || this;
                }
                return _MatMenu;
            }(MatMenu));
            _MatMenu.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-menu',
                            template: "<ng-template><div class=\"mat-menu-panel\" [ngClass]=\"_classList\" (keydown)=\"_handleKeydown($event)\" (click)=\"closed.emit('click')\" [@transformMenu]=\"_panelAnimationState\" (@transformMenu.start)=\"_onAnimationStart($event)\" (@transformMenu.done)=\"_onAnimationDone($event)\" tabindex=\"-1\" role=\"menu\"><div class=\"mat-menu-content\"><ng-content></ng-content></div></div></ng-template>",
                            styles: [".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}@media (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matMenu',
                            animations: [
                                matMenuAnimations.transformMenu,
                                matMenuAnimations.fadeInItems
                            ],
                            providers: [
                                { provide: MAT_MENU_PANEL, useExisting: MatMenu },
                                { provide: MatMenu, useExisting: _MatMenu }
                            ]
                        },] },
            ];
            /** @nocollapse */
            _MatMenu.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_DEFAULT_OPTIONS,] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that determines the scroll handling while the menu is open.
             * @type {?}
             */
            var MAT_MENU_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-menu-scroll-strategy');
            /**
             * \@docs-private
             * @param {?} overlay
             * @return {?}
             */
            function MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {
                return ( /**
                 * @return {?}
                 */function () { return overlay.scrollStrategies.reposition(); });
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {
                provide: MAT_MENU_SCROLL_STRATEGY,
                deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["Overlay"]],
                useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,
            };
            /**
             * Default top padding of the menu panel.
             * @type {?}
             */
            var MENU_PANEL_TOP_PADDING = 8;
            /**
             * Options for binding a passive event listener.
             * @type {?}
             */
            var passiveEventListenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_12__["normalizePassiveListenerOptions"])({ passive: true });
            // TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors
            /**
             * This directive is intended to be used in conjunction with an mat-menu tag.  It is
             * responsible for toggling the display of the provided menu instance.
             */
            var MatMenuTrigger = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _element
                 * @param {?} _viewContainerRef
                 * @param {?} scrollStrategy
                 * @param {?} _parentMenu
                 * @param {?} _menuItemInstance
                 * @param {?} _dir
                 * @param {?=} _focusMonitor
                 */
                function MatMenuTrigger(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {
                    var _this = this;
                    this._overlay = _overlay;
                    this._element = _element;
                    this._viewContainerRef = _viewContainerRef;
                    this._parentMenu = _parentMenu;
                    this._menuItemInstance = _menuItemInstance;
                    this._dir = _dir;
                    this._focusMonitor = _focusMonitor;
                    this._overlayRef = null;
                    this._menuOpen = false;
                    this._closingActionsSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    this._hoverSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    this._menuCloseSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__["Subscription"].EMPTY;
                    /**
                     * Handles touch start events on the trigger.
                     * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.
                     */
                    this._handleTouchStart = ( /**
                     * @return {?}
                     */function () { return _this._openedBy = 'touch'; });
                    // Tracking input type is necessary so it's possible to only auto-focus
                    // the first item of the list when the menu is opened via the keyboard
                    this._openedBy = null;
                    /**
                     * Whether focus should be restored when the menu is closed.
                     * Note that disabling this option can have accessibility implications
                     * and it's up to you to manage focus, if you decide to turn it off.
                     */
                    this.restoreFocus = true;
                    /**
                     * Event emitted when the associated menu is opened.
                     */
                    this.menuOpened = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the associated menu is opened.
                     * @deprecated Switch to `menuOpened` instead
                     * \@breaking-change 8.0.0
                     */
                    // tslint:disable-next-line:no-output-on-prefix
                    this.onMenuOpen = this.menuOpened;
                    /**
                     * Event emitted when the associated menu is closed.
                     */
                    this.menuClosed = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Event emitted when the associated menu is closed.
                     * @deprecated Switch to `menuClosed` instead
                     * \@breaking-change 8.0.0
                     */
                    // tslint:disable-next-line:no-output-on-prefix
                    this.onMenuClose = this.menuClosed;
                    _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);
                    if (_menuItemInstance) {
                        _menuItemInstance._triggersSubmenu = this.triggersSubmenu();
                    }
                    this._scrollStrategy = scrollStrategy;
                }
                Object.defineProperty(MatMenuTrigger.prototype, "_deprecatedMatMenuTriggerFor", {
                    /**
                     * @deprecated
                     * \@breaking-change 8.0.0
                     * @return {?}
                     */
                    get: function () { return this.menu; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this.menu = v;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMenuTrigger.prototype, "menu", {
                    /**
                     * References the menu instance that the trigger is associated with.
                     * @return {?}
                     */
                    get: function () { return this._menu; },
                    /**
                     * @param {?} menu
                     * @return {?}
                     */
                    set: function (menu) {
                        var _this = this;
                        if (menu === this._menu) {
                            return;
                        }
                        this._menu = menu;
                        this._menuCloseSubscription.unsubscribe();
                        if (menu) {
                            this._menuCloseSubscription = menu.close.asObservable().subscribe(( /**
                             * @param {?} reason
                             * @return {?}
                             */function (/**
                             * @param {?} reason
                             * @return {?}
                             */ reason) {
                                _this._destroyMenu();
                                // If a click closed the menu, we should close the entire chain of nested menus.
                                if ((reason === 'click' || reason === 'tab') && _this._parentMenu) {
                                    _this._parentMenu.closed.emit(reason);
                                }
                            }));
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatMenuTrigger.prototype.ngAfterContentInit = function () {
                    this._checkMenu();
                    this._handleHover();
                };
                /**
                 * @return {?}
                 */
                MatMenuTrigger.prototype.ngOnDestroy = function () {
                    if (this._overlayRef) {
                        this._overlayRef.dispose();
                        this._overlayRef = null;
                    }
                    this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);
                    this._menuCloseSubscription.unsubscribe();
                    this._closingActionsSubscription.unsubscribe();
                    this._hoverSubscription.unsubscribe();
                };
                Object.defineProperty(MatMenuTrigger.prototype, "menuOpen", {
                    /**
                     * Whether the menu is open.
                     * @return {?}
                     */
                    get: function () {
                        return this._menuOpen;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatMenuTrigger.prototype, "dir", {
                    /**
                     * The text direction of the containing app.
                     * @return {?}
                     */
                    get: function () {
                        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether the menu triggers a sub-menu or a top-level one.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.triggersSubmenu = function () {
                    return !!(this._menuItemInstance && this._parentMenu);
                };
                /**
                 * Toggles the menu between the open and closed states.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.toggleMenu = function () {
                    return this._menuOpen ? this.closeMenu() : this.openMenu();
                };
                /**
                 * Opens the menu.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.openMenu = function () {
                    var _this = this;
                    if (this._menuOpen) {
                        return;
                    }
                    this._checkMenu();
                    /** @type {?} */
                    var overlayRef = this._createOverlay();
                    /** @type {?} */
                    var overlayConfig = overlayRef.getConfig();
                    this._setPosition(( /** @type {?} */(overlayConfig.positionStrategy)));
                    overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :
                        this.menu.hasBackdrop;
                    overlayRef.attach(this._getPortal());
                    if (this.menu.lazyContent) {
                        this.menu.lazyContent.attach(this.menuData);
                    }
                    this._closingActionsSubscription = this._menuClosingActions().subscribe(( /**
                     * @return {?}
                     */function () { return _this.closeMenu(); }));
                    this._initMenu();
                    if (this.menu instanceof MatMenu) {
                        this.menu._startAnimation();
                    }
                };
                /**
                 * Closes the menu.
                 * @return {?}
                 */
                MatMenuTrigger.prototype.closeMenu = function () {
                    this.menu.close.emit();
                };
                /**
                 * Focuses the menu trigger.
                 * @param {?=} origin Source of the menu trigger's focus.
                 * @param {?=} options
                 * @return {?}
                 */
                MatMenuTrigger.prototype.focus = function (origin, options) {
                    if (origin === void 0) { origin = 'program'; }
                    if (this._focusMonitor) {
                        this._focusMonitor.focusVia(this._element, origin, options);
                    }
                    else {
                        this._element.nativeElement.focus(options);
                    }
                };
                /**
                 * Closes the menu and does the necessary cleanup.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._destroyMenu = function () {
                    var _this = this;
                    if (!this._overlayRef || !this.menuOpen) {
                        return;
                    }
                    /** @type {?} */
                    var menu = this.menu;
                    this._closingActionsSubscription.unsubscribe();
                    this._overlayRef.detach();
                    if (menu instanceof MatMenu) {
                        menu._resetAnimation();
                        if (menu.lazyContent) {
                            // Wait for the exit animation to finish before detaching the content.
                            menu._animationDone
                                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return event.toState === 'void'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1), 
                            // Interrupt if the content got re-attached.
                            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["takeUntil"])(menu.lazyContent._attached))
                                .subscribe({
                                next: ( /**
                                 * @return {?}
                                 */function () { return ( /** @type {?} */(menu.lazyContent)).detach(); }),
                                // No matter whether the content got re-attached, reset the menu.
                                complete: ( /**
                                 * @return {?}
                                 */function () { return _this._setIsMenuOpen(false); })
                            });
                        }
                        else {
                            this._setIsMenuOpen(false);
                        }
                    }
                    else {
                        this._setIsMenuOpen(false);
                        if (menu.lazyContent) {
                            menu.lazyContent.detach();
                        }
                    }
                    this._restoreFocus();
                };
                /**
                 * This method sets the menu state to open and focuses the first item if
                 * the menu was opened via the keyboard.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._initMenu = function () {
                    this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;
                    this.menu.direction = this.dir;
                    this._setMenuElevation();
                    this._setIsMenuOpen(true);
                    this.menu.focusFirstItem(this._openedBy || 'program');
                };
                /**
                 * Updates the menu elevation based on the amount of parent menus that it has.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._setMenuElevation = function () {
                    if (this.menu.setElevation) {
                        /** @type {?} */
                        var depth = 0;
                        /** @type {?} */
                        var parentMenu = this.menu.parentMenu;
                        while (parentMenu) {
                            depth++;
                            parentMenu = parentMenu.parentMenu;
                        }
                        this.menu.setElevation(depth);
                    }
                };
                /**
                 * Restores focus to the element that was focused before the menu was open.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._restoreFocus = function () {
                    // We should reset focus if the user is navigating using a keyboard or
                    // if we have a top-level trigger which might cause focus to be lost
                    // when clicking on the backdrop.
                    if (this.restoreFocus) {
                        if (!this._openedBy) {
                            // Note that the focus style will show up both for `program` and
                            // `keyboard` so we don't have to specify which one it is.
                            this.focus();
                        }
                        else if (!this.triggersSubmenu()) {
                            this.focus(this._openedBy);
                        }
                    }
                    this._openedBy = null;
                };
                // set state rather than toggle to support triggers sharing a menu
                /**
                 * @private
                 * @param {?} isOpen
                 * @return {?}
                 */
                MatMenuTrigger.prototype._setIsMenuOpen = function (isOpen) {
                    this._menuOpen = isOpen;
                    this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();
                    if (this.triggersSubmenu()) {
                        this._menuItemInstance._highlighted = isOpen;
                    }
                };
                /**
                 * This method checks that a valid instance of MatMenu has been passed into
                 * matMenuTriggerFor. If not, an exception is thrown.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._checkMenu = function () {
                    if (!this.menu) {
                        throwMatMenuMissingError();
                    }
                };
                /**
                 * This method creates the overlay from the provided menu's template and saves its
                 * OverlayRef so that it can be attached to the DOM when openMenu is called.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._createOverlay = function () {
                    if (!this._overlayRef) {
                        /** @type {?} */
                        var config = this._getOverlayConfig();
                        this._subscribeToPositions(( /** @type {?} */(config.positionStrategy)));
                        this._overlayRef = this._overlay.create(config);
                        // Consume the `keydownEvents` in order to prevent them from going to another overlay.
                        // Ideally we'd also have our keyboard event logic in here, however doing so will
                        // break anybody that may have implemented the `MatMenuPanel` themselves.
                        this._overlayRef.keydownEvents().subscribe();
                    }
                    return this._overlayRef;
                };
                /**
                 * This method builds the configuration object needed to create the overlay, the OverlayState.
                 * @private
                 * @return {?} OverlayConfig
                 */
                MatMenuTrigger.prototype._getOverlayConfig = function () {
                    return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["OverlayConfig"]({
                        positionStrategy: this._overlay.position()
                            .flexibleConnectedTo(this._element)
                            .withLockedPosition()
                            .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),
                        backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',
                        scrollStrategy: this._scrollStrategy(),
                        direction: this._dir
                    });
                };
                /**
                 * Listens to changes in the position of the overlay and sets the correct classes
                 * on the menu based on the new position. This ensures the animation origin is always
                 * correct, even if a fallback position is used for the overlay.
                 * @private
                 * @param {?} position
                 * @return {?}
                 */
                MatMenuTrigger.prototype._subscribeToPositions = function (position) {
                    var _this = this;
                    if (this.menu.setPositionClasses) {
                        position.positionChanges.subscribe(( /**
                         * @param {?} change
                         * @return {?}
                         */function (/**
                         * @param {?} change
                         * @return {?}
                         */ change) {
                            /** @type {?} */
                            var posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
                            /** @type {?} */
                            var posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
                            ( /** @type {?} */(_this.menu.setPositionClasses))(posX, posY);
                        }));
                    }
                };
                /**
                 * Sets the appropriate positions on a position strategy
                 * so the overlay connects with the trigger correctly.
                 * @private
                 * @param {?} positionStrategy Strategy whose position to update.
                 * @return {?}
                 */
                MatMenuTrigger.prototype._setPosition = function (positionStrategy) {
                    var _a = __read(this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'], 2), originX = _a[0], originFallbackX = _a[1];
                    var _b = __read(this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], 2), overlayY = _b[0], overlayFallbackY = _b[1];
                    var _c = __read([overlayY, overlayFallbackY], 2), originY = _c[0], originFallbackY = _c[1];
                    var _d = __read([originX, originFallbackX], 2), overlayX = _d[0], overlayFallbackX = _d[1];
                    /** @type {?} */
                    var offsetY = 0;
                    if (this.triggersSubmenu()) {
                        // When the menu is a sub-menu, it should always align itself
                        // to the edges of the trigger, instead of overlapping it.
                        overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';
                        originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';
                        offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;
                    }
                    else if (!this.menu.overlapTrigger) {
                        originY = overlayY === 'top' ? 'bottom' : 'top';
                        originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
                    }
                    positionStrategy.withPositions([
                        { originX: originX, originY: originY, overlayX: overlayX, overlayY: overlayY, offsetY: offsetY },
                        { originX: originFallbackX, originY: originY, overlayX: overlayFallbackX, overlayY: overlayY, offsetY: offsetY },
                        {
                            originX: originX,
                            originY: originFallbackY,
                            overlayX: overlayX,
                            overlayY: overlayFallbackY,
                            offsetY: -offsetY
                        },
                        {
                            originX: originFallbackX,
                            originY: originFallbackY,
                            overlayX: overlayFallbackX,
                            overlayY: overlayFallbackY,
                            offsetY: -offsetY
                        }
                    ]);
                };
                /**
                 * Returns a stream that emits whenever an action that should close the menu occurs.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._menuClosingActions = function () {
                    var _this = this;
                    /** @type {?} */
                    var backdrop = ( /** @type {?} */(this._overlayRef)).backdropClick();
                    /** @type {?} */
                    var detachments = ( /** @type {?} */(this._overlayRef)).detachments();
                    /** @type {?} */
                    var parentClose = this._parentMenu ? this._parentMenu.closed : Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])();
                    /** @type {?} */
                    var hover = this._parentMenu ? this._parentMenu._hovered().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                     * @param {?} active
                     * @return {?}
                     */function (/**
                     * @param {?} active
                     * @return {?}
                     */ active) { return active !== _this._menuItemInstance; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                     * @return {?}
                     */function () { return _this._menuOpen; }))) : Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["of"])();
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["merge"])(backdrop, parentClose, hover, detachments);
                };
                /**
                 * Handles mouse presses on the trigger.
                 * @param {?} event
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleMousedown = function (event) {
                    if (!Object(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["isFakeMousedownFromScreenReader"])(event)) {
                        // Since right or middle button clicks won't trigger the `click` event,
                        // we shouldn't consider the menu as opened by mouse in those cases.
                        this._openedBy = event.button === 0 ? 'mouse' : null;
                        // Since clicking on the trigger won't close the menu if it opens a sub-menu,
                        // we should prevent focus from moving onto it via click to avoid the
                        // highlight from lingering on the menu item.
                        if (this.triggersSubmenu()) {
                            event.preventDefault();
                        }
                    }
                };
                /**
                 * Handles key presses on the trigger.
                 * @param {?} event
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleKeydown = function (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    if (this.triggersSubmenu() && ((keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["RIGHT_ARROW"] && this.dir === 'ltr') ||
                        (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_8__["LEFT_ARROW"] && this.dir === 'rtl'))) {
                        this.openMenu();
                    }
                };
                /**
                 * Handles click events on the trigger.
                 * @param {?} event
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleClick = function (event) {
                    if (this.triggersSubmenu()) {
                        // Stop event propagation to avoid closing the parent menu.
                        event.stopPropagation();
                        this.openMenu();
                    }
                    else {
                        this.toggleMenu();
                    }
                };
                /**
                 * Handles the cases where the user hovers over the trigger.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._handleHover = function () {
                    var _this = this;
                    // Subscribe to changes in the hovered item in order to toggle the panel.
                    if (!this.triggersSubmenu()) {
                        return;
                    }
                    this._hoverSubscription = this._parentMenu._hovered()
                        // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
                        // with different data and triggers), we have to delay it by a tick to ensure that
                        // it won't be closed immediately after it is opened.
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["filter"])(( /**
                 * @param {?} active
                 * @return {?}
                 */function (/**
                 * @param {?} active
                 * @return {?}
                 */ active) { return active === _this._menuItemInstance && !active.disabled; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["delay"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["asapScheduler"]))
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        _this._openedBy = 'mouse';
                        // If the same menu is used between multiple triggers, it might still be animating
                        // while the new trigger tries to re-open it. Wait for the animation to finish
                        // before doing so. Also interrupt if the user moves to another item.
                        if (_this.menu instanceof MatMenu && _this.menu._isAnimating) {
                            // We need the `delay(0)` here in order to avoid
                            // 'changed after checked' errors in some cases. See #12194.
                            _this.menu._animationDone
                                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["take"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["delay"])(0, rxjs__WEBPACK_IMPORTED_MODULE_4__["asapScheduler"]), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__["takeUntil"])(_this._parentMenu._hovered()))
                                .subscribe(( /**
                         * @return {?}
                         */function () { return _this.openMenu(); }));
                        }
                        else {
                            _this.openMenu();
                        }
                    }));
                };
                /**
                 * Gets the portal that should be attached to the overlay.
                 * @private
                 * @return {?}
                 */
                MatMenuTrigger.prototype._getPortal = function () {
                    // Note that we can avoid this check by keeping the portal on the menu panel.
                    // While it would be cleaner, we'd have to introduce another required method on
                    // `MatMenuPanel`, making it harder to consume.
                    if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {
                        this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_1__["TemplatePortal"](this.menu.templateRef, this._viewContainerRef);
                    }
                    return this._portal;
                };
                return MatMenuTrigger;
            }());
            MatMenuTrigger.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: "[mat-menu-trigger-for], [matMenuTriggerFor]",
                            host: {
                                'class': 'mat-menu-trigger',
                                'aria-haspopup': 'true',
                                '[attr.aria-expanded]': 'menuOpen || null',
                                '(mousedown)': '_handleMousedown($event)',
                                '(keydown)': '_handleKeydown($event)',
                                '(click)': '_handleClick($event)',
                            },
                            exportAs: 'matMenuTrigger'
                        },] },
            ];
            /** @nocollapse */
            MatMenuTrigger.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["Overlay"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_MENU_SCROLL_STRATEGY,] }] },
                { type: MatMenu, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: MatMenuItem, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Self"] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_10__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_5__["FocusMonitor"] }
            ]; };
            MatMenuTrigger.propDecorators = {
                _deprecatedMatMenuTriggerFor: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['mat-menu-trigger-for',] }],
                menu: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matMenuTriggerFor',] }],
                menuData: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matMenuTriggerData',] }],
                restoreFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['matMenuTriggerRestoreFocus',] }],
                menuOpened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                onMenuOpen: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                menuClosed: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                onMenuClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Used by both the current `MatMenuModule` and the MDC `MatMenuModule`
             * to declare the menu-related directives.
             */
            // tslint:disable-next-line:class-name
            var _MatMenuDirectivesModule = /** @class */ (function () {
                function _MatMenuDirectivesModule() {
                }
                return _MatMenuDirectivesModule;
            }());
            _MatMenuDirectivesModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            exports: [MatMenuTrigger, MatMenuContent, _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            declarations: [MatMenuTrigger, MatMenuContent],
                            providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]
                        },] },
            ];
            var MatMenuModule = /** @class */ (function () {
                function MatMenuModule() {
                }
                return MatMenuModule;
            }());
            MatMenuModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatRippleModule"],
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__["OverlayModule"],
                                _MatMenuDirectivesModule,
                            ],
                            exports: [_MatMenu, MatMenuItem, _MatMenuDirectivesModule],
                            declarations: [_MatMenu, MatMenuItem],
                            providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=menu.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/radio.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/radio.js ***!
          \*********************************************************/
        /*! exports provided: MatRadioModule, MAT_RADIO_DEFAULT_OPTIONS_FACTORY, MAT_RADIO_DEFAULT_OPTIONS, MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR, MatRadioChange, MatRadioGroup, MatRadioButton */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioModule", function () { return MatRadioModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS_FACTORY", function () { return MAT_RADIO_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_DEFAULT_OPTIONS", function () { return MAT_RADIO_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR", function () { return MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioChange", function () { return MatRadioChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioGroup", function () { return MatRadioGroup; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRadioButton", function () { return MatRadioButton; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_RADIO_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["InjectionToken"]('mat-radio-default-options', {
                providedIn: 'root',
                factory: MAT_RADIO_DEFAULT_OPTIONS_FACTORY
            });
            /**
             * @return {?}
             */
            function MAT_RADIO_DEFAULT_OPTIONS_FACTORY() {
                return {
                    color: 'accent'
                };
            }
            // Increasing integer for generating unique ids for radio components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * Provider Expression that allows mat-radio-group to register as a ControlValueAccessor. This
             * allows it to support [(ngModel)] and ngControl.
             * \@docs-private
             * @type {?}
             */
            var MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatRadioGroup; })),
                multi: true
            };
            /**
             * Change event object emitted by MatRadio and MatRadioGroup.
             */
            var MatRadioChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} value
                 */
                function MatRadioChange(source, value) {
                    this.source = source;
                    this.value = value;
                }
                return MatRadioChange;
            }());
            /**
             * A group of radio buttons. May contain one or more `<mat-radio-button>` elements.
             */
            var MatRadioGroup = /** @class */ (function () {
                /**
                 * @param {?} _changeDetector
                 */
                function MatRadioGroup(_changeDetector) {
                    this._changeDetector = _changeDetector;
                    /**
                     * Selected value for the radio group.
                     */
                    this._value = null;
                    /**
                     * The HTML name attribute applied to radio buttons in this group.
                     */
                    this._name = "mat-radio-group-" + nextUniqueId++;
                    /**
                     * The currently selected radio button. Should match value.
                     */
                    this._selected = null;
                    /**
                     * Whether the `value` has been set to its initial value.
                     */
                    this._isInitialized = false;
                    /**
                     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
                     */
                    this._labelPosition = 'after';
                    /**
                     * Whether the radio group is disabled.
                     */
                    this._disabled = false;
                    /**
                     * Whether the radio group is required.
                     */
                    this._required = false;
                    /**
                     * The method to be called in order to update ngModel
                     */
                    this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     * \@docs-private
                     */
                    this.onTouched = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Event emitted when the group value changes.
                     * Change events are only emitted when the value changes due to user interaction with
                     * a radio button (the same behavior as `<input type-"radio">`).
                     */
                    this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                }
                Object.defineProperty(MatRadioGroup.prototype, "name", {
                    /**
                     * Name of the radio button group. All radio buttons inside this group will use this name.
                     * @return {?}
                     */
                    get: function () { return this._name; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._name = value;
                        this._updateRadioButtonNames();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "labelPosition", {
                    /**
                     * Whether the labels should appear after or before the radio-buttons. Defaults to 'after'
                     * @return {?}
                     */
                    get: function () {
                        return this._labelPosition;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._labelPosition = v === 'before' ? 'before' : 'after';
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "value", {
                    /**
                     * Value for the radio-group. Should equal the value of the selected radio button if there is
                     * a corresponding radio button with a matching value. If there is not such a corresponding
                     * radio button, this value persists to be applied in case a new radio button is added with a
                     * matching value.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) {
                        if (this._value !== newValue) {
                            // Set this before proceeding to ensure no circular loop occurs with selection.
                            this._value = newValue;
                            this._updateSelectedRadioFromValue();
                            this._checkSelectedRadioButton();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatRadioGroup.prototype._checkSelectedRadioButton = function () {
                    if (this._selected && !this._selected.checked) {
                        this._selected.checked = true;
                    }
                };
                Object.defineProperty(MatRadioGroup.prototype, "selected", {
                    /**
                     * The currently selected radio button. If set to a new radio button, the radio group value
                     * will be updated to match the new selected button.
                     * @return {?}
                     */
                    get: function () { return this._selected; },
                    /**
                     * @param {?} selected
                     * @return {?}
                     */
                    set: function (selected) {
                        this._selected = selected;
                        this.value = selected ? selected.value : null;
                        this._checkSelectedRadioButton();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "disabled", {
                    /**
                     * Whether the radio group is disabled
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioGroup.prototype, "required", {
                    /**
                     * Whether the radio group is required
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        this._markRadiosForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Initialize properties once content children are available.
                 * This allows us to propagate relevant attributes to associated buttons.
                 * @return {?}
                 */
                MatRadioGroup.prototype.ngAfterContentInit = function () {
                    // Mark this component as initialized in AfterContentInit because the initial value can
                    // possibly be set by NgModel on MatRadioGroup, and it is possible that the OnInit of the
                    // NgModel occurs *after* the OnInit of the MatRadioGroup.
                    this._isInitialized = true;
                };
                /**
                 * Mark this group as being "touched" (for ngModel). Meant to be called by the contained
                 * radio buttons upon their blur.
                 * @return {?}
                 */
                MatRadioGroup.prototype._touch = function () {
                    if (this.onTouched) {
                        this.onTouched();
                    }
                };
                /**
                 * @private
                 * @return {?}
                 */
                MatRadioGroup.prototype._updateRadioButtonNames = function () {
                    var _this = this;
                    if (this._radios) {
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) {
                            radio.name = _this.name;
                            radio._markForCheck();
                        }));
                    }
                };
                /**
                 * Updates the `selected` radio button from the internal _value state.
                 * @private
                 * @return {?}
                 */
                MatRadioGroup.prototype._updateSelectedRadioFromValue = function () {
                    var _this = this;
                    // If the value already matches the selected radio, do nothing.
                    /** @type {?} */
                    var isAlreadySelected = this._selected !== null && this._selected.value === this._value;
                    if (this._radios && !isAlreadySelected) {
                        this._selected = null;
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) {
                            radio.checked = _this.value === radio.value;
                            if (radio.checked) {
                                _this._selected = radio;
                            }
                        }));
                    }
                };
                /**
                 * Dispatch change event with current selection and group value.
                 * @return {?}
                 */
                MatRadioGroup.prototype._emitChangeEvent = function () {
                    if (this._isInitialized) {
                        this.change.emit(new MatRadioChange(( /** @type {?} */(this._selected)), this._value));
                    }
                };
                /**
                 * @return {?}
                 */
                MatRadioGroup.prototype._markRadiosForCheck = function () {
                    if (this._radios) {
                        this._radios.forEach(( /**
                         * @param {?} radio
                         * @return {?}
                         */function (/**
                         * @param {?} radio
                         * @return {?}
                         */ radio) { return radio._markForCheck(); }));
                    }
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatRadioGroup.prototype.writeValue = function (value) {
                    this.value = value;
                    this._changeDetector.markForCheck();
                };
                /**
                 * Registers a callback to be triggered when the model value changes.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatRadioGroup.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                /**
                 * Registers a callback to be triggered when the control is touched.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatRadioGroup.prototype.registerOnTouched = function (fn) {
                    this.onTouched = fn;
                };
                /**
                 * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.
                 * @param {?} isDisabled Whether the control should be disabled.
                 * @return {?}
                 */
                MatRadioGroup.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this._changeDetector.markForCheck();
                };
                return MatRadioGroup;
            }());
            MatRadioGroup.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Directive"], args: [{
                            selector: 'mat-radio-group',
                            exportAs: 'matRadioGroup',
                            providers: [MAT_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],
                            host: {
                                'role': 'radiogroup',
                                'class': 'mat-radio-group',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatRadioGroup.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] }
            ]; };
            MatRadioGroup.propDecorators = {
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                _radios: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ContentChildren"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_3__["forwardRef"])(( /**
                                         * @return {?}
                                         */function () { return MatRadioButton; })), { descendants: true },] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }]
            };
            // Boilerplate for applying mixins to MatRadioButton.
            /**
             * \@docs-private
             */
            var MatRadioButtonBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatRadioButtonBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatRadioButtonBase;
            }());
            // As per Material design specifications the selection control radio should use the accent color
            // palette by default. https://material.io/guidelines/components/selection-controls.html
            /** @type {?} */
            var _MatRadioButtonMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinTabIndex"])(MatRadioButtonBase));
            /**
             * A Material design radio-button. Typically placed inside of `<mat-radio-group>` elements.
             */
            var MatRadioButton = /** @class */ (function (_super) {
                __extends(MatRadioButton, _super);
                /**
                 * @param {?} radioGroup
                 * @param {?} elementRef
                 * @param {?} _changeDetector
                 * @param {?} _focusMonitor
                 * @param {?} _radioDispatcher
                 * @param {?=} _animationMode
                 * @param {?=} _providerOverride
                 */
                function MatRadioButton(radioGroup, elementRef, _changeDetector, _focusMonitor, _radioDispatcher, _animationMode, _providerOverride) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._changeDetector = _changeDetector;
                    _this._focusMonitor = _focusMonitor;
                    _this._radioDispatcher = _radioDispatcher;
                    _this._animationMode = _animationMode;
                    _this._providerOverride = _providerOverride;
                    _this._uniqueId = "mat-radio-" + ++nextUniqueId;
                    /**
                     * The unique ID for the radio button.
                     */
                    _this.id = _this._uniqueId;
                    /**
                     * Event emitted when the checked state of this radio button changes.
                     * Change events are only emitted when the value changes due to user interaction with
                     * the radio button (the same behavior as `<input type-"radio">`).
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                    /**
                     * Whether this radio is checked.
                     */
                    _this._checked = false;
                    /**
                     * Value assigned to this radio.
                     */
                    _this._value = null;
                    /**
                     * Unregister function for _radioDispatcher
                     */
                    _this._removeUniqueSelectionListener = ( /**
                     * @return {?}
                     */function () { });
                    // Assertions. Ideally these should be stripped out by the compiler.
                    // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.
                    _this.radioGroup = radioGroup;
                    _this._removeUniqueSelectionListener =
                        _radioDispatcher.listen(( /**
                         * @param {?} id
                         * @param {?} name
                         * @return {?}
                         */function (id, name) {
                            if (id !== _this.id && name === _this.name) {
                                _this.checked = false;
                            }
                        }));
                    return _this;
                }
                Object.defineProperty(MatRadioButton.prototype, "checked", {
                    /**
                     * Whether this radio button is checked.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newCheckedState = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._checked !== newCheckedState) {
                            this._checked = newCheckedState;
                            if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {
                                this.radioGroup.selected = this;
                            }
                            else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {
                                // When unchecking the selected radio button, update the selected radio
                                // property on the group.
                                this.radioGroup.selected = null;
                            }
                            if (newCheckedState) {
                                // Notify all radio buttons with the same name to un-check.
                                this._radioDispatcher.notify(this.id, this.name);
                            }
                            this._changeDetector.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "value", {
                    /**
                     * The value of this radio button.
                     * @return {?}
                     */
                    get: function () { return this._value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._value !== value) {
                            this._value = value;
                            if (this.radioGroup !== null) {
                                if (!this.checked) {
                                    // Update checked when the value changed to match the radio group's value
                                    this.checked = this.radioGroup.value === value;
                                }
                                if (this.checked) {
                                    this.radioGroup.selected = this;
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "labelPosition", {
                    /**
                     * Whether the label should appear after or before the radio button. Defaults to 'after'
                     * @return {?}
                     */
                    get: function () {
                        return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._labelPosition = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "disabled", {
                    /**
                     * Whether the radio button is disabled.
                     * @return {?}
                     */
                    get: function () {
                        return this._disabled || (this.radioGroup !== null && this.radioGroup.disabled);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        /** @type {?} */
                        var newDisabledState = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                        if (this._disabled !== newDisabledState) {
                            this._disabled = newDisabledState;
                            this._changeDetector.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "required", {
                    /**
                     * Whether the radio button is required.
                     * @return {?}
                     */
                    get: function () {
                        return this._required || (this.radioGroup && this.radioGroup.required);
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "color", {
                    /**
                     * Theme color of the radio button.
                     * @return {?}
                     */
                    get: function () {
                        return this._color ||
                            (this.radioGroup && this.radioGroup.color) ||
                            this._providerOverride && this._providerOverride.color || 'accent';
                    },
                    /**
                     * @param {?} newValue
                     * @return {?}
                     */
                    set: function (newValue) { this._color = newValue; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatRadioButton.prototype, "inputId", {
                    /**
                     * ID of the native input element inside `<mat-radio-button>`
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Focuses the radio button.
                 * @param {?=} options
                 * @return {?}
                 */
                MatRadioButton.prototype.focus = function (options) {
                    this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);
                };
                /**
                 * Marks the radio button as needing checking for change detection.
                 * This method is exposed because the parent radio group will directly
                 * update bound properties of the radio button.
                 * @return {?}
                 */
                MatRadioButton.prototype._markForCheck = function () {
                    // When group value changes, the button will not be notified. Use `markForCheck` to explicit
                    // update radio button's status
                    this._changeDetector.markForCheck();
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngOnInit = function () {
                    if (this.radioGroup) {
                        // If the radio is inside a radio group, determine if it should be checked
                        this.checked = this.radioGroup.value === this._value;
                        // Copy name from parent radio group
                        this.name = this.radioGroup.name;
                    }
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} focusOrigin
                 * @return {?}
                 */function (/**
                 * @param {?} focusOrigin
                 * @return {?}
                 */ focusOrigin) {
                        if (!focusOrigin && _this.radioGroup) {
                            _this.radioGroup._touch();
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    this._removeUniqueSelectionListener();
                };
                /**
                 * Dispatch change event with current value.
                 * @private
                 * @return {?}
                 */
                MatRadioButton.prototype._emitChangeEvent = function () {
                    this.change.emit(new MatRadioChange(this, this._value));
                };
                /**
                 * @return {?}
                 */
                MatRadioButton.prototype._isRippleDisabled = function () {
                    return this.disableRipple || this.disabled;
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatRadioButton.prototype._onInputClick = function (event) {
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `radio-button` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                };
                /**
                 * Triggered when the radio button received a click or the input recognized any change.
                 * Clicking on a label element, will trigger a change event on the associated input.
                 * @param {?} event
                 * @return {?}
                 */
                MatRadioButton.prototype._onInputChange = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the `change` output.
                    event.stopPropagation();
                    /** @type {?} */
                    var groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;
                    this.checked = true;
                    this._emitChangeEvent();
                    if (this.radioGroup) {
                        this.radioGroup._controlValueAccessorChangeFn(this.value);
                        if (groupValueChanged) {
                            this.radioGroup._emitChangeEvent();
                        }
                    }
                };
                return MatRadioButton;
            }(_MatRadioButtonMixinBase));
            MatRadioButton.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Component"], args: [{ selector: 'mat-radio-button',
                            template: "<label [attr.for]=\"inputId\" class=\"mat-radio-label\" #label><div class=\"mat-radio-container\"><div class=\"mat-radio-outer-circle\"></div><div class=\"mat-radio-inner-circle\"></div><div mat-ripple class=\"mat-radio-ripple\" [matRippleTrigger]=\"label\" [matRippleDisabled]=\"_isRippleDisabled()\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-radio-persistent-ripple\"></div></div><input #input class=\"mat-radio-input cdk-visually-hidden\" type=\"radio\" [id]=\"inputId\" [checked]=\"checked\" [disabled]=\"disabled\" [tabIndex]=\"tabIndex\" [attr.name]=\"name\" [attr.value]=\"value\" [required]=\"required\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" [attr.aria-describedby]=\"ariaDescribedby\" (change)=\"_onInputChange($event)\" (click)=\"_onInputClick($event)\"></div><div class=\"mat-radio-label-content\" [class.mat-radio-label-before]=\"labelPosition == 'before'\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></div></label>",
                            styles: [".mat-radio-button{display:inline-block;-webkit-tap-highlight-color:transparent;outline:0}.mat-radio-label{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;vertical-align:middle;width:100%}.mat-radio-container{box-sizing:border-box;display:inline-block;position:relative;width:20px;height:20px;flex-shrink:0}.mat-radio-outer-circle{box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:border-color ease 280ms;width:20px;border-width:2px;border-style:solid;border-radius:50%}._mat-animation-noopable .mat-radio-outer-circle{transition:none}.mat-radio-inner-circle{border-radius:50%;box-sizing:border-box;height:20px;left:0;position:absolute;top:0;transition:transform ease 280ms,background-color ease 280ms;width:20px;transform:scale(.001)}._mat-animation-noopable .mat-radio-inner-circle{transition:none}.mat-radio-checked .mat-radio-inner-circle{transform:scale(.5)}@media (-ms-high-contrast:active){.mat-radio-checked .mat-radio-inner-circle{border:solid 10px}}.mat-radio-label-content{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:inline-block;order:0;line-height:inherit;padding-left:8px;padding-right:0}[dir=rtl] .mat-radio-label-content{padding-right:8px;padding-left:0}.mat-radio-label-content.mat-radio-label-before{order:-1;padding-left:0;padding-right:8px}[dir=rtl] .mat-radio-label-content.mat-radio-label-before{padding-right:0;padding-left:8px}.mat-radio-disabled,.mat-radio-disabled .mat-radio-label{cursor:default}.mat-radio-button .mat-radio-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-radio-button .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple){opacity:.16}.mat-radio-persistent-ripple{width:100%;height:100%;transform:none}.mat-radio-container:hover .mat-radio-persistent-ripple{opacity:.04}.mat-radio-button:not(.mat-radio-disabled).cdk-keyboard-focused .mat-radio-persistent-ripple,.mat-radio-button:not(.mat-radio-disabled).cdk-program-focused .mat-radio-persistent-ripple{opacity:.12}.mat-radio-disabled .mat-radio-container:hover .mat-radio-persistent-ripple,.mat-radio-persistent-ripple{opacity:0}@media (hover:none){.mat-radio-container:hover .mat-radio-persistent-ripple{display:none}}.mat-radio-input{bottom:0;left:50%}@media (-ms-high-contrast:active){.mat-radio-disabled{opacity:.5}}"],
                            inputs: ['disableRipple', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewEncapsulation"].None,
                            exportAs: 'matRadioButton',
                            host: {
                                'class': 'mat-radio-button',
                                '[class.mat-radio-checked]': 'checked',
                                '[class.mat-radio-disabled]': 'disabled',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '[class.mat-primary]': 'color === "primary"',
                                '[class.mat-accent]': 'color === "accent"',
                                '[class.mat-warn]': 'color === "warn"',
                                // Needs to be -1 so the `focus` event still fires.
                                '[attr.tabindex]': '-1',
                                '[attr.id]': 'id',
                                '[attr.aria-label]': 'null',
                                '[attr.aria-labelledby]': 'null',
                                '[attr.aria-describedby]': 'null',
                                // Note: under normal conditions focus shouldn't land on this element, however it may be
                                // programmatically set, for example inside of a focus trap, in this case we want to forward
                                // the focus to the native element.
                                '(focus)': '_inputElement.nativeElement.focus()',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatRadioButton.ctorParameters = function () { return [
                { type: MatRadioGroup, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ChangeDetectorRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_2__["UniqueSelectionDispatcher"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__["ANIMATION_MODULE_TYPE"],] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Inject"], args: [MAT_RADIO_DEFAULT_OPTIONS,] }] }
            ]; };
            MatRadioButton.propDecorators = {
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-labelledby',] }],
                ariaDescribedby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"], args: ['aria-describedby',] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                color: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["Output"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["ViewChild"], args: ['input', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatRadioModule = /** @class */ (function () {
                function MatRadioModule() {
                }
                return MatRadioModule;
            }());
            MatRadioModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_3__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]],
                            exports: [MatRadioGroup, MatRadioButton, _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]],
                            declarations: [MatRadioGroup, MatRadioButton],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=radio.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/sidenav.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/sidenav.js ***!
          \***********************************************************/
        /*! exports provided: MatSidenavModule, throwMatDuplicatedDrawerError, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MAT_DRAWER_DEFAULT_AUTOSIZE, MatDrawerContent, MatDrawer, MatDrawerContainer, MatSidenavContent, MatSidenav, MatSidenavContainer, matDrawerAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSidenavModule", function () { return MatSidenavModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwMatDuplicatedDrawerError", function () { return throwMatDuplicatedDrawerError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY", function () { return MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_DRAWER_DEFAULT_AUTOSIZE", function () { return MAT_DRAWER_DEFAULT_AUTOSIZE; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDrawerContent", function () { return MatDrawerContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDrawer", function () { return MatDrawer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatDrawerContainer", function () { return MatDrawerContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSidenavContent", function () { return MatSidenavContent; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSidenav", function () { return MatSidenav; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSidenavContainer", function () { return MatSidenavContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matDrawerAnimations", function () { return matDrawerAnimations; });
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/scrolling */ "./node_modules/@angular/cdk/esm2015/scrolling.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material drawers.
             * \@docs-private
             * @type {?}
             */
            var matDrawerAnimations = {
                /**
                 * Animation that slides a drawer in and out.
                 */
                transformDrawer: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["trigger"])('transform', [
                    // We remove the `transform` here completely, rather than setting it to zero, because:
                    // 1. Having a transform can cause elements with ripples or an animated
                    //    transform to shift around in Chrome with an RTL layout (see #10023).
                    // 2. 3d transforms causes text to appear blurry on IE and Edge.
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('open, open-instant', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                        'transform': 'none',
                        'visibility': 'visible',
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["state"])('void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
                        // Avoids the shadow showing up when closed in SSR.
                        'box-shadow': 'none',
                        'visibility': 'hidden',
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void => open-instant', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('0ms')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["transition"])('void <=> open, open-instant => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Throws an exception when two MatDrawer are matching the same position.
             * \@docs-private
             * @param {?} position
             * @return {?}
             */
            function throwMatDuplicatedDrawerError(position) {
                throw Error("A drawer was already declared for 'position=\"" + position + "\"'");
            }
            /**
             * Configures whether drawers should use auto sizing by default.
             * @type {?}
             */
            var MAT_DRAWER_DEFAULT_AUTOSIZE = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["InjectionToken"]('MAT_DRAWER_DEFAULT_AUTOSIZE', {
                providedIn: 'root',
                factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {
                return false;
            }
            var MatDrawerContent = /** @class */ (function (_super) {
                __extends(MatDrawerContent, _super);
                /**
                 * @param {?} _changeDetectorRef
                 * @param {?} _container
                 * @param {?} elementRef
                 * @param {?} scrollDispatcher
                 * @param {?} ngZone
                 */
                function MatDrawerContent(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {
                    var _this = _super.call(this, elementRef, scrollDispatcher, ngZone) || this;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._container = _container;
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatDrawerContent.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._container._contentMarginChanges.subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._changeDetectorRef.markForCheck();
                    }));
                };
                return MatDrawerContent;
            }(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__["CdkScrollable"]));
            MatDrawerContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"], args: [{ selector: 'mat-drawer-content',
                            template: '<ng-content></ng-content>',
                            host: {
                                'class': 'mat-drawer-content',
                                '[style.margin-left.px]': '_container._contentMargins.left',
                                '[style.margin-right.px]': '_container._contentMargins.right',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatDrawerContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"] },
                { type: MatDrawerContainer, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatDrawerContainer; })),] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__["ScrollDispatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgZone"] }
            ]; };
            /**
             * This component corresponds to a drawer that can be opened on the drawer container.
             */
            var MatDrawer = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 * @param {?} _focusTrapFactory
                 * @param {?} _focusMonitor
                 * @param {?} _platform
                 * @param {?} _ngZone
                 * @param {?} _doc
                 */
                function MatDrawer(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc) {
                    var _this = this;
                    this._elementRef = _elementRef;
                    this._focusTrapFactory = _focusTrapFactory;
                    this._focusMonitor = _focusMonitor;
                    this._platform = _platform;
                    this._ngZone = _ngZone;
                    this._doc = _doc;
                    this._elementFocusedBeforeDrawerWasOpened = null;
                    /**
                     * Whether the drawer is initialized. Used for disabling the initial animation.
                     */
                    this._enableAnimations = false;
                    this._position = 'start';
                    this._mode = 'over';
                    this._disableClose = false;
                    this._autoFocus = true;
                    /**
                     * Emits whenever the drawer has started animating.
                     */
                    this._animationStarted = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    /**
                     * Emits whenever the drawer is done animating.
                     */
                    this._animationEnd = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    /**
                     * Current state of the sidenav animation.
                     */
                    // @HostBinding is used in the class as it is expected to be extended.  Since @Component decorator
                    // metadata is not inherited by child classes, instead the host binding data is defined in a way
                    // that can be inherited.
                    // tslint:disable:no-host-decorator-in-concrete
                    this._animationState = 'void';
                    /**
                     * Event emitted when the drawer open state is changed.
                     */
                    this.openedChange =
                        // Note this has to be async in order to avoid some issues with two-bindings (see #8872).
                        new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"](/* isAsync */ true);
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    /**
                     * Event emitted when the drawer's position changes.
                     */
                    // tslint:disable-next-line:no-output-on-prefix
                    this.onPositionChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    /**
                     * An observable that emits when the drawer mode changes. This is used by the drawer container to
                     * to know when to when the mode changes so it can adapt the margins on the content.
                     */
                    this._modeChanged = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    this._opened = false;
                    this.openedChange.subscribe(( /**
                     * @param {?} opened
                     * @return {?}
                     */function (opened) {
                        if (opened) {
                            if (_this._doc) {
                                _this._elementFocusedBeforeDrawerWasOpened = ( /** @type {?} */(_this._doc.activeElement));
                            }
                            if (_this._isFocusTrapEnabled && _this._focusTrap) {
                                _this._trapFocus();
                            }
                        }
                        else {
                            _this._restoreFocus();
                        }
                    }));
                    /**
                     * Listen to `keydown` events outside the zone so that change detection is not run every
                     * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed
                     * and we don't have close disabled.
                     */
                    this._ngZone.runOutsideAngular(( /**
                     * @return {?}
                     */function () {
                        (( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["fromEvent"])(_this._elementRef.nativeElement, 'keydown')))).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) {
                            return event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["ESCAPE"] && !_this.disableClose && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_4__["hasModifierKey"])(event);
                        })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(_this._destroyed)).subscribe(( /**
                         * @param {?} event
                         * @return {?}
                         */function (/**
                         * @param {?} event
                         * @return {?}
                         */ event) { return _this._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            _this.close();
                            event.stopPropagation();
                            event.preventDefault();
                        })); }));
                    }));
                    // We need a Subject with distinctUntilChanged, because the `done` event
                    // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
                    this._animationEnd.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) {
                        return x.fromState === y.fromState && x.toState === y.toState;
                    }))).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) {
                        var fromState = event.fromState, toState = event.toState;
                        if ((toState.indexOf('open') === 0 && fromState === 'void') ||
                            (toState === 'void' && fromState.indexOf('open') === 0)) {
                            _this.openedChange.emit(_this._opened);
                        }
                    }));
                }
                Object.defineProperty(MatDrawer.prototype, "position", {
                    /**
                     * The side that the drawer is attached to.
                     * @return {?}
                     */
                    get: function () { return this._position; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        // Make sure we have a valid value.
                        value = value === 'end' ? 'end' : 'start';
                        if (value != this._position) {
                            this._position = value;
                            this.onPositionChanged.emit();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "mode", {
                    /**
                     * Mode of the drawer; one of 'over', 'push' or 'side'.
                     * @return {?}
                     */
                    get: function () { return this._mode; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._mode = value;
                        this._updateFocusTrapState();
                        this._modeChanged.next();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "disableClose", {
                    /**
                     * Whether the drawer can be closed with the escape key or by clicking on the backdrop.
                     * @return {?}
                     */
                    get: function () { return this._disableClose; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disableClose = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "autoFocus", {
                    /**
                     * Whether the drawer should focus the first focusable element automatically when opened.
                     * @return {?}
                     */
                    get: function () { return this._autoFocus; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._autoFocus = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "_openedStream", {
                    /**
                     * Event emitted when the drawer has been opened.
                     * @return {?}
                     */
                    get: function () {
                        return this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                         * @param {?} o
                         * @return {?}
                         */function (/**
                         * @param {?} o
                         * @return {?}
                         */ o) { return o; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(( /**
                         * @return {?}
                         */function () { })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "openedStart", {
                    /**
                     * Event emitted when the drawer has started opening.
                     * @return {?}
                     */
                    get: function () {
                        return this._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                         * @param {?} e
                         * @return {?}
                         */function (/**
                         * @param {?} e
                         * @return {?}
                         */ e) { return e.fromState !== e.toState && e.toState.indexOf('open') === 0; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(( /**
                         * @return {?}
                         */function () { })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "_closedStream", {
                    /**
                     * Event emitted when the drawer has been closed.
                     * @return {?}
                     */
                    get: function () {
                        return this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                         * @param {?} o
                         * @return {?}
                         */function (/**
                         * @param {?} o
                         * @return {?}
                         */ o) { return !o; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(( /**
                         * @return {?}
                         */function () { })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "closedStart", {
                    /**
                     * Event emitted when the drawer has started closing.
                     * @return {?}
                     */
                    get: function () {
                        return this._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                         * @param {?} e
                         * @return {?}
                         */function (/**
                         * @param {?} e
                         * @return {?}
                         */ e) { return e.fromState !== e.toState && e.toState === 'void'; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["map"])(( /**
                         * @return {?}
                         */function () { })));
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawer.prototype, "_isFocusTrapEnabled", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        // The focus trap is only enabled when the drawer is open in any mode other than side.
                        return this.opened && this.mode !== 'side';
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Traps focus inside the drawer.
                 * @private
                 * @return {?}
                 */
                MatDrawer.prototype._trapFocus = function () {
                    var _this = this;
                    if (!this.autoFocus) {
                        return;
                    }
                    this._focusTrap.focusInitialElementWhenReady().then(( /**
                     * @param {?} hasMovedFocus
                     * @return {?}
                     */function (/**
                     * @param {?} hasMovedFocus
                     * @return {?}
                     */ hasMovedFocus) {
                        // If there were no focusable elements, focus the sidenav itself so the keyboard navigation
                        // still works. We need to check that `focus` is a function due to Universal.
                        if (!hasMovedFocus && typeof _this._elementRef.nativeElement.focus === 'function') {
                            _this._elementRef.nativeElement.focus();
                        }
                    }));
                };
                /**
                 * If focus is currently inside the drawer, restores it to where it was before the drawer
                 * opened.
                 * @private
                 * @return {?}
                 */
                MatDrawer.prototype._restoreFocus = function () {
                    if (!this.autoFocus) {
                        return;
                    }
                    /** @type {?} */
                    var activeEl = this._doc && this._doc.activeElement;
                    if (activeEl && this._elementRef.nativeElement.contains(activeEl)) {
                        if (this._elementFocusedBeforeDrawerWasOpened instanceof HTMLElement) {
                            this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);
                        }
                        else {
                            this._elementRef.nativeElement.blur();
                        }
                    }
                    this._elementFocusedBeforeDrawerWasOpened = null;
                    this._openedVia = null;
                };
                /**
                 * @return {?}
                 */
                MatDrawer.prototype.ngAfterContentInit = function () {
                    this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
                    this._updateFocusTrapState();
                };
                /**
                 * @return {?}
                 */
                MatDrawer.prototype.ngAfterContentChecked = function () {
                    // Enable the animations after the lifecycle hooks have run, in order to avoid animating
                    // drawers that are open by default. When we're on the server, we shouldn't enable the
                    // animations, because we don't want the drawer to animate the first time the user sees
                    // the page.
                    if (this._platform.isBrowser) {
                        this._enableAnimations = true;
                    }
                };
                /**
                 * @return {?}
                 */
                MatDrawer.prototype.ngOnDestroy = function () {
                    if (this._focusTrap) {
                        this._focusTrap.destroy();
                    }
                    this._animationStarted.complete();
                    this._animationEnd.complete();
                    this._modeChanged.complete();
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                Object.defineProperty(MatDrawer.prototype, "opened", {
                    /**
                     * Whether the drawer is opened. We overload this because we trigger an event when it
                     * starts or end.
                     * @return {?}
                     */
                    get: function () { return this._opened; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this.toggle(Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value)); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Open the drawer.
                 * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
                 * Used for focus management after the sidenav is closed.
                 * @return {?}
                 */
                MatDrawer.prototype.open = function (openedVia) {
                    return this.toggle(true, openedVia);
                };
                /**
                 * Close the drawer.
                 * @return {?}
                 */
                MatDrawer.prototype.close = function () {
                    return this.toggle(false);
                };
                /**
                 * Toggle this drawer.
                 * @param {?=} isOpen Whether the drawer should be open.
                 * @param {?=} openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
                 * Used for focus management after the sidenav is closed.
                 * @return {?}
                 */
                MatDrawer.prototype.toggle = function (isOpen, openedVia) {
                    var _this = this;
                    if (isOpen === void 0) { isOpen = !this.opened; }
                    if (openedVia === void 0) { openedVia = 'program'; }
                    this._opened = isOpen;
                    if (isOpen) {
                        this._animationState = this._enableAnimations ? 'open' : 'open-instant';
                        this._openedVia = openedVia;
                    }
                    else {
                        this._animationState = 'void';
                        this._restoreFocus();
                    }
                    this._updateFocusTrapState();
                    return new Promise(( /**
                     * @param {?} resolve
                     * @return {?}
                     */function (/**
                     * @param {?} resolve
                     * @return {?}
                     */ resolve) {
                        _this.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(( /**
                         * @param {?} open
                         * @return {?}
                         */function (/**
                         * @param {?} open
                         * @return {?}
                         */ open) { return resolve(open ? 'open' : 'close'); }));
                    }));
                };
                Object.defineProperty(MatDrawer.prototype, "_width", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Updates the enabled state of the focus trap.
                 * @private
                 * @return {?}
                 */
                MatDrawer.prototype._updateFocusTrapState = function () {
                    if (this._focusTrap) {
                        this._focusTrap.enabled = this._isFocusTrapEnabled;
                    }
                };
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDrawer.prototype._animationStartListener = function (event) {
                    this._animationStarted.next(event);
                };
                // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.
                // In Ivy the `host` bindings will be merged when this class is extended, whereas in
                // ViewEngine they're overwritten.
                // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.
                // tslint:disable-next-line:no-host-decorator-in-concrete
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatDrawer.prototype._animationDoneListener = function (event) {
                    this._animationEnd.next(event);
                };
                return MatDrawer;
            }());
            MatDrawer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"], args: [{ selector: 'mat-drawer',
                            exportAs: 'matDrawer',
                            template: "<div class=\"mat-drawer-inner-container\"><ng-content></ng-content></div>",
                            animations: [matDrawerAnimations.transformDrawer],
                            host: {
                                'class': 'mat-drawer',
                                // must prevent the browser from aligning text based on value
                                '[attr.align]': 'null',
                                '[class.mat-drawer-end]': 'position === "end"',
                                '[class.mat-drawer-over]': 'mode === "over"',
                                '[class.mat-drawer-push]': 'mode === "push"',
                                '[class.mat-drawer-side]': 'mode === "side"',
                                '[class.mat-drawer-opened]': 'opened',
                                'tabIndex': '-1',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatDrawer.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusTrapFactory"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__["Platform"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_7__["DOCUMENT"],] }] }
            ]; };
            MatDrawer.propDecorators = {
                position: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                mode: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                disableClose: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                autoFocus: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                _animationState: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["HostBinding"], args: ['@transform',] }],
                openedChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"] }],
                _openedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"], args: ['opened',] }],
                openedStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"] }],
                _closedStream: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"], args: ['closed',] }],
                closedStart: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"] }],
                onPositionChanged: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"], args: ['positionChanged',] }],
                opened: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                _animationStartListener: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["HostListener"], args: ['@transform.start', ['$event'],] }],
                _animationDoneListener: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["HostListener"], args: ['@transform.done', ['$event'],] }]
            };
            /**
             * `<mat-drawer-container>` component.
             *
             * This is the parent component to one or two `<mat-drawer>`s that validates the state internally
             * and coordinates the backdrop and content styling.
             */
            var MatDrawerContainer = /** @class */ (function () {
                /**
                 * @param {?} _dir
                 * @param {?} _element
                 * @param {?} _ngZone
                 * @param {?} _changeDetectorRef
                 * @param {?} viewportRuler
                 * @param {?=} defaultAutosize
                 * @param {?=} _animationMode
                 */
                function MatDrawerContainer(_dir, _element, _ngZone, _changeDetectorRef, viewportRuler, defaultAutosize, _animationMode) {
                    var _this = this;
                    if (defaultAutosize === void 0) { defaultAutosize = false; }
                    this._dir = _dir;
                    this._element = _element;
                    this._ngZone = _ngZone;
                    this._changeDetectorRef = _changeDetectorRef;
                    this._animationMode = _animationMode;
                    /**
                     * Event emitted when the drawer backdrop is clicked.
                     */
                    this.backdropClick = new _angular_core__WEBPACK_IMPORTED_MODULE_8__["EventEmitter"]();
                    /**
                     * Emits when the component is destroyed.
                     */
                    this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    /**
                     * Emits on every ngDoCheck. Used for debouncing reflows.
                     */
                    this._doCheckSubject = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    /**
                     * Margins to be applied to the content. These are used to push / shrink the drawer content when a
                     * drawer is open. We use margin rather than transform even for push mode because transform breaks
                     * fixed position elements inside of the transformed element.
                     */
                    this._contentMargins = { left: null, right: null };
                    this._contentMarginChanges = new rxjs__WEBPACK_IMPORTED_MODULE_9__["Subject"]();
                    // If a `Dir` directive exists up the tree, listen direction changes
                    // and update the left/right properties to point to the proper start/end.
                    if (_dir) {
                        _dir.change.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroyed)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._validateDrawers();
                            _this.updateContentMargins();
                        }));
                    }
                    // Since the minimum width of the sidenav depends on the viewport width,
                    // we need to recompute the margins if the viewport changes.
                    viewportRuler.change()
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroyed))
                        .subscribe(( /**
                 * @return {?}
                 */function () { return _this.updateContentMargins(); }));
                    this._autosize = defaultAutosize;
                }
                Object.defineProperty(MatDrawerContainer.prototype, "start", {
                    /**
                     * The drawer child with the `start` position.
                     * @return {?}
                     */
                    get: function () { return this._start; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawerContainer.prototype, "end", {
                    /**
                     * The drawer child with the `end` position.
                     * @return {?}
                     */
                    get: function () { return this._end; },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawerContainer.prototype, "autosize", {
                    /**
                     * Whether to automatically resize the container whenever
                     * the size of any of its drawers changes.
                     *
                     * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring
                     * the drawers on every change detection cycle. Can be configured globally via the
                     * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.
                     * @return {?}
                     */
                    get: function () { return this._autosize; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._autosize = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawerContainer.prototype, "hasBackdrop", {
                    /**
                     * Whether the drawer container should have a backdrop while one of the sidenavs is open.
                     * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`
                     * mode as well.
                     * @return {?}
                     */
                    get: function () {
                        if (this._backdropOverride == null) {
                            return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';
                        }
                        return this._backdropOverride;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._backdropOverride = value == null ? null : Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatDrawerContainer.prototype, "scrollable", {
                    /**
                     * Reference to the CdkScrollable instance that wraps the scrollable content.
                     * @return {?}
                     */
                    get: function () {
                        return this._userContent || this._content;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatDrawerContainer.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._drawers.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["startWith"])(null)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._validateDrawers();
                        _this._drawers.forEach(( /**
                         * @param {?} drawer
                         * @return {?}
                         */function (drawer) {
                            _this._watchDrawerToggle(drawer);
                            _this._watchDrawerPosition(drawer);
                            _this._watchDrawerMode(drawer);
                        }));
                        if (!_this._drawers.length ||
                            _this._isDrawerOpen(_this._start) ||
                            _this._isDrawerOpen(_this._end)) {
                            _this.updateContentMargins();
                        }
                        _this._changeDetectorRef.markForCheck();
                    }));
                    this._doCheckSubject.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["debounceTime"])(10), // Arbitrary debounce time, less than a frame at 60fps
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () { return _this.updateContentMargins(); }));
                };
                /**
                 * @return {?}
                 */
                MatDrawerContainer.prototype.ngOnDestroy = function () {
                    this._contentMarginChanges.complete();
                    this._doCheckSubject.complete();
                    this._destroyed.next();
                    this._destroyed.complete();
                };
                /**
                 * Calls `open` of both start and end drawers
                 * @return {?}
                 */
                MatDrawerContainer.prototype.open = function () {
                    this._drawers.forEach(( /**
                     * @param {?} drawer
                     * @return {?}
                     */function (/**
                     * @param {?} drawer
                     * @return {?}
                     */ drawer) { return drawer.open(); }));
                };
                /**
                 * Calls `close` of both start and end drawers
                 * @return {?}
                 */
                MatDrawerContainer.prototype.close = function () {
                    this._drawers.forEach(( /**
                     * @param {?} drawer
                     * @return {?}
                     */function (/**
                     * @param {?} drawer
                     * @return {?}
                     */ drawer) { return drawer.close(); }));
                };
                /**
                 * Recalculates and updates the inline styles for the content. Note that this should be used
                 * sparingly, because it causes a reflow.
                 * @return {?}
                 */
                MatDrawerContainer.prototype.updateContentMargins = function () {
                    var _this = this;
                    // 1. For drawers in `over` mode, they don't affect the content.
                    // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the
                    //    left margin (for left drawer) or right margin (for right the drawer).
                    // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by
                    //    adding to the left or right margin and simultaneously subtracting the same amount of
                    //    margin from the other side.
                    /** @type {?} */
                    var left = 0;
                    /** @type {?} */
                    var right = 0;
                    if (this._left && this._left.opened) {
                        if (this._left.mode == 'side') {
                            left += this._left._width;
                        }
                        else if (this._left.mode == 'push') {
                            /** @type {?} */
                            var width = this._left._width;
                            left += width;
                            right -= width;
                        }
                    }
                    if (this._right && this._right.opened) {
                        if (this._right.mode == 'side') {
                            right += this._right._width;
                        }
                        else if (this._right.mode == 'push') {
                            /** @type {?} */
                            var width = this._right._width;
                            right += width;
                            left -= width;
                        }
                    }
                    // If either `right` or `left` is zero, don't set a style to the element. This
                    // allows users to specify a custom size via CSS class in SSR scenarios where the
                    // measured widths will always be zero. Note that we reset to `null` here, rather
                    // than below, in order to ensure that the types in the `if` below are consistent.
                    left = left || ( /** @type {?} */(null));
                    right = right || ( /** @type {?} */(null));
                    if (left !== this._contentMargins.left || right !== this._contentMargins.right) {
                        this._contentMargins = { left: left, right: right };
                        // Pull back into the NgZone since in some cases we could be outside. We need to be careful
                        // to do it only when something changed, otherwise we can end up hitting the zone too often.
                        this._ngZone.run(( /**
                         * @return {?}
                         */function () { return _this._contentMarginChanges.next(_this._contentMargins); }));
                    }
                };
                /**
                 * @return {?}
                 */
                MatDrawerContainer.prototype.ngDoCheck = function () {
                    var _this = this;
                    // If users opted into autosizing, do a check every change detection cycle.
                    if (this._autosize && this._isPushed()) {
                        // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () { return _this._doCheckSubject.next(); }));
                    }
                };
                /**
                 * Subscribes to drawer events in order to set a class on the main container element when the
                 * drawer is open and the backdrop is visible. This ensures any overflow on the container element
                 * is properly hidden.
                 * @private
                 * @param {?} drawer
                 * @return {?}
                 */
                MatDrawerContainer.prototype._watchDrawerToggle = function (drawer) {
                    var _this = this;
                    drawer._animationStarted.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["filter"])(( /**
                     * @param {?} event
                     * @return {?}
                     */function (event) { return event.fromState !== event.toState; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._drawers.changes))
                        .subscribe(( /**
                 * @param {?} event
                 * @return {?}
                 */function (event) {
                        // Set the transition class on the container so that the animations occur. This should not
                        // be set initially because animations should only be triggered via a change in state.
                        if (event.toState !== 'open-instant' && _this._animationMode !== 'NoopAnimations') {
                            _this._element.nativeElement.classList.add('mat-drawer-transition');
                        }
                        _this.updateContentMargins();
                        _this._changeDetectorRef.markForCheck();
                    }));
                    if (drawer.mode !== 'side') {
                        drawer.openedChange.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._drawers.changes)).subscribe(( /**
                         * @return {?}
                         */function () { return _this._setContainerClass(drawer.opened); }));
                    }
                };
                /**
                 * Subscribes to drawer onPositionChanged event in order to
                 * re-validate drawers when the position changes.
                 * @private
                 * @param {?} drawer
                 * @return {?}
                 */
                MatDrawerContainer.prototype._watchDrawerPosition = function (drawer) {
                    var _this = this;
                    if (!drawer) {
                        return;
                    }
                    // NOTE: We need to wait for the microtask queue to be empty before validating,
                    // since both drawers may be swapping positions at the same time.
                    drawer.onPositionChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(this._drawers.changes)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._ngZone.onMicrotaskEmpty.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["take"])(1)).subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._validateDrawers();
                        }));
                    }));
                };
                /**
                 * Subscribes to changes in drawer mode so we can run change detection.
                 * @private
                 * @param {?} drawer
                 * @return {?}
                 */
                MatDrawerContainer.prototype._watchDrawerMode = function (drawer) {
                    var _this = this;
                    if (drawer) {
                        drawer._modeChanged.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__["takeUntil"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__["merge"])(this._drawers.changes, this._destroyed)))
                            .subscribe(( /**
                     * @return {?}
                     */function () {
                            _this.updateContentMargins();
                            _this._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element.
                 * @private
                 * @param {?} isAdd
                 * @return {?}
                 */
                MatDrawerContainer.prototype._setContainerClass = function (isAdd) {
                    /** @type {?} */
                    var classList = this._element.nativeElement.classList;
                    /** @type {?} */
                    var className = 'mat-drawer-container-has-open';
                    if (isAdd) {
                        classList.add(className);
                    }
                    else {
                        classList.remove(className);
                    }
                };
                /**
                 * Validate the state of the drawer children components.
                 * @private
                 * @return {?}
                 */
                MatDrawerContainer.prototype._validateDrawers = function () {
                    var _this = this;
                    this._start = this._end = null;
                    // Ensure that we have at most one start and one end drawer.
                    this._drawers.forEach(( /**
                     * @param {?} drawer
                     * @return {?}
                     */function (/**
                     * @param {?} drawer
                     * @return {?}
                     */ drawer) {
                        if (drawer.position == 'end') {
                            if (_this._end != null) {
                                throwMatDuplicatedDrawerError('end');
                            }
                            _this._end = drawer;
                        }
                        else {
                            if (_this._start != null) {
                                throwMatDuplicatedDrawerError('start');
                            }
                            _this._start = drawer;
                        }
                    }));
                    this._right = this._left = null;
                    // Detect if we're LTR or RTL.
                    if (this._dir && this._dir.value === 'rtl') {
                        this._left = this._end;
                        this._right = this._start;
                    }
                    else {
                        this._left = this._start;
                        this._right = this._end;
                    }
                };
                /**
                 * Whether the container is being pushed to the side by one of the drawers.
                 * @private
                 * @return {?}
                 */
                MatDrawerContainer.prototype._isPushed = function () {
                    return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||
                        (this._isDrawerOpen(this._end) && this._end.mode != 'over');
                };
                /**
                 * @return {?}
                 */
                MatDrawerContainer.prototype._onBackdropClicked = function () {
                    this.backdropClick.emit();
                    this._closeModalDrawer();
                };
                /**
                 * @return {?}
                 */
                MatDrawerContainer.prototype._closeModalDrawer = function () {
                    var _this = this;
                    // Close all open drawers where closing is not disabled and the mode is not `side`.
                    [this._start, this._end]
                        .filter(( /**
                 * @param {?} drawer
                 * @return {?}
                 */function (/**
                 * @param {?} drawer
                 * @return {?}
                 */ drawer) { return drawer && !drawer.disableClose && _this._canHaveBackdrop(drawer); }))
                        .forEach(( /**
                 * @param {?} drawer
                 * @return {?}
                 */function (/**
                 * @param {?} drawer
                 * @return {?}
                 */ drawer) { return ( /** @type {?} */(drawer)).close(); }));
                };
                /**
                 * @return {?}
                 */
                MatDrawerContainer.prototype._isShowingBackdrop = function () {
                    return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||
                        (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));
                };
                /**
                 * @private
                 * @param {?} drawer
                 * @return {?}
                 */
                MatDrawerContainer.prototype._canHaveBackdrop = function (drawer) {
                    return drawer.mode !== 'side' || !!this._backdropOverride;
                };
                /**
                 * @private
                 * @param {?} drawer
                 * @return {?}
                 */
                MatDrawerContainer.prototype._isDrawerOpen = function (drawer) {
                    return drawer != null && drawer.opened;
                };
                return MatDrawerContainer;
            }());
            MatDrawerContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"], args: [{ selector: 'mat-drawer-container',
                            exportAs: 'matDrawerContainer',
                            template: "<div class=\"mat-drawer-backdrop\" (click)=\"_onBackdropClicked()\" *ngIf=\"hasBackdrop\" [class.mat-drawer-shown]=\"_isShowingBackdrop()\"></div><ng-content select=\"mat-drawer\"></ng-content><ng-content select=\"mat-drawer-content\"></ng-content><mat-drawer-content *ngIf=\"!_content\"><ng-content></ng-content></mat-drawer-content>",
                            styles: [".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}"],
                            host: {
                                'class': 'mat-drawer-container',
                                '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatDrawerContainer.ctorParameters = function () { return [
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__["ViewportRuler"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"], args: [MAT_DRAWER_DEFAULT_AUTOSIZE,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_11__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatDrawerContainer.propDecorators = {
                _drawers: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChildren"], args: [MatDrawer,] }],
                _content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChild"], args: [MatDrawerContent, { static: false },] }],
                _userContent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewChild"], args: [MatDrawerContent, { static: false },] }],
                autosize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                hasBackdrop: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                backdropClick: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Output"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSidenavContent = /** @class */ (function (_super) {
                __extends(MatSidenavContent, _super);
                /**
                 * @param {?} changeDetectorRef
                 * @param {?} container
                 * @param {?} elementRef
                 * @param {?} scrollDispatcher
                 * @param {?} ngZone
                 */
                function MatSidenavContent(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {
                    return _super.call(this, changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) || this;
                }
                return MatSidenavContent;
            }(MatDrawerContent));
            MatSidenavContent.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"], args: [{ selector: 'mat-sidenav-content',
                            template: '<ng-content></ng-content>',
                            host: {
                                'class': 'mat-drawer-content mat-sidenav-content',
                                '[style.margin-left.px]': '_container._contentMargins.left',
                                '[style.margin-right.px]': '_container._contentMargins.right',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatSidenavContent.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectorRef"] },
                { type: MatSidenavContainer, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_8__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatSidenavContainer; })),] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ElementRef"] },
                { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__["ScrollDispatcher"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgZone"] }
            ]; };
            var MatSidenav = /** @class */ (function (_super) {
                __extends(MatSidenav, _super);
                function MatSidenav() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    _this._fixedInViewport = false;
                    _this._fixedTopGap = 0;
                    _this._fixedBottomGap = 0;
                    return _this;
                }
                Object.defineProperty(MatSidenav.prototype, "fixedInViewport", {
                    /**
                     * Whether the sidenav is fixed in the viewport.
                     * @return {?}
                     */
                    get: function () { return this._fixedInViewport; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._fixedInViewport = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSidenav.prototype, "fixedTopGap", {
                    /**
                     * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed
                     * mode.
                     * @return {?}
                     */
                    get: function () { return this._fixedTopGap; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._fixedTopGap = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceNumberProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSidenav.prototype, "fixedBottomGap", {
                    /**
                     * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in
                     * fixed mode.
                     * @return {?}
                     */
                    get: function () { return this._fixedBottomGap; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._fixedBottomGap = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceNumberProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                return MatSidenav;
            }(MatDrawer));
            MatSidenav.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"], args: [{ selector: 'mat-sidenav',
                            exportAs: 'matSidenav',
                            template: "<div class=\"mat-drawer-inner-container\"><ng-content></ng-content></div>",
                            animations: [matDrawerAnimations.transformDrawer],
                            host: {
                                'class': 'mat-drawer mat-sidenav',
                                'tabIndex': '-1',
                                // must prevent the browser from aligning text based on value
                                '[attr.align]': 'null',
                                '[class.mat-drawer-end]': 'position === "end"',
                                '[class.mat-drawer-over]': 'mode === "over"',
                                '[class.mat-drawer-push]': 'mode === "push"',
                                '[class.mat-drawer-side]': 'mode === "side"',
                                '[class.mat-drawer-opened]': 'opened',
                                '[class.mat-sidenav-fixed]': 'fixedInViewport',
                                '[style.top.px]': 'fixedInViewport ? fixedTopGap : null',
                                '[style.bottom.px]': 'fixedInViewport ? fixedBottomGap : null',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewEncapsulation"].None,
                        },] },
            ];
            MatSidenav.propDecorators = {
                fixedInViewport: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                fixedTopGap: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }],
                fixedBottomGap: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Input"] }]
            };
            var MatSidenavContainer = /** @class */ (function (_super) {
                __extends(MatSidenavContainer, _super);
                function MatSidenavContainer() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatSidenavContainer;
            }(MatDrawerContainer));
            MatSidenavContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["Component"], args: [{ selector: 'mat-sidenav-container',
                            exportAs: 'matSidenavContainer',
                            template: "<div class=\"mat-drawer-backdrop\" (click)=\"_onBackdropClicked()\" *ngIf=\"hasBackdrop\" [class.mat-drawer-shown]=\"_isShowingBackdrop()\"></div><ng-content select=\"mat-sidenav\"></ng-content><ng-content select=\"mat-sidenav-content\"></ng-content><mat-sidenav-content *ngIf=\"!_content\" cdkScrollable><ng-content></ng-content></mat-sidenav-content>",
                            styles: [".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:background-color,visibility}@media (-ms-high-contrast:active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:.4s;transition-timing-function:cubic-bezier(.25,.8,.25,1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%,0,0)}@media (-ms-high-contrast:active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media (-ms-high-contrast:active){.mat-drawer.mat-drawer-end,[dir=rtl] .mat-drawer{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer{transform:translate3d(100%,0,0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%,0,0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}"],
                            host: {
                                'class': 'mat-drawer-container mat-sidenav-container',
                                '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ViewEncapsulation"].None,
                        },] },
            ];
            MatSidenavContainer.propDecorators = {
                _drawers: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChildren"], args: [MatSidenav,] }],
                _content: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["ContentChild"], args: [MatSidenavContent, { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSidenavModule = /** @class */ (function () {
                function MatSidenavModule() {
                }
                return MatSidenavModule;
            }());
            MatSidenavModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_8__["NgModule"], args: [{
                            imports: [
                                _angular_common__WEBPACK_IMPORTED_MODULE_7__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_12__["MatCommonModule"],
                                _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_6__["ScrollingModule"],
                                _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__["PlatformModule"],
                            ],
                            exports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_12__["MatCommonModule"],
                                MatDrawer,
                                MatDrawerContainer,
                                MatDrawerContent,
                                MatSidenav,
                                MatSidenavContainer,
                                MatSidenavContent,
                            ],
                            declarations: [
                                MatDrawer,
                                MatDrawerContainer,
                                MatDrawerContent,
                                MatSidenav,
                                MatSidenavContainer,
                                MatSidenavContent,
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=sidenav.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/slide-toggle.js": 
        /*!****************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/slide-toggle.js ***!
          \****************************************************************/
        /*! exports provided: _MatSlideToggleRequiredValidatorModule, MatSlideToggleModule, MAT_SLIDE_TOGGLE_VALUE_ACCESSOR, MatSlideToggleChange, MatSlideToggle, MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS, MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR, MatSlideToggleRequiredValidator */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_MatSlideToggleRequiredValidatorModule", function () { return _MatSlideToggleRequiredValidatorModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleModule", function () { return MatSlideToggleModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_VALUE_ACCESSOR", function () { return MAT_SLIDE_TOGGLE_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleChange", function () { return MatSlideToggleChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggle", function () { return MatSlideToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS", function () { return MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR", function () { return MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlideToggleRequiredValidator", function () { return MatSlideToggleRequiredValidator; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/observers */ "./node_modules/@angular/cdk/esm2015/observers.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token to be used to override the default options for `mat-slide-toggle`.
             * @type {?}
             */
            var MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["InjectionToken"]('mat-slide-toggle-default-options', {
                providedIn: 'root',
                factory: ( /**
                 * @return {?}
                 */function () { return ({ disableToggleValue: false, disableDragValue: false }); })
            });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Increasing integer for generating unique ids for slide-toggle components.
            /** @type {?} */
            var nextUniqueId = 0;
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlideToggle; })),
                multi: true
            };
            /**
             * Change event object emitted by a MatSlideToggle.
             */
            var MatSlideToggleChange = /** @class */ (function () {
                /**
                 * @param {?} source
                 * @param {?} checked
                 */
                function MatSlideToggleChange(source, checked) {
                    this.source = source;
                    this.checked = checked;
                }
                return MatSlideToggleChange;
            }());
            // Boilerplate for applying mixins to MatSlideToggle.
            /**
             * \@docs-private
             */
            var MatSlideToggleBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatSlideToggleBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatSlideToggleBase;
            }());
            /** @type {?} */
            var _MatSlideToggleMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisableRipple"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__["mixinDisabled"])(MatSlideToggleBase)), 'accent'));
            /**
             * Represents a slidable "switch" toggle that can be moved between on and off.
             */
            var MatSlideToggle = /** @class */ (function (_super) {
                __extends(MatSlideToggle, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?} tabIndex
                 * @param {?} _ngZone
                 * @param {?} defaults
                 * @param {?=} _animationMode
                 * @param {?=} _dir
                 */
                function MatSlideToggle(elementRef, _focusMonitor, _changeDetectorRef, tabIndex, _ngZone, defaults, _animationMode, _dir) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._focusMonitor = _focusMonitor;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._ngZone = _ngZone;
                    _this.defaults = defaults;
                    _this._animationMode = _animationMode;
                    _this._dir = _dir;
                    _this._onChange = ( /**
                     * @param {?} _
                     * @return {?}
                     */function (_) { });
                    _this._onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this._uniqueId = "mat-slide-toggle-" + ++nextUniqueId;
                    _this._required = false;
                    _this._checked = false;
                    /**
                     * Whether the thumb is currently being dragged.
                     */
                    _this._dragging = false;
                    /**
                     * Name value will be applied to the input element if present.
                     */
                    _this.name = null;
                    /**
                     * A unique id for the slide-toggle input. If none is supplied, it will be auto-generated.
                     */
                    _this.id = _this._uniqueId;
                    /**
                     * Whether the label should appear after or before the slide-toggle. Defaults to 'after'.
                     */
                    _this.labelPosition = 'after';
                    /**
                     * Used to set the aria-label attribute on the underlying input element.
                     */
                    _this.ariaLabel = null;
                    /**
                     * Used to set the aria-labelledby attribute on the underlying input element.
                     */
                    _this.ariaLabelledby = null;
                    /**
                     * An event will be dispatched each time the slide-toggle changes its value.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event will be dispatched each time the slide-toggle input is toggled.
                     * This event is always emitted when the user toggles the slide toggle, but this does not mean
                     * the slide toggle's value has changed. The event does not fire when the user drags to change
                     * the slide toggle value.
                     */
                    _this.toggleChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * An event will be dispatched each time the slide-toggle is dragged.
                     * This event is always emitted when the user drags the slide toggle to make a change greater
                     * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when
                     * the user toggles the slide toggle to change its value.
                     */
                    _this.dragChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    return _this;
                }
                Object.defineProperty(MatSlideToggle.prototype, "required", {
                    /**
                     * Whether the slide-toggle is required.
                     * @return {?}
                     */
                    get: function () { return this._required; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlideToggle.prototype, "checked", {
                    /**
                     * Whether the slide-toggle element is checked or not.
                     * @return {?}
                     */
                    get: function () { return this._checked; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._checked = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value);
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlideToggle.prototype, "inputId", {
                    /**
                     * Returns the unique id for the visual hidden input.
                     * @return {?}
                     */
                    get: function () { return (this.id || this._uniqueId) + "-input"; },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} focusOrigin
                 * @return {?}
                 */function (/**
                 * @param {?} focusOrigin
                 * @return {?}
                 */ focusOrigin) {
                        if (!focusOrigin) {
                            // When a focused element becomes disabled, the browser *immediately* fires a blur event.
                            // Angular does not expect events to be raised during change detection, so any state
                            // change (such as a form control's 'ng-touched') will cause a changed-after-checked
                            // error. See https://github.com/angular/angular/issues/17793. To work around this,
                            // we defer telling the form control it has been touched until the next tick.
                            Promise.resolve().then(( /**
                             * @return {?}
                             */function () { return _this._onTouched(); }));
                        }
                    }));
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Method being called whenever the underlying input emits a change event.
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onChangeEvent = function (event) {
                    // We always have to stop propagation on the change event.
                    // Otherwise the change event, from the input element, will bubble up and
                    // emit its event object to the component's `change` output.
                    event.stopPropagation();
                    if (!this._dragging) {
                        this.toggleChange.emit();
                    }
                    // Releasing the pointer over the `<label>` element while dragging triggers another
                    // click event on the `<label>` element. This means that the checked state of the underlying
                    // input changed unintentionally and needs to be changed back. Or when the slide toggle's config
                    // disabled toggle change event by setting `disableToggleValue: true`, the slide toggle's value
                    // does not change, and the checked state of the underlying input needs to be changed back.
                    if (this._dragging || this.defaults.disableToggleValue) {
                        this._inputElement.nativeElement.checked = this.checked;
                        return;
                    }
                    // Sync the value from the underlying input element with the component instance.
                    this.checked = this._inputElement.nativeElement.checked;
                    // Emit our custom change event only if the underlying input emitted one. This ensures that
                    // there is no change event, when the checked state changes programmatically.
                    this._emitChangeEvent();
                };
                /**
                 * Method being called whenever the slide-toggle has been clicked.
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onInputClick = function (event) {
                    // We have to stop propagation for click events on the visual hidden input element.
                    // By default, when a user clicks on a label element, a generated click event will be
                    // dispatched on the associated input element. Since we are using a label element as our
                    // root container, the click event on the `slide-toggle` will be executed twice.
                    // The real click event will bubble up, and the generated click event also tries to bubble up.
                    // This will lead to multiple click events.
                    // Preventing bubbling for the second event will solve that issue.
                    event.stopPropagation();
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatSlideToggle.prototype.writeValue = function (value) {
                    this.checked = !!value;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSlideToggle.prototype.registerOnChange = function (fn) {
                    this._onChange = fn;
                };
                /**
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn
                 * @return {?}
                 */
                MatSlideToggle.prototype.registerOnTouched = function (fn) {
                    this._onTouched = fn;
                };
                /**
                 * Implemented as a part of ControlValueAccessor.
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatSlideToggle.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                    this._changeDetectorRef.markForCheck();
                };
                /**
                 * Focuses the slide-toggle.
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlideToggle.prototype.focus = function (options) {
                    this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);
                };
                /**
                 * Toggles the checked state of the slide-toggle.
                 * @return {?}
                 */
                MatSlideToggle.prototype.toggle = function () {
                    this.checked = !this.checked;
                    this._onChange(this.checked);
                };
                /**
                 * Emits a change event on the `change` output. Also notifies the FormControl about the change.
                 * @private
                 * @return {?}
                 */
                MatSlideToggle.prototype._emitChangeEvent = function () {
                    this._onChange(this.checked);
                    this.change.emit(new MatSlideToggleChange(this, this.checked));
                };
                /**
                 * Retrieves the percentage of thumb from the moved distance. Percentage as fraction of 100.
                 * @private
                 * @param {?} distance
                 * @return {?}
                 */
                MatSlideToggle.prototype._getDragPercentage = function (distance) {
                    /** @type {?} */
                    var percentage = (distance / this._thumbBarWidth) * 100;
                    // When the toggle was initially checked, then we have to start the drag at the end.
                    if (this._previousChecked) {
                        percentage += 100;
                    }
                    return Math.max(0, Math.min(percentage, 100));
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDragStart = function () {
                    if (!this.disabled && !this._dragging) {
                        /** @type {?} */
                        var thumbEl = this._thumbEl.nativeElement;
                        this._thumbBarWidth = this._thumbBarEl.nativeElement.clientWidth - thumbEl.clientWidth;
                        thumbEl.classList.add('mat-dragging');
                        this._previousChecked = this.checked;
                        this._dragging = true;
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDrag = function (event) {
                    if (this._dragging) {
                        /** @type {?} */
                        var direction = this._dir && this._dir.value === 'rtl' ? -1 : 1;
                        this._dragPercentage = this._getDragPercentage(event.deltaX * direction);
                        // Calculate the moved distance based on the thumb bar width.
                        /** @type {?} */
                        var dragX = (this._dragPercentage / 100) * this._thumbBarWidth * direction;
                        this._thumbEl.nativeElement.style.transform = "translate3d(" + dragX + "px, 0, 0)";
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlideToggle.prototype._onDragEnd = function () {
                    var _this = this;
                    if (this._dragging) {
                        /** @type {?} */
                        var newCheckedValue = this._dragPercentage > 50;
                        if (newCheckedValue !== this.checked) {
                            this.dragChange.emit();
                            if (!this.defaults.disableDragValue) {
                                this.checked = newCheckedValue;
                                this._emitChangeEvent();
                            }
                        }
                        // The drag should be stopped outside of the current event handler, otherwise the
                        // click event will be fired before it and will revert the drag change.
                        this._ngZone.runOutsideAngular(( /**
                         * @return {?}
                         */function () { return setTimeout(( /**
                         * @return {?}
                         */function () {
                            if (_this._dragging) {
                                _this._dragging = false;
                                _this._thumbEl.nativeElement.classList.remove('mat-dragging');
                                // Reset the transform because the component will take care
                                // of the thumb position after drag.
                                _this._thumbEl.nativeElement.style.transform = '';
                            }
                        })); }));
                    }
                };
                /**
                 * Method being called whenever the label text changes.
                 * @return {?}
                 */
                MatSlideToggle.prototype._onLabelTextChange = function () {
                    // Since the event of the `cdkObserveContent` directive runs outside of the zone, the
                    // slide-toggle component will be only marked for check, but no actual change detection runs
                    // automatically. Instead of going back into the zone in order to trigger a change detection
                    // which causes *all* components to be checked (if explicitly marked or not using OnPush),
                    // we only trigger an explicit change detection for the slide-toggle view and its children.
                    this._changeDetectorRef.detectChanges();
                };
                return MatSlideToggle;
            }(_MatSlideToggleMixinBase));
            MatSlideToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-slide-toggle',
                            exportAs: 'matSlideToggle',
                            host: {
                                'class': 'mat-slide-toggle',
                                '[id]': 'id',
                                // Needs to be `-1` so it can still receive programmatic focus.
                                '[attr.tabindex]': 'disabled ? null : -1',
                                '[attr.aria-label]': 'null',
                                '[attr.aria-labelledby]': 'null',
                                '[class.mat-checked]': 'checked',
                                '[class.mat-disabled]': 'disabled',
                                '[class.mat-slide-toggle-label-before]': 'labelPosition == "before"',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                                '(focus)': '_inputElement.nativeElement.focus()',
                            },
                            template: "<label [attr.for]=\"inputId\" class=\"mat-slide-toggle-label\" #label><div #toggleBar class=\"mat-slide-toggle-bar\" [class.mat-slide-toggle-bar-no-side-margin]=\"!labelContent.textContent || !labelContent.textContent.trim()\"><input #input class=\"mat-slide-toggle-input cdk-visually-hidden\" type=\"checkbox\" role=\"switch\" [id]=\"inputId\" [required]=\"required\" [tabIndex]=\"tabIndex\" [checked]=\"checked\" [disabled]=\"disabled\" [attr.name]=\"name\" [attr.aria-checked]=\"checked.toString()\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledby\" (change)=\"_onChangeEvent($event)\" (click)=\"_onInputClick($event)\"><div class=\"mat-slide-toggle-thumb-container\" #thumbContainer (slidestart)=\"_onDragStart()\" (slide)=\"_onDrag($event)\" (slideend)=\"_onDragEnd()\"><div class=\"mat-slide-toggle-thumb\"></div><div class=\"mat-slide-toggle-ripple\" mat-ripple [matRippleTrigger]=\"label\" [matRippleDisabled]=\"disableRipple || disabled\" [matRippleCentered]=\"true\" [matRippleRadius]=\"20\" [matRippleAnimation]=\"{enterDuration: 150}\"><div class=\"mat-ripple-element mat-slide-toggle-persistent-ripple\"></div></div></div></div><span class=\"mat-slide-toggle-content\" #labelContent (cdkObserveContent)=\"_onLabelTextChange()\"><span style=\"display:none\">&nbsp;</span><ng-content></ng-content></span></label>",
                            styles: [".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px,0,0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px,0,0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}.mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-right:8px;margin-left:0}.mat-slide-toggle-label-before .mat-slide-toggle-bar,[dir=rtl] .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0,0,0);transition:all 80ms linear;transition-property:transform;cursor:-webkit-grab;cursor:grab}.mat-slide-toggle-thumb-container.mat-dragging{transition-duration:0s}.mat-slide-toggle-thumb-container:active{cursor:-webkit-grabbing;cursor:grabbing}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media (hover:none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}@media (-ms-high-contrast:active){.mat-slide-toggle-thumb{background:#fff;border:1px solid #000}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background:#000;border:1px solid #fff}.mat-slide-toggle-bar{background:#fff}.mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:1px dotted;outline-offset:5px}}@media (-ms-high-contrast:black-on-white){.mat-slide-toggle-bar{border:1px solid #000}}"],
                            providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],
                            inputs: ['disabled', 'disableRipple', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatSlideToggle.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Attribute"], args: ['tabindex',] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgZone"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS,] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_6__["ANIMATION_MODULE_TYPE"],] }] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_2__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] }
            ]; };
            MatSlideToggle.propDecorators = {
                _thumbEl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['thumbContainer', { static: false },] }],
                _thumbBarEl: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['toggleBar', { static: false },] }],
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                ariaLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-label',] }],
                ariaLabelledby: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['aria-labelledby',] }],
                required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                checked: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                toggleChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                dragChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                _inputElement: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"], args: ['input', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_4__["NG_VALIDATORS"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlideToggleRequiredValidator; })),
                multi: true
            };
            /**
             * Validator for Material slide-toggle components with the required attribute in a
             * template-driven form. The default validator for required form controls asserts
             * that the control value is not undefined but that is not appropriate for a slide-toggle
             * where the value is always defined.
             *
             * Required slide-toggle form controls are valid when checked.
             */
            var MatSlideToggleRequiredValidator = /** @class */ (function (_super) {
                __extends(MatSlideToggleRequiredValidator, _super);
                function MatSlideToggleRequiredValidator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatSlideToggleRequiredValidator;
            }(_angular_forms__WEBPACK_IMPORTED_MODULE_4__["CheckboxRequiredValidator"]));
            MatSlideToggleRequiredValidator.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: "mat-slide-toggle[required][formControlName],\n             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]",
                            providers: [MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * This module is used by both original and MDC-based slide-toggle implementations.
             */
            // tslint:disable-next-line:class-name
            var _MatSlideToggleRequiredValidatorModule = /** @class */ (function () {
                function _MatSlideToggleRequiredValidatorModule() {
                }
                return _MatSlideToggleRequiredValidatorModule;
            }());
            _MatSlideToggleRequiredValidatorModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            exports: [MatSlideToggleRequiredValidator],
                            declarations: [MatSlideToggleRequiredValidator],
                        },] },
            ];
            var MatSlideToggleModule = /** @class */ (function () {
                function MatSlideToggleModule() {
                }
                return MatSlideToggleModule;
            }());
            MatSlideToggleModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _MatSlideToggleRequiredValidatorModule,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatRippleModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"],
                                _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__["ObserversModule"],
                            ],
                            exports: [
                                _MatSlideToggleRequiredValidatorModule,
                                MatSlideToggle,
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["MatCommonModule"]
                            ],
                            declarations: [MatSlideToggle],
                            providers: [
                                { provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_5__["GestureConfig"] }
                            ],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=slide-toggle.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/slider.js": 
        /*!**********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/slider.js ***!
          \**********************************************************/
        /*! exports provided: MatSliderModule, MAT_SLIDER_VALUE_ACCESSOR, MatSliderChange, MatSlider */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSliderModule", function () { return MatSliderModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SLIDER_VALUE_ACCESSOR", function () { return MAT_SLIDER_VALUE_ACCESSOR; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSliderChange", function () { return MatSliderChange; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSlider", function () { return MatSlider; });
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/keycodes */ "./node_modules/@angular/cdk/esm2015/keycodes.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm2015/forms.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm2015/animations.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm2015/platform-browser.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Visually, a 30px separation between tick marks looks best. This is very subjective but it is
             * the default separation we chose.
             * @type {?}
             */
            var MIN_AUTO_TICK_SEPARATION = 30;
            /**
             * The thumb gap size for a disabled slider.
             * @type {?}
             */
            var DISABLED_THUMB_GAP = 7;
            /**
             * The thumb gap size for a non-active slider at its minimum value.
             * @type {?}
             */
            var MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
            /**
             * The thumb gap size for an active slider at its minimum value.
             * @type {?}
             */
            var MIN_VALUE_ACTIVE_THUMB_GAP = 10;
            /**
             * Provider Expression that allows mat-slider to register as a ControlValueAccessor.
             * This allows it to support [(ngModel)] and [formControl].
             * \@docs-private
             * @type {?}
             */
            var MAT_SLIDER_VALUE_ACCESSOR = {
                provide: _angular_forms__WEBPACK_IMPORTED_MODULE_5__["NG_VALUE_ACCESSOR"],
                useExisting: Object(_angular_core__WEBPACK_IMPORTED_MODULE_4__["forwardRef"])(( /**
                 * @return {?}
                 */function () { return MatSlider; })),
                multi: true
            };
            /**
             * A simple change event emitted by the MatSlider component.
             */
            var MatSliderChange = /** @class */ (function () {
                function MatSliderChange() {
                }
                return MatSliderChange;
            }());
            // Boilerplate for applying mixins to MatSlider.
            /**
             * \@docs-private
             */
            var MatSliderBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatSliderBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatSliderBase;
            }());
            /** @type {?} */
            var _MatSliderMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinColor"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_6__["mixinDisabled"])(MatSliderBase), 'accent'));
            /**
             * Allows users to select from a range of values by moving the slider thumb. It is similar in
             * behavior to the native `<input type="range">` element.
             */
            var MatSlider = /** @class */ (function (_super) {
                __extends(MatSlider, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _focusMonitor
                 * @param {?} _changeDetectorRef
                 * @param {?} _dir
                 * @param {?} tabIndex
                 * @param {?=} _animationMode
                 */
                function MatSlider(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex, _animationMode) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._focusMonitor = _focusMonitor;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this._dir = _dir;
                    _this._animationMode = _animationMode;
                    _this._invert = false;
                    _this._max = 100;
                    _this._min = 0;
                    _this._step = 1;
                    _this._thumbLabel = false;
                    _this._tickInterval = 0;
                    _this._value = null;
                    _this._vertical = false;
                    /**
                     * Event emitted when the slider value has changed.
                     */
                    _this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * Event emitted when the slider thumb moves.
                     */
                    _this.input = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * Emits when the raw value of the slider changes. This is here primarily
                     * to facilitate the two-way binding for the `value` input.
                     * \@docs-private
                     */
                    _this.valueChange = new _angular_core__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
                    /**
                     * onTouch function registered via registerOnTouch (ControlValueAccessor).
                     */
                    _this.onTouched = ( /**
                     * @return {?}
                     */function () { });
                    _this._percent = 0;
                    /**
                     * Whether or not the thumb is sliding.
                     * Used to determine if there should be a transition for the thumb and fill track.
                     */
                    _this._isSliding = false;
                    /**
                     * Whether or not the slider is active (clicked or sliding).
                     * Used to shrink and grow the thumb as according to the Material Design spec.
                     */
                    _this._isActive = false;
                    /**
                     * The size of a tick interval as a percentage of the size of the track.
                     */
                    _this._tickIntervalPercent = 0;
                    /**
                     * The dimensions of the slider.
                     */
                    _this._sliderDimensions = null;
                    _this._controlValueAccessorChangeFn = ( /**
                     * @return {?}
                     */function () { });
                    /**
                     * Subscription to the Directionality change EventEmitter.
                     */
                    _this._dirChangeSubscription = rxjs__WEBPACK_IMPORTED_MODULE_8__["Subscription"].EMPTY;
                    _this.tabIndex = parseInt(tabIndex) || 0;
                    return _this;
                }
                Object.defineProperty(MatSlider.prototype, "invert", {
                    /**
                     * Whether the slider is inverted.
                     * @return {?}
                     */
                    get: function () { return this._invert; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._invert = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "max", {
                    /**
                     * The maximum value that the slider can have.
                     * @return {?}
                     */
                    get: function () { return this._max; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._max = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._max);
                        this._percent = this._calculatePercentage(this._value);
                        // Since this also modifies the percentage, we need to let the change detection know.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "min", {
                    /**
                     * The minimum value that the slider can have.
                     * @return {?}
                     */
                    get: function () { return this._min; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._min = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._min);
                        // If the value wasn't explicitly set by the user, set it to the min.
                        if (this._value === null) {
                            this.value = this._min;
                        }
                        this._percent = this._calculatePercentage(this._value);
                        // Since this also modifies the percentage, we need to let the change detection know.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "step", {
                    /**
                     * The values at which the thumb will snap.
                     * @return {?}
                     */
                    get: function () { return this._step; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        this._step = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v, this._step);
                        if (this._step % 1 !== 0) {
                            this._roundToDecimal = ( /** @type {?} */(this._step.toString().split('.').pop())).length;
                        }
                        // Since this could modify the label, we need to notify the change detection.
                        this._changeDetectorRef.markForCheck();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "thumbLabel", {
                    /**
                     * Whether or not to show the thumb label.
                     * @return {?}
                     */
                    get: function () { return this._thumbLabel; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._thumbLabel = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "tickInterval", {
                    /**
                     * How often to show ticks. Relative to the step so that a tick always appears on a step.
                     * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
                     * @return {?}
                     */
                    get: function () { return this._tickInterval; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (value === 'auto') {
                            this._tickInterval = 'auto';
                        }
                        else if (typeof value === 'number' || typeof value === 'string') {
                            this._tickInterval = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(value, ( /** @type {?} */(this._tickInterval)));
                        }
                        else {
                            this._tickInterval = 0;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "value", {
                    /**
                     * Value of the slider.
                     * @return {?}
                     */
                    get: function () {
                        // If the value needs to be read and it is still uninitialized, initialize it to the min.
                        if (this._value === null) {
                            this.value = this._min;
                        }
                        return this._value;
                    },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) {
                        if (v !== this._value) {
                            /** @type {?} */
                            var value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceNumberProperty"])(v);
                            // While incrementing by a decimal we can end up with values like 33.300000000000004.
                            // Truncate it to ensure that it matches the label and to make it easier to work with.
                            if (this._roundToDecimal) {
                                value = parseFloat(value.toFixed(this._roundToDecimal));
                            }
                            this._value = value;
                            this._percent = this._calculatePercentage(this._value);
                            // Since this also modifies the percentage, we need to let the change detection know.
                            this._changeDetectorRef.markForCheck();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "vertical", {
                    /**
                     * Whether the slider is vertical.
                     * @return {?}
                     */
                    get: function () { return this._vertical; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._vertical = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__["coerceBooleanProperty"])(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "displayValue", {
                    /**
                     * The value to be used for display purposes.
                     * @return {?}
                     */
                    get: function () {
                        if (this.displayWith) {
                            // Value is never null but since setters and getters cannot have
                            // different types, the value getter is also typed to return null.
                            return this.displayWith(( /** @type {?} */(this.value)));
                        }
                        // Note that this could be improved further by rounding something like 0.999 to 1 or
                        // 0.899 to 0.9, however it is very performance sensitive, because it gets called on
                        // every change detection cycle.
                        if (this._roundToDecimal && this.value && this.value % 1 !== 0) {
                            return this.value.toFixed(this._roundToDecimal);
                        }
                        return this.value || 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * set focus to the host element
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlider.prototype.focus = function (options) {
                    this._focusHostElement(options);
                };
                /**
                 * blur the host element
                 * @return {?}
                 */
                MatSlider.prototype.blur = function () {
                    this._blurHostElement();
                };
                Object.defineProperty(MatSlider.prototype, "percent", {
                    /**
                     * The percentage of the slider that coincides with the value.
                     * @return {?}
                     */
                    get: function () { return this._clamp(this._percent); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_invertAxis", {
                    /**
                     * Whether the axis of the slider is inverted.
                     * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
                     * @return {?}
                     */
                    get: function () {
                        // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to
                        // top. However from a y-axis standpoint this is inverted.
                        return this.vertical ? !this.invert : this.invert;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_isMinValue", {
                    /**
                     * Whether the slider is at its minimum value.
                     * @return {?}
                     */
                    get: function () {
                        return this.percent === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_thumbGap", {
                    /**
                     * The amount of space to leave between the slider thumb and the track fill & track background
                     * elements.
                     * @return {?}
                     */
                    get: function () {
                        if (this.disabled) {
                            return DISABLED_THUMB_GAP;
                        }
                        if (this._isMinValue && !this.thumbLabel) {
                            return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
                        }
                        return 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_trackBackgroundStyles", {
                    /**
                     * CSS styles for the track background element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        /** @type {?} */
                        var scale = this.vertical ? "1, " + (1 - this.percent) + ", 1" : 1 - this.percent + ", 1, 1";
                        /** @type {?} */
                        var sign = this._shouldInvertMouseCoords() ? '-' : '';
                        return {
                            // scale3d avoids some rendering issues in Chrome. See #12071.
                            transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_trackFillStyles", {
                    /**
                     * CSS styles for the track fill element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        /** @type {?} */
                        var scale = this.vertical ? "1, " + this.percent + ", 1" : this.percent + ", 1, 1";
                        /** @type {?} */
                        var sign = this._shouldInvertMouseCoords() ? '' : '-';
                        return {
                            // scale3d avoids some rendering issues in Chrome. See #12071.
                            transform: "translate" + axis + "(" + sign + this._thumbGap + "px) scale3d(" + scale + ")"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_ticksContainerStyles", {
                    /**
                     * CSS styles for the ticks container element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // For a horizontal slider in RTL languages we push the ticks container off the left edge
                        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
                        /** @type {?} */
                        var sign = !this.vertical && this._getDirection() == 'rtl' ? '' : '-';
                        /** @type {?} */
                        var offset = this._tickIntervalPercent / 2 * 100;
                        return {
                            'transform': "translate" + axis + "(" + sign + offset + "%)"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_ticksStyles", {
                    /**
                     * CSS styles for the ticks element.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var tickSize = this._tickIntervalPercent * 100;
                        /** @type {?} */
                        var backgroundSize = this.vertical ? "2px " + tickSize + "%" : tickSize + "% 2px";
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // Depending on the direction we pushed the ticks container, push the ticks the opposite
                        // direction to re-center them but clip off the end edge. In RTL languages we need to flip the
                        // ticks 180 degrees so we're really cutting off the end edge abd not the start.
                        /** @type {?} */
                        var sign = !this.vertical && this._getDirection() == 'rtl' ? '-' : '';
                        /** @type {?} */
                        var rotate = !this.vertical && this._getDirection() == 'rtl' ? ' rotate(180deg)' : '';
                        /** @type {?} */
                        var styles = {
                            'backgroundSize': backgroundSize,
                            // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
                            'transform': "translateZ(0) translate" + axis + "(" + sign + tickSize / 2 + "%)" + rotate
                        };
                        if (this._isMinValue && this._thumbGap) {
                            /** @type {?} */
                            var side = this.vertical ?
                                (this._invertAxis ? 'Bottom' : 'Top') :
                                (this._invertAxis ? 'Right' : 'Left');
                            styles["padding" + side] = this._thumbGap + "px";
                        }
                        return styles;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSlider.prototype, "_thumbContainerStyles", {
                    /**
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var axis = this.vertical ? 'Y' : 'X';
                        // For a horizontal slider in RTL languages we push the thumb container off the left edge
                        // instead of the right edge to avoid causing a horizontal scrollbar to appear.
                        /** @type {?} */
                        var invertOffset = (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
                        /** @type {?} */
                        var offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
                        return {
                            'transform': "translate" + axis + "(-" + offset + "%)"
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Whether mouse events should be converted to a slider position by calculating their distance
                 * from the right or bottom edge of the slider as opposed to the top or left.
                 * @return {?}
                 */
                MatSlider.prototype._shouldInvertMouseCoords = function () {
                    return (this._getDirection() == 'rtl' && !this.vertical) ? !this._invertAxis : this._invertAxis;
                };
                /**
                 * The language direction for this slider element.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._getDirection = function () {
                    return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype.ngOnInit = function () {
                    var _this = this;
                    this._focusMonitor
                        .monitor(this._elementRef, true)
                        .subscribe(( /**
                 * @param {?} origin
                 * @return {?}
                 */function (origin) {
                        _this._isActive = !!origin && origin !== 'keyboard';
                        _this._changeDetectorRef.detectChanges();
                    }));
                    if (this._dir) {
                        this._dirChangeSubscription = this._dir.change.subscribe(( /**
                         * @return {?}
                         */function () {
                            _this._changeDetectorRef.markForCheck();
                        }));
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype.ngOnDestroy = function () {
                    this._focusMonitor.stopMonitoring(this._elementRef);
                    this._dirChangeSubscription.unsubscribe();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onMouseenter = function () {
                    if (this.disabled) {
                        return;
                    }
                    // We save the dimensions of the slider here so we can use them to update the spacing of the
                    // ticks and determine where on the slider click and slide events happen.
                    this._sliderDimensions = this._getSliderDimensions();
                    this._updateTickIntervalPercent();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onMousedown = function (event) {
                    // Don't do anything if the slider is disabled or the
                    // user is using anything other than the main mouse button.
                    if (this.disabled || event.button !== 0) {
                        return;
                    }
                    /** @type {?} */
                    var oldValue = this.value;
                    this._isSliding = false;
                    this._focusHostElement();
                    this._updateValueFromPosition({ x: event.clientX, y: event.clientY });
                    // Emit a change and input event if the value changed.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                        this._emitChangeEvent();
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onSlide = function (event) {
                    if (this.disabled) {
                        return;
                    }
                    // The slide start event sometimes fails to fire on iOS, so if we're not already in the sliding
                    // state, call the slide start handler manually.
                    if (!this._isSliding) {
                        this._onSlideStart(null);
                    }
                    // Prevent the slide from selecting anything else.
                    event.preventDefault();
                    /** @type {?} */
                    var oldValue = this.value;
                    this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
                    // Native range elements always emit `input` events when the value changed while sliding.
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                    }
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onSlideStart = function (event) {
                    if (this.disabled || this._isSliding) {
                        return;
                    }
                    // Simulate mouseenter in case this is a mobile device.
                    this._onMouseenter();
                    this._isSliding = true;
                    this._focusHostElement();
                    this._valueOnSlideStart = this.value;
                    if (event) {
                        this._updateValueFromPosition({ x: event.center.x, y: event.center.y });
                        event.preventDefault();
                    }
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onSlideEnd = function () {
                    this._isSliding = false;
                    if (this._valueOnSlideStart != this.value && !this.disabled) {
                        this._emitChangeEvent();
                    }
                    this._valueOnSlideStart = null;
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onFocus = function () {
                    // We save the dimensions of the slider here so we can use them to update the spacing of the
                    // ticks and determine where on the slider click and slide events happen.
                    this._sliderDimensions = this._getSliderDimensions();
                    this._updateTickIntervalPercent();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onBlur = function () {
                    this.onTouched();
                };
                /**
                 * @param {?} event
                 * @return {?}
                 */
                MatSlider.prototype._onKeydown = function (event) {
                    if (this.disabled || Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["hasModifierKey"])(event)) {
                        return;
                    }
                    /** @type {?} */
                    var oldValue = this.value;
                    switch (event.keyCode) {
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_UP"]:
                            this._increment(10);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["PAGE_DOWN"]:
                            this._increment(-10);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["END"]:
                            this.value = this.max;
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["HOME"]:
                            this.value = this.min;
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["LEFT_ARROW"]:
                            // NOTE: For a sighted user it would make more sense that when they press an arrow key on an
                            // inverted slider the thumb moves in that direction. However for a blind user, nothing
                            // about the slider indicates that it is inverted. They will expect left to be decrement,
                            // regardless of how it appears on the screen. For speakers ofRTL languages, they probably
                            // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for
                            // RTL. For inverted sliders we prefer a good a11y experience to having it "look right" for
                            // sighted users, therefore we do not swap the meaning.
                            this._increment(this._getDirection() == 'rtl' ? 1 : -1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["UP_ARROW"]:
                            this._increment(1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["RIGHT_ARROW"]:
                            // See comment on LEFT_ARROW about the conditions under which we flip the meaning.
                            this._increment(this._getDirection() == 'rtl' ? -1 : 1);
                            break;
                        case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_3__["DOWN_ARROW"]:
                            this._increment(-1);
                            break;
                        default:
                            // Return if the key is not one that we explicitly handle to avoid calling preventDefault on
                            // it.
                            return;
                    }
                    if (oldValue != this.value) {
                        this._emitInputEvent();
                        this._emitChangeEvent();
                    }
                    this._isSliding = true;
                    event.preventDefault();
                };
                /**
                 * @return {?}
                 */
                MatSlider.prototype._onKeyup = function () {
                    this._isSliding = false;
                };
                /**
                 * Increments the slider by the given number of steps (negative number decrements).
                 * @private
                 * @param {?} numSteps
                 * @return {?}
                 */
                MatSlider.prototype._increment = function (numSteps) {
                    this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);
                };
                /**
                 * Calculate the new value from the new physical location. The value will always be snapped.
                 * @private
                 * @param {?} pos
                 * @return {?}
                 */
                MatSlider.prototype._updateValueFromPosition = function (pos) {
                    if (!this._sliderDimensions) {
                        return;
                    }
                    /** @type {?} */
                    var offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
                    /** @type {?} */
                    var size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
                    /** @type {?} */
                    var posComponent = this.vertical ? pos.y : pos.x;
                    // The exact value is calculated from the event and used to find the closest snap value.
                    /** @type {?} */
                    var percent = this._clamp((posComponent - offset) / size);
                    if (this._shouldInvertMouseCoords()) {
                        percent = 1 - percent;
                    }
                    // Since the steps may not divide cleanly into the max value, if the user
                    // slid to 0 or 100 percent, we jump to the min/max value. This approach
                    // is slightly more intuitive than using `Math.ceil` below, because it
                    // follows the user's pointer closer.
                    if (percent === 0) {
                        this.value = this.min;
                    }
                    else if (percent === 1) {
                        this.value = this.max;
                    }
                    else {
                        /** @type {?} */
                        var exactValue = this._calculateValue(percent);
                        // This calculation finds the closest step by finding the closest
                        // whole number divisible by the step relative to the min.
                        /** @type {?} */
                        var closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
                        // The value needs to snap to the min and max.
                        this.value = this._clamp(closestValue, this.min, this.max);
                    }
                };
                /**
                 * Emits a change event if the current value is different from the last emitted value.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._emitChangeEvent = function () {
                    this._controlValueAccessorChangeFn(this.value);
                    this.valueChange.emit(this.value);
                    this.change.emit(this._createChangeEvent());
                };
                /**
                 * Emits an input event when the current value is different from the last emitted value.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._emitInputEvent = function () {
                    this.input.emit(this._createChangeEvent());
                };
                /**
                 * Updates the amount of space between ticks as a percentage of the width of the slider.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._updateTickIntervalPercent = function () {
                    if (!this.tickInterval || !this._sliderDimensions) {
                        return;
                    }
                    if (this.tickInterval == 'auto') {
                        /** @type {?} */
                        var trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
                        /** @type {?} */
                        var pixelsPerStep = trackSize * this.step / (this.max - this.min);
                        /** @type {?} */
                        var stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
                        /** @type {?} */
                        var pixelsPerTick = stepsPerTick * this.step;
                        this._tickIntervalPercent = pixelsPerTick / trackSize;
                    }
                    else {
                        this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
                    }
                };
                /**
                 * Creates a slider change object from the specified value.
                 * @private
                 * @param {?=} value
                 * @return {?}
                 */
                MatSlider.prototype._createChangeEvent = function (value) {
                    if (value === void 0) { value = this.value; }
                    /** @type {?} */
                    var event = new MatSliderChange();
                    event.source = this;
                    event.value = value;
                    return event;
                };
                /**
                 * Calculates the percentage of the slider that a value is.
                 * @private
                 * @param {?} value
                 * @return {?}
                 */
                MatSlider.prototype._calculatePercentage = function (value) {
                    return ((value || 0) - this.min) / (this.max - this.min);
                };
                /**
                 * Calculates the value a percentage of the slider corresponds to.
                 * @private
                 * @param {?} percentage
                 * @return {?}
                 */
                MatSlider.prototype._calculateValue = function (percentage) {
                    return this.min + percentage * (this.max - this.min);
                };
                /**
                 * Return a number between two numbers.
                 * @private
                 * @param {?} value
                 * @param {?=} min
                 * @param {?=} max
                 * @return {?}
                 */
                MatSlider.prototype._clamp = function (value, min, max) {
                    if (min === void 0) { min = 0; }
                    if (max === void 0) { max = 1; }
                    return Math.max(min, Math.min(value, max));
                };
                /**
                 * Get the bounding client rect of the slider track element.
                 * The track is used rather than the native element to ignore the extra space that the thumb can
                 * take up.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._getSliderDimensions = function () {
                    return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;
                };
                /**
                 * Focuses the native element.
                 * Currently only used to allow a blur event to fire but will be used with keyboard input later.
                 * @private
                 * @param {?=} options
                 * @return {?}
                 */
                MatSlider.prototype._focusHostElement = function (options) {
                    this._elementRef.nativeElement.focus(options);
                };
                /**
                 * Blurs the native element.
                 * @private
                 * @return {?}
                 */
                MatSlider.prototype._blurHostElement = function () {
                    this._elementRef.nativeElement.blur();
                };
                /**
                 * Sets the model value. Implemented as part of ControlValueAccessor.
                 * @param {?} value
                 * @return {?}
                 */
                MatSlider.prototype.writeValue = function (value) {
                    this.value = value;
                };
                /**
                 * Registers a callback to be triggered when the value has changed.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatSlider.prototype.registerOnChange = function (fn) {
                    this._controlValueAccessorChangeFn = fn;
                };
                /**
                 * Registers a callback to be triggered when the component is touched.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} fn Callback to be registered.
                 * @return {?}
                 */
                MatSlider.prototype.registerOnTouched = function (fn) {
                    this.onTouched = fn;
                };
                /**
                 * Sets whether the component should be disabled.
                 * Implemented as part of ControlValueAccessor.
                 * @param {?} isDisabled
                 * @return {?}
                 */
                MatSlider.prototype.setDisabledState = function (isDisabled) {
                    this.disabled = isDisabled;
                };
                return MatSlider;
            }(_MatSliderMixinBase));
            MatSlider.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Component"], args: [{ selector: 'mat-slider',
                            exportAs: 'matSlider',
                            providers: [MAT_SLIDER_VALUE_ACCESSOR],
                            host: {
                                '(focus)': '_onFocus()',
                                '(blur)': '_onBlur()',
                                '(mousedown)': '_onMousedown($event)',
                                '(keydown)': '_onKeydown($event)',
                                '(keyup)': '_onKeyup()',
                                '(mouseenter)': '_onMouseenter()',
                                '(slide)': '_onSlide($event)',
                                '(slideend)': '_onSlideEnd()',
                                '(slidestart)': '_onSlideStart($event)',
                                // On Safari starting to slide temporarily triggers text selection mode which
                                // show the wrong cursor. We prevent it by stopping the `selectstart` event.
                                '(selectstart)': '$event.preventDefault()',
                                'class': 'mat-slider',
                                'role': 'slider',
                                '[tabIndex]': 'tabIndex',
                                '[attr.aria-disabled]': 'disabled',
                                '[attr.aria-valuemax]': 'max',
                                '[attr.aria-valuemin]': 'min',
                                '[attr.aria-valuenow]': 'value',
                                '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                                '[class.mat-slider-disabled]': 'disabled',
                                '[class.mat-slider-has-ticks]': 'tickInterval',
                                '[class.mat-slider-horizontal]': '!vertical',
                                '[class.mat-slider-axis-inverted]': '_invertAxis',
                                // Class binding which is only used by the test harness as there is no other
                                // way for the harness to detect if mouse coordinates need to be inverted.
                                '[class.mat-slider-invert-mouse-coords]': '_shouldInvertMouseCoords()',
                                '[class.mat-slider-sliding]': '_isSliding',
                                '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
                                '[class.mat-slider-vertical]': 'vertical',
                                '[class.mat-slider-min-value]': '_isMinValue',
                                '[class.mat-slider-hide-last-tick]': 'disabled || _isMinValue && _thumbGap && _invertAxis',
                                '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                            },
                            template: "<div class=\"mat-slider-wrapper\" #sliderWrapper><div class=\"mat-slider-track-wrapper\"><div class=\"mat-slider-track-background\" [ngStyle]=\"_trackBackgroundStyles\"></div><div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div></div><div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\"><div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div></div><div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\"><div class=\"mat-slider-focus-ring\"></div><div class=\"mat-slider-thumb\"></div><div class=\"mat-slider-thumb-label\"><span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span></div></div></div>",
                            styles: [".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:0;vertical-align:middle}.mat-slider.mat-slider-sliding:not(.mat-slider-disabled),.mat-slider:not(.mat-slider-disabled):active{cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{background-repeat:repeat;background-clip:content-box;box-sizing:border-box;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(.7);transition:transform .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1),border-color .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform .4s cubic-bezier(.25,.8,.25,1),border-radius .4s cubic-bezier(.25,.8,.25,1),background-color .4s cubic-bezier(.25,.8,.25,1)}@media (-ms-high-contrast:active){.mat-slider-thumb-label{outline:solid 1px}}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-sliding .mat-slider-thumb-container,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-track-fill{transition-duration:0s}.mat-slider-has-ticks .mat-slider-wrapper::after{content:'';position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity .4s cubic-bezier(.25,.8,.25,1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}@media (-ms-high-contrast:active){.mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}@media (-ms-high-contrast:active){.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}@media (-ms-high-contrast:active){.mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-track-fill{transition:none}"],
                            inputs: ['disabled', 'color', 'tabIndex'],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatSlider.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ElementRef"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ChangeDetectorRef"] },
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_1__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Optional"] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Attribute"], args: ['tabindex',] }] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Inject"], args: [_angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_7__["ANIMATION_MODULE_TYPE"],] }] }
            ]; };
            MatSlider.propDecorators = {
                invert: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                max: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                min: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                step: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                thumbLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                tickInterval: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                displayWith: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                vertical: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Input"] }],
                change: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                input: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                valueChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["Output"] }],
                _sliderWrapper: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["ViewChild"], args: ['sliderWrapper', { static: false },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSliderModule = /** @class */ (function () {
                function MatSliderModule() {
                }
                return MatSliderModule;
            }());
            MatSliderModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_4__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_9__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            exports: [MatSlider, _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["MatCommonModule"]],
                            declarations: [MatSlider],
                            providers: [{ provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_10__["HAMMER_GESTURE_CONFIG"], useClass: _angular_material_core__WEBPACK_IMPORTED_MODULE_6__["GestureConfig"] }]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=slider.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/snack-bar.js": 
        /*!*************************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/snack-bar.js ***!
          \*************************************************************/
        /*! exports provided: MatSnackBarModule, MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY, MAT_SNACK_BAR_DEFAULT_OPTIONS, MatSnackBar, MatSnackBarContainer, MAT_SNACK_BAR_DATA, MatSnackBarConfig, MatSnackBarRef, SimpleSnackBar, matSnackBarAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarModule", function () { return MatSnackBarModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY", function () { return MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DEFAULT_OPTIONS", function () { return MAT_SNACK_BAR_DEFAULT_OPTIONS; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBar", function () { return MatSnackBar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarContainer", function () { return MatSnackBarContainer; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SNACK_BAR_DATA", function () { return MAT_SNACK_BAR_DATA; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarConfig", function () { return MatSnackBarConfig; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSnackBarRef", function () { return MatSnackBarRef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleSnackBar", function () { return SimpleSnackBar; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matSnackBarAnimations", function () { return matSnackBarAnimations; });
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/overlay */ "./node_modules/@angular/cdk/esm2015/overlay.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/cdk/layout */ "./node_modules/@angular/cdk/esm2015/layout.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Reference to a snack bar dispatched from the snack bar service.
             * @template T
             */
            var MatSnackBarRef = /** @class */ (function () {
                /**
                 * @param {?} containerInstance
                 * @param {?} _overlayRef
                 */
                function MatSnackBarRef(containerInstance, _overlayRef) {
                    var _this = this;
                    this._overlayRef = _overlayRef;
                    /**
                     * Subject for notifying the user that the snack bar has been dismissed.
                     */
                    this._afterDismissed = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Subject for notifying the user that the snack bar has opened and appeared.
                     */
                    this._afterOpened = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Subject for notifying the user that the snack bar action was called.
                     */
                    this._onAction = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Whether the snack bar was dismissed using the action button.
                     */
                    this._dismissedByAction = false;
                    this.containerInstance = containerInstance;
                    // Dismiss snackbar on action.
                    this.onAction().subscribe(( /**
                     * @return {?}
                     */function () { return _this.dismiss(); }));
                    containerInstance._onExit.subscribe(( /**
                     * @return {?}
                     */function () { return _this._finishDismiss(); }));
                }
                /**
                 * Dismisses the snack bar.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.dismiss = function () {
                    if (!this._afterDismissed.closed) {
                        this.containerInstance.exit();
                    }
                    clearTimeout(this._durationTimeoutId);
                };
                /**
                 * Marks the snackbar action clicked.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.dismissWithAction = function () {
                    if (!this._onAction.closed) {
                        this._dismissedByAction = true;
                        this._onAction.next();
                        this._onAction.complete();
                    }
                };
                /**
                 * Marks the snackbar action clicked.
                 * @deprecated Use `dismissWithAction` instead.
                 * \@breaking-change 8.0.0
                 * @return {?}
                 */
                MatSnackBarRef.prototype.closeWithAction = function () {
                    this.dismissWithAction();
                };
                /**
                 * Dismisses the snack bar after some duration
                 * @param {?} duration
                 * @return {?}
                 */
                MatSnackBarRef.prototype._dismissAfter = function (duration) {
                    var _this = this;
                    this._durationTimeoutId = setTimeout(( /**
                     * @return {?}
                     */function () { return _this.dismiss(); }), duration);
                };
                /**
                 * Marks the snackbar as opened
                 * @return {?}
                 */
                MatSnackBarRef.prototype._open = function () {
                    if (!this._afterOpened.closed) {
                        this._afterOpened.next();
                        this._afterOpened.complete();
                    }
                };
                /**
                 * Cleans up the DOM after closing.
                 * @private
                 * @return {?}
                 */
                MatSnackBarRef.prototype._finishDismiss = function () {
                    this._overlayRef.dispose();
                    if (!this._onAction.closed) {
                        this._onAction.complete();
                    }
                    this._afterDismissed.next({ dismissedByAction: this._dismissedByAction });
                    this._afterDismissed.complete();
                    this._dismissedByAction = false;
                };
                /**
                 * Gets an observable that is notified when the snack bar is finished closing.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.afterDismissed = function () {
                    return this._afterDismissed.asObservable();
                };
                /**
                 * Gets an observable that is notified when the snack bar has opened and appeared.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.afterOpened = function () {
                    return this.containerInstance._onEnter;
                };
                /**
                 * Gets an observable that is notified when the snack bar action is called.
                 * @return {?}
                 */
                MatSnackBarRef.prototype.onAction = function () {
                    return this._onAction.asObservable();
                };
                return MatSnackBarRef;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to access the data that was passed in to a snack bar.
             * @type {?}
             */
            var MAT_SNACK_BAR_DATA = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('MatSnackBarData');
            /**
             * Configuration used when opening a snack-bar.
             * @template D
             */
            var MatSnackBarConfig = /** @class */ (function () {
                function MatSnackBarConfig() {
                    /**
                     * The politeness level for the MatAriaLiveAnnouncer announcement.
                     */
                    this.politeness = 'assertive';
                    /**
                     * Message to be announced by the LiveAnnouncer. When opening a snackbar without a custom
                     * component or template, the announcement message will default to the specified message.
                     */
                    this.announcementMessage = '';
                    /**
                     * The length of time in milliseconds to wait before automatically dismissing the snack bar.
                     */
                    this.duration = 0;
                    /**
                     * Data being injected into the child component.
                     */
                    this.data = null;
                    /**
                     * The horizontal position to place the snack bar.
                     */
                    this.horizontalPosition = 'center';
                    /**
                     * The vertical position to place the snack bar.
                     */
                    this.verticalPosition = 'bottom';
                }
                return MatSnackBarConfig;
            }());
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * A component used to open as the default snack bar, matching material spec.
             * This should only be used internally by the snack bar service.
             */
            var SimpleSnackBar = /** @class */ (function () {
                /**
                 * @param {?} snackBarRef
                 * @param {?} data
                 */
                function SimpleSnackBar(snackBarRef, data) {
                    this.snackBarRef = snackBarRef;
                    this.data = data;
                }
                /**
                 * Performs the action on the snack bar.
                 * @return {?}
                 */
                SimpleSnackBar.prototype.action = function () {
                    this.snackBarRef.dismissWithAction();
                };
                Object.defineProperty(SimpleSnackBar.prototype, "hasAction", {
                    /**
                     * If the action button should be shown.
                     * @return {?}
                     */
                    get: function () {
                        return !!this.data.action;
                    },
                    enumerable: true,
                    configurable: true
                });
                return SimpleSnackBar;
            }());
            SimpleSnackBar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'simple-snack-bar',
                            template: "<span>{{data.message}}</span><div class=\"mat-simple-snackbar-action\" *ngIf=\"hasAction\"><button mat-button (click)=\"action()\">{{data.action}}</button></div>",
                            styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                            host: {
                                'class': 'mat-simple-snackbar',
                            }
                        },] },
            ];
            /** @nocollapse */
            SimpleSnackBar.ctorParameters = function () { return [
                { type: MatSnackBarRef },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_SNACK_BAR_DATA,] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material snack bar.
             * \@docs-private
             * @type {?}
             */
            var matSnackBarAnimations = {
                /**
                 * Animation that shows and hides a snack bar.
                 */
                snackBarState: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["trigger"])('state', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('void, hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        transform: 'scale(0.8)',
                        opacity: 0,
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])('visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        transform: 'scale(1)',
                        opacity: 1,
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('* => visible', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('150ms cubic-bezier(0, 0, 0.2, 1)')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])('* => void, * => hidden', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])('75ms cubic-bezier(0.4, 0.0, 1, 1)', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        opacity: 0
                    }))),
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Internal component that wraps user-provided snack bar content.
             * \@docs-private
             */
            var MatSnackBarContainer = /** @class */ (function (_super) {
                __extends(MatSnackBarContainer, _super);
                /**
                 * @param {?} _ngZone
                 * @param {?} _elementRef
                 * @param {?} _changeDetectorRef
                 * @param {?} snackBarConfig
                 */
                function MatSnackBarContainer(_ngZone, _elementRef, _changeDetectorRef, snackBarConfig) {
                    var _this = _super.call(this) || this;
                    _this._ngZone = _ngZone;
                    _this._elementRef = _elementRef;
                    _this._changeDetectorRef = _changeDetectorRef;
                    _this.snackBarConfig = snackBarConfig;
                    /**
                     * Whether the component has been destroyed.
                     */
                    _this._destroyed = false;
                    /**
                     * Subject for notifying that the snack bar has exited from view.
                     */
                    _this._onExit = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * Subject for notifying that the snack bar has finished entering the view.
                     */
                    _this._onEnter = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
                    /**
                     * The state of the snack bar animations.
                     */
                    _this._animationState = 'void';
                    // Based on the ARIA spec, `alert` and `status` roles have an
                    // implicit `assertive` and `polite` politeness respectively.
                    if (snackBarConfig.politeness === 'assertive' && !snackBarConfig.announcementMessage) {
                        _this._role = 'alert';
                    }
                    else if (snackBarConfig.politeness === 'off') {
                        _this._role = null;
                    }
                    else {
                        _this._role = 'status';
                    }
                    return _this;
                }
                /**
                 * Attach a component portal as content to this snack bar container.
                 * @template T
                 * @param {?} portal
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.attachComponentPortal = function (portal) {
                    this._assertNotAttached();
                    this._applySnackBarClasses();
                    return this._portalOutlet.attachComponentPortal(portal);
                };
                /**
                 * Attach a template portal as content to this snack bar container.
                 * @template C
                 * @param {?} portal
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.attachTemplatePortal = function (portal) {
                    this._assertNotAttached();
                    this._applySnackBarClasses();
                    return this._portalOutlet.attachTemplatePortal(portal);
                };
                /**
                 * Handle end of animations, updating the state of the snackbar.
                 * @param {?} event
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.onAnimationEnd = function (event) {
                    var fromState = event.fromState, toState = event.toState;
                    if ((toState === 'void' && fromState !== 'void') || toState === 'hidden') {
                        this._completeExit();
                    }
                    if (toState === 'visible') {
                        // Note: we shouldn't use `this` inside the zone callback,
                        // because it can cause a memory leak.
                        /** @type {?} */
                        var onEnter_1 = this._onEnter;
                        this._ngZone.run(( /**
                         * @return {?}
                         */function () {
                            onEnter_1.next();
                            onEnter_1.complete();
                        }));
                    }
                };
                /**
                 * Begin animation of snack bar entrance into view.
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.enter = function () {
                    if (!this._destroyed) {
                        this._animationState = 'visible';
                        this._changeDetectorRef.detectChanges();
                    }
                };
                /**
                 * Begin animation of the snack bar exiting from view.
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.exit = function () {
                    // Note: this one transitions to `hidden`, rather than `void`, in order to handle the case
                    // where multiple snack bars are opened in quick succession (e.g. two consecutive calls to
                    // `MatSnackBar.open`).
                    this._animationState = 'hidden';
                    return this._onExit;
                };
                /**
                 * Makes sure the exit callbacks have been invoked when the element is destroyed.
                 * @return {?}
                 */
                MatSnackBarContainer.prototype.ngOnDestroy = function () {
                    this._destroyed = true;
                    this._completeExit();
                };
                /**
                 * Waits for the zone to settle before removing the element. Helps prevent
                 * errors where we end up removing an element which is in the middle of an animation.
                 * @private
                 * @return {?}
                 */
                MatSnackBarContainer.prototype._completeExit = function () {
                    var _this = this;
                    this._ngZone.onMicrotaskEmpty.asObservable().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["take"])(1)).subscribe(( /**
                     * @return {?}
                     */function () {
                        _this._onExit.next();
                        _this._onExit.complete();
                    }));
                };
                /**
                 * Applies the various positioning and user-configured CSS classes to the snack bar.
                 * @private
                 * @return {?}
                 */
                MatSnackBarContainer.prototype._applySnackBarClasses = function () {
                    /** @type {?} */
                    var element = this._elementRef.nativeElement;
                    /** @type {?} */
                    var panelClasses = this.snackBarConfig.panelClass;
                    if (panelClasses) {
                        if (Array.isArray(panelClasses)) {
                            // Note that we can't use a spread here, because IE doesn't support multiple arguments.
                            panelClasses.forEach(( /**
                             * @param {?} cssClass
                             * @return {?}
                             */function (/**
                             * @param {?} cssClass
                             * @return {?}
                             */ cssClass) { return element.classList.add(cssClass); }));
                        }
                        else {
                            element.classList.add(panelClasses);
                        }
                    }
                    if (this.snackBarConfig.horizontalPosition === 'center') {
                        element.classList.add('mat-snack-bar-center');
                    }
                    if (this.snackBarConfig.verticalPosition === 'top') {
                        element.classList.add('mat-snack-bar-top');
                    }
                };
                /**
                 * Asserts that no content is already attached to the container.
                 * @private
                 * @return {?}
                 */
                MatSnackBarContainer.prototype._assertNotAttached = function () {
                    if (this._portalOutlet.hasAttached()) {
                        throw Error('Attempting to attach snack bar content after content is already attached');
                    }
                };
                return MatSnackBarContainer;
            }(_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["BasePortalOutlet"]));
            MatSnackBarContainer.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'snack-bar-container',
                            template: "<ng-template cdkPortalOutlet></ng-template>",
                            styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}@media (-ms-high-contrast:active){.mat-snack-bar-container{border:solid 1px}}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}"],
                            // In Ivy embedded views will be change detected from their declaration place, rather than
                            // where they were stamped out. This means that we can't have the snack bar container be OnPush,
                            // because it might cause snack bars that were opened from a template not to be out of date.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            animations: [matSnackBarAnimations.snackBarState],
                            host: {
                                '[attr.role]': '_role',
                                'class': 'mat-snack-bar-container',
                                '[@state]': '_animationState',
                                '(@state.done)': 'onAnimationEnd($event)'
                            },
                        },] },
            ];
            /** @nocollapse */
            MatSnackBarContainer.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: MatSnackBarConfig }
            ]; };
            MatSnackBarContainer.propDecorators = {
                _portalOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["CdkPortalOutlet"], { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSnackBarModule = /** @class */ (function () {
                function MatSnackBarModule() {
                }
                return MatSnackBarModule;
            }());
            MatSnackBarModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["OverlayModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_8__["MatButtonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                            ],
                            exports: [MatSnackBarContainer, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"]],
                            declarations: [MatSnackBarContainer, SimpleSnackBar],
                            entryComponents: [MatSnackBarContainer, SimpleSnackBar],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Injection token that can be used to specify default snack bar.
             * @type {?}
             */
            var MAT_SNACK_BAR_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["InjectionToken"]('mat-snack-bar-default-options', {
                providedIn: 'root',
                factory: MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY,
            });
            /**
             * \@docs-private
             * @return {?}
             */
            function MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY() {
                return new MatSnackBarConfig();
            }
            /**
             * Service to dispatch Material Design snack bar messages.
             */
            var MatSnackBar = /** @class */ (function () {
                /**
                 * @param {?} _overlay
                 * @param {?} _live
                 * @param {?} _injector
                 * @param {?} _breakpointObserver
                 * @param {?} _parentSnackBar
                 * @param {?} _defaultConfig
                 */
                function MatSnackBar(_overlay, _live, _injector, _breakpointObserver, _parentSnackBar, _defaultConfig) {
                    this._overlay = _overlay;
                    this._live = _live;
                    this._injector = _injector;
                    this._breakpointObserver = _breakpointObserver;
                    this._parentSnackBar = _parentSnackBar;
                    this._defaultConfig = _defaultConfig;
                    /**
                     * Reference to the current snack bar in the view *at this level* (in the Angular injector tree).
                     * If there is a parent snack-bar service, all operations should delegate to that parent
                     * via `_openedSnackBarRef`.
                     */
                    this._snackBarRefAtThisLevel = null;
                }
                Object.defineProperty(MatSnackBar.prototype, "_openedSnackBarRef", {
                    /**
                     * Reference to the currently opened snackbar at *any* level.
                     * @return {?}
                     */
                    get: function () {
                        /** @type {?} */
                        var parent = this._parentSnackBar;
                        return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;
                    },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        if (this._parentSnackBar) {
                            this._parentSnackBar._openedSnackBarRef = value;
                        }
                        else {
                            this._snackBarRefAtThisLevel = value;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Creates and dispatches a snack bar with a custom component for the content, removing any
                 * currently opened snack bars.
                 *
                 * @template T
                 * @param {?} component Component to be instantiated.
                 * @param {?=} config Extra configuration for the snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype.openFromComponent = function (component, config) {
                    return ( /** @type {?} */(this._attach(component, config)));
                };
                /**
                 * Creates and dispatches a snack bar with a custom template for the content, removing any
                 * currently opened snack bars.
                 *
                 * @param {?} template Template to be instantiated.
                 * @param {?=} config Extra configuration for the snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype.openFromTemplate = function (template, config) {
                    return this._attach(template, config);
                };
                /**
                 * Opens a snackbar with a message and an optional action.
                 * @param {?} message The message to show in the snackbar.
                 * @param {?=} action The label for the snackbar action.
                 * @param {?=} config Additional configuration options for the snackbar.
                 * @return {?}
                 */
                MatSnackBar.prototype.open = function (message, action, config) {
                    if (action === void 0) { action = ''; }
                    /** @type {?} */
                    var _config = Object.assign({}, this._defaultConfig, config);
                    // Since the user doesn't have access to the component, we can
                    // override the data to pass in our own message and action.
                    _config.data = { message: message, action: action };
                    if (!_config.announcementMessage) {
                        _config.announcementMessage = message;
                    }
                    return this.openFromComponent(SimpleSnackBar, _config);
                };
                /**
                 * Dismisses the currently-visible snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype.dismiss = function () {
                    if (this._openedSnackBarRef) {
                        this._openedSnackBarRef.dismiss();
                    }
                };
                /**
                 * @return {?}
                 */
                MatSnackBar.prototype.ngOnDestroy = function () {
                    // Only dismiss the snack bar at the current level on destroy.
                    if (this._snackBarRefAtThisLevel) {
                        this._snackBarRefAtThisLevel.dismiss();
                    }
                };
                /**
                 * Attaches the snack bar container component to the overlay.
                 * @private
                 * @param {?} overlayRef
                 * @param {?} config
                 * @return {?}
                 */
                MatSnackBar.prototype._attachSnackBarContainer = function (overlayRef, config) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    /** @type {?} */
                    var injector = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatSnackBarConfig, config]
                    ]));
                    /** @type {?} */
                    var containerPortal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](MatSnackBarContainer, config.viewContainerRef, injector);
                    /** @type {?} */
                    var containerRef = overlayRef.attach(containerPortal);
                    containerRef.instance.snackBarConfig = config;
                    return containerRef.instance;
                };
                /**
                 * Places a new component or a template as the content of the snack bar container.
                 * @private
                 * @template T
                 * @param {?} content
                 * @param {?=} userConfig
                 * @return {?}
                 */
                MatSnackBar.prototype._attach = function (content, userConfig) {
                    /** @type {?} */
                    var config = Object.assign({}, new MatSnackBarConfig(), this._defaultConfig, userConfig);
                    /** @type {?} */
                    var overlayRef = this._createOverlay(config);
                    /** @type {?} */
                    var container = this._attachSnackBarContainer(overlayRef, config);
                    /** @type {?} */
                    var snackBarRef = new MatSnackBarRef(container, overlayRef);
                    if (content instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__["TemplateRef"]) {
                        /** @type {?} */
                        var portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["TemplatePortal"](content, ( /** @type {?} */(null)), ( /** @type {?} */({
                            $implicit: config.data,
                            snackBarRef: snackBarRef
                        })));
                        snackBarRef.instance = container.attachTemplatePortal(portal);
                    }
                    else {
                        /** @type {?} */
                        var injector = this._createInjector(config, snackBarRef);
                        /** @type {?} */
                        var portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["ComponentPortal"](content, undefined, injector);
                        /** @type {?} */
                        var contentRef = container.attachComponentPortal(portal);
                        // We can't pass this via the injector, because the injector is created earlier.
                        snackBarRef.instance = contentRef.instance;
                    }
                    // Subscribe to the breakpoint observer and attach the mat-snack-bar-handset class as
                    // appropriate. This class is applied to the overlay element because the overlay must expand to
                    // fill the width of the screen for full width snackbars.
                    this._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__["Breakpoints"].HandsetPortrait).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["takeUntil"])(overlayRef.detachments())).subscribe(( /**
                     * @param {?} state
                     * @return {?}
                     */function (/**
                     * @param {?} state
                     * @return {?}
                     */ state$$1) {
                        /** @type {?} */
                        var classList = overlayRef.overlayElement.classList;
                        /** @type {?} */
                        var className = 'mat-snack-bar-handset';
                        state$$1.matches ? classList.add(className) : classList.remove(className);
                    }));
                    this._animateSnackBar(snackBarRef, config);
                    this._openedSnackBarRef = snackBarRef;
                    return this._openedSnackBarRef;
                };
                /**
                 * Animates the old snack bar out and the new one in.
                 * @private
                 * @param {?} snackBarRef
                 * @param {?} config
                 * @return {?}
                 */
                MatSnackBar.prototype._animateSnackBar = function (snackBarRef, config) {
                    var _this = this;
                    // When the snackbar is dismissed, clear the reference to it.
                    snackBarRef.afterDismissed().subscribe(( /**
                     * @return {?}
                     */function () {
                        // Clear the snackbar ref if it hasn't already been replaced by a newer snackbar.
                        if (_this._openedSnackBarRef == snackBarRef) {
                            _this._openedSnackBarRef = null;
                        }
                        if (config.announcementMessage) {
                            _this._live.clear();
                        }
                    }));
                    if (this._openedSnackBarRef) {
                        // If a snack bar is already in view, dismiss it and enter the
                        // new snack bar after exit animation is complete.
                        this._openedSnackBarRef.afterDismissed().subscribe(( /**
                         * @return {?}
                         */function () {
                            snackBarRef.containerInstance.enter();
                        }));
                        this._openedSnackBarRef.dismiss();
                    }
                    else {
                        // If no snack bar is in view, enter the new snack bar.
                        snackBarRef.containerInstance.enter();
                    }
                    // If a dismiss timeout is provided, set up dismiss based on after the snackbar is opened.
                    if (config.duration && config.duration > 0) {
                        snackBarRef.afterOpened().subscribe(( /**
                         * @return {?}
                         */function () { return snackBarRef._dismissAfter(( /** @type {?} */(config.duration))); }));
                    }
                    if (config.announcementMessage) {
                        this._live.announce(config.announcementMessage, config.politeness);
                    }
                };
                /**
                 * Creates a new overlay and places it in the correct location.
                 * @private
                 * @param {?} config The user-specified snack bar config.
                 * @return {?}
                 */
                MatSnackBar.prototype._createOverlay = function (config) {
                    /** @type {?} */
                    var overlayConfig = new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["OverlayConfig"]();
                    overlayConfig.direction = config.direction;
                    /** @type {?} */
                    var positionStrategy = this._overlay.position().global();
                    // Set horizontal position.
                    /** @type {?} */
                    var isRtl = config.direction === 'rtl';
                    /** @type {?} */
                    var isLeft = (config.horizontalPosition === 'left' ||
                        (config.horizontalPosition === 'start' && !isRtl) ||
                        (config.horizontalPosition === 'end' && isRtl));
                    /** @type {?} */
                    var isRight = !isLeft && config.horizontalPosition !== 'center';
                    if (isLeft) {
                        positionStrategy.left('0');
                    }
                    else if (isRight) {
                        positionStrategy.right('0');
                    }
                    else {
                        positionStrategy.centerHorizontally();
                    }
                    // Set horizontal position.
                    if (config.verticalPosition === 'top') {
                        positionStrategy.top('0');
                    }
                    else {
                        positionStrategy.bottom('0');
                    }
                    overlayConfig.positionStrategy = positionStrategy;
                    return this._overlay.create(overlayConfig);
                };
                /**
                 * Creates an injector to be used inside of a snack bar component.
                 * @private
                 * @template T
                 * @param {?} config Config that was used to create the snack bar.
                 * @param {?} snackBarRef Reference to the snack bar.
                 * @return {?}
                 */
                MatSnackBar.prototype._createInjector = function (config, snackBarRef) {
                    /** @type {?} */
                    var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
                    return new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_3__["PortalInjector"](userInjector || this._injector, new WeakMap([
                        [MatSnackBarRef, snackBarRef],
                        [MAT_SNACK_BAR_DATA, config.data]
                    ]));
                };
                return MatSnackBar;
            }());
            MatSnackBar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: MatSnackBarModule },] },
            ];
            /** @nocollapse */
            MatSnackBar.ctorParameters = function () { return [
                { type: _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["Overlay"] },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__["LiveAnnouncer"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"] },
                { type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__["BreakpointObserver"] },
                { type: MatSnackBar, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"] }] },
                { type: MatSnackBarConfig, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [MAT_SNACK_BAR_DEFAULT_OPTIONS,] }] }
            ]; };
            /** @nocollapse */ MatSnackBar.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function MatSnackBar_Factory() { return new MatSnackBar(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_5__["Overlay"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_9__["LiveAnnouncer"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__["INJECTOR"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_10__["BreakpointObserver"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(MatSnackBar, 12), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(MAT_SNACK_BAR_DEFAULT_OPTIONS)); }, token: MatSnackBar, providedIn: MatSnackBarModule });
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=snack-bar.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/sort.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/sort.js ***!
          \********************************************************/
        /*! exports provided: MatSortModule, MatSortHeader, MAT_SORT_HEADER_INTL_PROVIDER_FACTORY, MatSortHeaderIntl, MAT_SORT_HEADER_INTL_PROVIDER, MatSort, matSortAnimations */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSortModule", function () { return MatSortModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSortHeader", function () { return MatSortHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SORT_HEADER_INTL_PROVIDER_FACTORY", function () { return MAT_SORT_HEADER_INTL_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSortHeaderIntl", function () { return MatSortHeaderIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_SORT_HEADER_INTL_PROVIDER", function () { return MAT_SORT_HEADER_INTL_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatSort", function () { return MatSort; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matSortAnimations", function () { return matSortAnimations; });
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * \@docs-private
             * @param {?} id
             * @return {?}
             */
            function getSortDuplicateSortableIdError(id) {
                return Error("Cannot have two MatSortables with the same id (" + id + ").");
            }
            /**
             * \@docs-private
             * @return {?}
             */
            function getSortHeaderNotContainedWithinSortError() {
                return Error("MatSortHeader must be placed within a parent element with the MatSort directive.");
            }
            /**
             * \@docs-private
             * @return {?}
             */
            function getSortHeaderMissingIdError() {
                return Error("MatSortHeader must be provided with a unique id.");
            }
            /**
             * \@docs-private
             * @param {?} direction
             * @return {?}
             */
            function getSortInvalidDirectionError(direction) {
                return Error(direction + " is not a valid sort direction ('asc' or 'desc').");
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatSort.
            /**
             * \@docs-private
             */
            var MatSortBase = /** @class */ (function () {
                function MatSortBase() {
                }
                return MatSortBase;
            }());
            /** @type {?} */
            var _MatSortMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinInitialized"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinDisabled"])(MatSortBase));
            /**
             * Container for MatSortables to manage the sort state and provide default sort parameters.
             */
            var MatSort = /** @class */ (function (_super) {
                __extends(MatSort, _super);
                function MatSort() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    /**
                     * Collection of all registered sortables that this directive manages.
                     */
                    _this.sortables = new Map();
                    /**
                     * Used to notify any child components listening to state changes.
                     */
                    _this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    /**
                     * The direction to set when an MatSortable is initially sorted.
                     * May be overriden by the MatSortable's sort start.
                     */
                    _this.start = 'asc';
                    _this._direction = '';
                    /**
                     * Event emitted when the user changes either the active sort or sort direction.
                     */
                    _this.sortChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
                    return _this;
                }
                Object.defineProperty(MatSort.prototype, "direction", {
                    /**
                     * The sort direction of the currently active MatSortable.
                     * @return {?}
                     */
                    get: function () { return this._direction; },
                    /**
                     * @param {?} direction
                     * @return {?}
                     */
                    set: function (direction) {
                        if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["isDevMode"])() && direction && direction !== 'asc' && direction !== 'desc') {
                            throw getSortInvalidDirectionError(direction);
                        }
                        this._direction = direction;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatSort.prototype, "disableClear", {
                    /**
                     * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
                     * May be overriden by the MatSortable's disable clear input.
                     * @return {?}
                     */
                    get: function () { return this._disableClear; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) { this._disableClear = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Register function to be used by the contained MatSortables. Adds the MatSortable to the
                 * collection of MatSortables.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.register = function (sortable) {
                    if (!sortable.id) {
                        throw getSortHeaderMissingIdError();
                    }
                    if (this.sortables.has(sortable.id)) {
                        throw getSortDuplicateSortableIdError(sortable.id);
                    }
                    this.sortables.set(sortable.id, sortable);
                };
                /**
                 * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
                 * collection of contained MatSortables.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.deregister = function (sortable) {
                    this.sortables.delete(sortable.id);
                };
                /**
                 * Sets the active sort id and determines the new sort direction.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.sort = function (sortable) {
                    if (this.active != sortable.id) {
                        this.active = sortable.id;
                        this.direction = sortable.start ? sortable.start : this.start;
                    }
                    else {
                        this.direction = this.getNextSortDirection(sortable);
                    }
                    this.sortChange.emit({ active: this.active, direction: this.direction });
                };
                /**
                 * Returns the next sort direction of the active sortable, checking for potential overrides.
                 * @param {?} sortable
                 * @return {?}
                 */
                MatSort.prototype.getNextSortDirection = function (sortable) {
                    if (!sortable) {
                        return '';
                    }
                    // Get the sort direction cycle with the potential sortable overrides.
                    /** @type {?} */
                    var disableClear = sortable.disableClear != null ? sortable.disableClear : this.disableClear;
                    /** @type {?} */
                    var sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
                    // Get and return the next direction in the cycle
                    /** @type {?} */
                    var nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
                    if (nextDirectionIndex >= sortDirectionCycle.length) {
                        nextDirectionIndex = 0;
                    }
                    return sortDirectionCycle[nextDirectionIndex];
                };
                /**
                 * @return {?}
                 */
                MatSort.prototype.ngOnInit = function () {
                    this._markInitialized();
                };
                /**
                 * @return {?}
                 */
                MatSort.prototype.ngOnChanges = function () {
                    this._stateChanges.next();
                };
                /**
                 * @return {?}
                 */
                MatSort.prototype.ngOnDestroy = function () {
                    this._stateChanges.complete();
                };
                return MatSort;
            }(_MatSortMixinBase));
            MatSort.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matSort]',
                            exportAs: 'matSort',
                            inputs: ['disabled: matSortDisabled']
                        },] },
            ];
            MatSort.propDecorators = {
                active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortActive',] }],
                start: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortStart',] }],
                direction: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortDirection',] }],
                disableClear: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matSortDisableClear',] }],
                sortChange: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"], args: ['matSortChange',] }]
            };
            /**
             * Returns the sort direction cycle to use given the provided parameters of order and clear.
             * @param {?} start
             * @param {?} disableClear
             * @return {?}
             */
            function getSortDirectionCycle(start, disableClear) {
                /** @type {?} */
                var sortOrder = ['asc', 'desc'];
                if (start == 'desc') {
                    sortOrder.reverse();
                }
                if (!disableClear) {
                    sortOrder.push('');
                }
                return sortOrder;
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var SORT_ANIMATION_TRANSITION = _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationDurations"].ENTERING + ' ' +
                _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["AnimationCurves"].STANDARD_CURVE;
            /**
             * Animations used by MatSort.
             * \@docs-private
             * @type {?}
             */
            var matSortAnimations = {
                /**
                 * Animation that moves the sort indicator.
                 */
                indicator: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('indicator', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0px)' })),
                    // 10px is the height of the sort indicator, minus the width of the pointers
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(10px)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('active-asc <=> active-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION))
                ]),
                /**
                 * Animation that rotates the left pointer of the indicator based on the sorting direction.
                 */
                leftPointer: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('leftPointer', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(-45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('active-asc <=> active-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION))
                ]),
                /**
                 * Animation that rotates the right pointer of the indicator based on the sorting direction.
                 */
                rightPointer: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('rightPointer', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('active-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'rotate(-45deg)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('active-asc <=> active-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION))
                ]),
                /**
                 * Animation that controls the arrow opacity.
                 */
                arrowOpacity: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('arrowOpacity', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('desc-to-active, asc-to-active, active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ opacity: 1 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('desc-to-hint, asc-to-hint, hint', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ opacity: .54 })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ opacity: 0 })),
                    // Transition between all states except for immediate transitions
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => asc, * => desc, * => active, * => hint, * => void', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('0ms')),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* <=> *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION)),
                ]),
                /**
                 * Animation for the translation of the arrow as a whole. States are separated into two
                 * groups: ones with animations and others that are immediate. Immediate states are asc, desc,
                 * peek, and active. The other states define a specific animation (source-to-destination)
                 * and are determined as a function of their prev user-perceived state and what the next state
                 * should be.
                 */
                arrowPosition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('arrowPosition', [
                    // Hidden Above => Hint Center
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => desc-to-hint, * => desc-to-active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(-25%)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' })
                    ]))),
                    // Hint Center => Hidden Below
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => hint-to-desc, * => active-to-desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(25%)' })
                    ]))),
                    // Hidden Below => Hint Center
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => asc-to-hint, * => asc-to-active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(25%)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' })
                    ]))),
                    // Hint Center => Hidden Above
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => hint-to-asc, * => active-to-asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])(SORT_ANIMATION_TRANSITION, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["keyframes"])([
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' }),
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(-25%)' })
                    ]))),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(0)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('hint-to-desc, active-to-desc, desc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(-25%)' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('hint-to-asc, active-to-asc, asc', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translateY(25%)' })),
                ]),
                /**
                 * Necessary trigger that calls animate on children animations.
                 */
                allowChildren: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('allowChildren', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* <=> *', [
                        Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["query"])('@*', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animateChild"])(), { optional: true })
                    ])
                ]),
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * To modify the labels and text displayed, create a new instance of MatSortHeaderIntl and
             * include it in a custom provider.
             */
            var MatSortHeaderIntl = /** @class */ (function () {
                function MatSortHeaderIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
                    /**
                     * ARIA label for the sorting button.
                     */
                    this.sortButtonLabel = ( /**
                     * @param {?} id
                     * @return {?}
                     */function (id) {
                        return "Change sorting for " + id;
                    });
                }
                return MatSortHeaderIntl;
            }());
            MatSortHeaderIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatSortHeaderIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({ factory: function MatSortHeaderIntl_Factory() { return new MatSortHeaderIntl(); }, token: MatSortHeaderIntl, providedIn: "root" });
            /**
             * \@docs-private
             * @param {?} parentIntl
             * @return {?}
             */
            function MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl) {
                return parentIntl || new MatSortHeaderIntl();
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_SORT_HEADER_INTL_PROVIDER = {
                // If there is already an MatSortHeaderIntl available, use that. Otherwise, provide a new one.
                provide: MatSortHeaderIntl,
                deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_1__["SkipSelf"](), MatSortHeaderIntl]],
                useFactory: MAT_SORT_HEADER_INTL_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to the sort header.
            /**
             * \@docs-private
             */
            var MatSortHeaderBase = /** @class */ (function () {
                function MatSortHeaderBase() {
                }
                return MatSortHeaderBase;
            }());
            /** @type {?} */
            var _MatSortHeaderMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinDisabled"])(MatSortHeaderBase);
            /**
             * Applies sorting behavior (click to change sort) and styles to an element, including an
             * arrow to display the current sort direction.
             *
             * Must be provided with an id and contained within a parent MatSort directive.
             *
             * If used on header cells in a CdkTable, it will automatically default its id from its containing
             * column definition.
             */
            var MatSortHeader = /** @class */ (function (_super) {
                __extends(MatSortHeader, _super);
                /**
                 * @param {?} _intl
                 * @param {?} changeDetectorRef
                 * @param {?} _sort
                 * @param {?} _columnDef
                 */
                function MatSortHeader(_intl, changeDetectorRef, _sort, _columnDef) {
                    var _this = 
                    // Note that we use a string token for the `_columnDef`, because the value is provided both by
                    // `material/table` and `cdk/table` and we can't have the CDK depending on Material,
                    // and we want to avoid having the sort header depending on the CDK table because
                    // of this single reference.
                    _super.call(this) || this;
                    _this._intl = _intl;
                    _this._sort = _sort;
                    _this._columnDef = _columnDef;
                    /**
                     * Flag set to true when the indicator should be displayed while the sort is not active. Used to
                     * provide an affordance that the header is sortable by showing on focus and hover.
                     */
                    _this._showIndicatorHint = false;
                    /**
                     * The direction the arrow should be facing according to the current state.
                     */
                    _this._arrowDirection = '';
                    /**
                     * Whether the view state animation should show the transition between the `from` and `to` states.
                     */
                    _this._disableViewStateAnimation = false;
                    /**
                     * Sets the position of the arrow that displays when sorted.
                     */
                    _this.arrowPosition = 'after';
                    if (!_sort) {
                        throw getSortHeaderNotContainedWithinSortError();
                    }
                    _this._rerenderSubscription = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["merge"])(_sort.sortChange, _sort._stateChanges, _intl.changes)
                        .subscribe(( /**
                 * @return {?}
                 */function () {
                        if (_this._isSorted()) {
                            _this._updateArrowDirection();
                        }
                        // If this header was recently active and now no longer sorted, animate away the arrow.
                        if (!_this._isSorted() && _this._viewState && _this._viewState.toState === 'active') {
                            _this._disableViewStateAnimation = false;
                            _this._setAnimationTransitionState({ fromState: 'active', toState: _this._arrowDirection });
                        }
                        changeDetectorRef.markForCheck();
                    }));
                    return _this;
                }
                Object.defineProperty(MatSortHeader.prototype, "disableClear", {
                    /**
                     * Overrides the disable clear value of the containing MatSort for this MatSortable.
                     * @return {?}
                     */
                    get: function () { return this._disableClear; },
                    /**
                     * @param {?} v
                     * @return {?}
                     */
                    set: function (v) { this._disableClear = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_0__["coerceBooleanProperty"])(v); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @return {?}
                 */
                MatSortHeader.prototype.ngOnInit = function () {
                    if (!this.id && this._columnDef) {
                        this.id = this._columnDef.name;
                    }
                    // Initialize the direction of the arrow and set the view state to be immediately that state.
                    this._updateArrowDirection();
                    this._setAnimationTransitionState({ toState: this._isSorted() ? 'active' : this._arrowDirection });
                    this._sort.register(this);
                };
                /**
                 * @return {?}
                 */
                MatSortHeader.prototype.ngOnDestroy = function () {
                    this._sort.deregister(this);
                    this._rerenderSubscription.unsubscribe();
                };
                /**
                 * Sets the "hint" state such that the arrow will be semi-transparently displayed as a hint to the
                 * user showing what the active sort will become. If set to false, the arrow will fade away.
                 * @param {?} visible
                 * @return {?}
                 */
                MatSortHeader.prototype._setIndicatorHintVisible = function (visible) {
                    // No-op if the sort header is disabled - should not make the hint visible.
                    if (this._isDisabled() && visible) {
                        return;
                    }
                    this._showIndicatorHint = visible;
                    if (!this._isSorted()) {
                        this._updateArrowDirection();
                        if (this._showIndicatorHint) {
                            this._setAnimationTransitionState({ fromState: this._arrowDirection, toState: 'hint' });
                        }
                        else {
                            this._setAnimationTransitionState({ fromState: 'hint', toState: this._arrowDirection });
                        }
                    }
                };
                /**
                 * Sets the animation transition view state for the arrow's position and opacity. If the
                 * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that
                 * no animation appears.
                 * @param {?} viewState
                 * @return {?}
                 */
                MatSortHeader.prototype._setAnimationTransitionState = function (viewState) {
                    this._viewState = viewState;
                    // If the animation for arrow position state (opacity/translation) should be disabled,
                    // remove the fromState so that it jumps right to the toState.
                    if (this._disableViewStateAnimation) {
                        this._viewState = { toState: viewState.toState };
                    }
                };
                /**
                 * Triggers the sort on this sort header and removes the indicator hint.
                 * @return {?}
                 */
                MatSortHeader.prototype._handleClick = function () {
                    if (this._isDisabled()) {
                        return;
                    }
                    this._sort.sort(this);
                    // Do not show the animation if the header was already shown in the right position.
                    if (this._viewState.toState === 'hint' || this._viewState.toState === 'active') {
                        this._disableViewStateAnimation = true;
                    }
                    // If the arrow is now sorted, animate the arrow into place. Otherwise, animate it away into
                    // the direction it is facing.
                    /** @type {?} */
                    var viewState = this._isSorted() ?
                        { fromState: this._arrowDirection, toState: 'active' } :
                        { fromState: 'active', toState: this._arrowDirection };
                    this._setAnimationTransitionState(viewState);
                    this._showIndicatorHint = false;
                };
                /**
                 * Whether this MatSortHeader is currently sorted in either ascending or descending order.
                 * @return {?}
                 */
                MatSortHeader.prototype._isSorted = function () {
                    return this._sort.active == this.id &&
                        (this._sort.direction === 'asc' || this._sort.direction === 'desc');
                };
                /**
                 * Returns the animation state for the arrow direction (indicator and pointers).
                 * @return {?}
                 */
                MatSortHeader.prototype._getArrowDirectionState = function () {
                    return "" + (this._isSorted() ? 'active-' : '') + this._arrowDirection;
                };
                /**
                 * Returns the arrow position state (opacity, translation).
                 * @return {?}
                 */
                MatSortHeader.prototype._getArrowViewState = function () {
                    /** @type {?} */
                    var fromState = this._viewState.fromState;
                    return (fromState ? fromState + "-to-" : '') + this._viewState.toState;
                };
                /**
                 * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be
                 * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently
                 * active sorted direction. The reason this is updated through a function is because the direction
                 * should only be changed at specific times - when deactivated but the hint is displayed and when
                 * the sort is active and the direction changes. Otherwise the arrow's direction should linger
                 * in cases such as the sort becoming deactivated but we want to animate the arrow away while
                 * preserving its direction, even though the next sort direction is actually different and should
                 * only be changed once the arrow displays again (hint or activation).
                 * @return {?}
                 */
                MatSortHeader.prototype._updateArrowDirection = function () {
                    this._arrowDirection = this._isSorted() ?
                        this._sort.direction :
                        (this.start || this._sort.start);
                };
                /**
                 * @return {?}
                 */
                MatSortHeader.prototype._isDisabled = function () {
                    return this._sort.disabled || this.disabled;
                };
                /**
                 * Gets the aria-sort attribute that should be applied to this sort header. If this header
                 * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
                 * says that the aria-sort property should only be present on one header at a time, so removing
                 * ensures this is true.
                 * @return {?}
                 */
                MatSortHeader.prototype._getAriaSortAttribute = function () {
                    if (!this._isSorted()) {
                        return null;
                    }
                    return this._sort.direction == 'asc' ? 'ascending' : 'descending';
                };
                /**
                 * Whether the arrow inside the sort header should be rendered.
                 * @return {?}
                 */
                MatSortHeader.prototype._renderArrow = function () {
                    return !this._isDisabled() || this._isSorted();
                };
                return MatSortHeader;
            }(_MatSortHeaderMixinBase));
            MatSortHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: '[mat-sort-header]',
                            exportAs: 'matSortHeader',
                            template: "<div class=\"mat-sort-header-container\" [class.mat-sort-header-sorted]=\"_isSorted()\" [class.mat-sort-header-position-before]=\"arrowPosition == 'before'\"><button class=\"mat-sort-header-button\" type=\"button\" [attr.disabled]=\"_isDisabled() || null\" [attr.aria-label]=\"_intl.sortButtonLabel(id)\" (focus)=\"_setIndicatorHintVisible(true)\" (blur)=\"_setIndicatorHintVisible(false)\"><ng-content></ng-content></button><div class=\"mat-sort-header-arrow\" *ngIf=\"_renderArrow()\" [@arrowOpacity]=\"_getArrowViewState()\" [@arrowPosition]=\"_getArrowViewState()\" [@allowChildren]=\"_getArrowDirectionState()\" (@arrowPosition.start)=\"_disableViewStateAnimation = true\" (@arrowPosition.done)=\"_disableViewStateAnimation = false\"><div class=\"mat-sort-header-stem\"></div><div class=\"mat-sort-header-indicator\" [@indicator]=\"_getArrowDirectionState()\"><div class=\"mat-sort-header-pointer-left\" [@leftPointer]=\"_getArrowDirectionState()\"></div><div class=\"mat-sort-header-pointer-right\" [@rightPointer]=\"_getArrowDirectionState()\"></div><div class=\"mat-sort-header-pointer-middle\"></div></div></div></div>",
                            styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-button{border:none;background:0 0;display:flex;align-items:center;padding:0;cursor:inherit;outline:0;font:inherit;color:currentColor}.mat-sort-header-button::-moz-focus-inner{border:0}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}@media (-ms-high-contrast:active){.mat-sort-header-stem{width:0;border-left:solid 2px}}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}@media (-ms-high-contrast:active){.mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}@media (-ms-high-contrast:active){.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}"],
                            host: {
                                '(click)': '_handleClick()',
                                '(mouseenter)': '_setIndicatorHintVisible(true)',
                                '(mouseleave)': '_setIndicatorHintVisible(false)',
                                '[attr.aria-sort]': '_getAriaSortAttribute()',
                                '[class.mat-sort-header-disabled]': '_isDisabled()',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].OnPush,
                            inputs: ['disabled'],
                            animations: [
                                matSortAnimations.indicator,
                                matSortAnimations.leftPointer,
                                matSortAnimations.rightPointer,
                                matSortAnimations.arrowOpacity,
                                matSortAnimations.arrowPosition,
                                matSortAnimations.allowChildren,
                            ]
                        },] },
            ];
            /** @nocollapse */
            MatSortHeader.ctorParameters = function () { return [
                { type: MatSortHeaderIntl },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectorRef"] },
                { type: MatSort, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: ['MAT_SORT_HEADER_COLUMN_DEF',] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
            ]; };
            MatSortHeader.propDecorators = {
                id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['mat-sort-header',] }],
                arrowPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                start: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                disableClear: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatSortModule = /** @class */ (function () {
                function MatSortModule() {
                }
                return MatSortModule;
            }());
            MatSortModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__["CommonModule"]],
                            exports: [MatSort, MatSortHeader],
                            declarations: [MatSort, MatSortHeader],
                            providers: [MAT_SORT_HEADER_INTL_PROVIDER]
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=sort.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/stepper.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/stepper.js ***!
          \***********************************************************/
        /*! exports provided: MatStepperModule, MatStepLabel, MatStep, MatStepper, MatHorizontalStepper, MatVerticalStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MAT_STEPPER_INTL_PROVIDER_FACTORY, MatStepperIntl, MAT_STEPPER_INTL_PROVIDER, matStepperAnimations, MatStepperIcon */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperModule", function () { return MatStepperModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepLabel", function () { return MatStepLabel; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStep", function () { return MatStep; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepper", function () { return MatStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHorizontalStepper", function () { return MatHorizontalStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatVerticalStepper", function () { return MatVerticalStepper; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperNext", function () { return MatStepperNext; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperPrevious", function () { return MatStepperPrevious; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepHeader", function () { return MatStepHeader; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER_FACTORY", function () { return MAT_STEPPER_INTL_PROVIDER_FACTORY; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperIntl", function () { return MatStepperIntl; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAT_STEPPER_INTL_PROVIDER", function () { return MAT_STEPPER_INTL_PROVIDER; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matStepperAnimations", function () { return matStepperAnimations; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatStepperIcon", function () { return MatStepperIcon; });
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk/stepper */ "./node_modules/@angular/cdk/esm2015/stepper.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/a11y */ "./node_modules/@angular/cdk/esm2015/a11y.js");
            /* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm2015/animations.js");
            /* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/bidi */ "./node_modules/@angular/cdk/esm2015/bidi.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/portal */ "./node_modules/@angular/cdk/esm2015/portal.js");
            /* harmony import */ var _angular_material_button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/material/button */ "./node_modules/@angular/material/esm2015/button.js");
            /* harmony import */ var _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/icon */ "./node_modules/@angular/material/esm2015/icon.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepLabel = /** @class */ (function (_super) {
                __extends(MatStepLabel, _super);
                function MatStepLabel() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepLabel;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepLabel"]));
            MatStepLabel.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: '[matStepLabel]',
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Stepper data that is required for internationalization.
             */
            var MatStepperIntl = /** @class */ (function () {
                function MatStepperIntl() {
                    /**
                     * Stream that emits whenever the labels here are changed. Use this to notify
                     * components if the labels have changed after initialization.
                     */
                    this.changes = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    /**
                     * Label that is rendered below optional steps.
                     */
                    this.optionalLabel = 'Optional';
                }
                return MatStepperIntl;
            }());
            MatStepperIntl.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"], args: [{ providedIn: 'root' },] },
            ];
            /** @nocollapse */ MatStepperIntl.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({ factory: function MatStepperIntl_Factory() { return new MatStepperIntl(); }, token: MatStepperIntl, providedIn: "root" });
            /**
             * \@docs-private
             * @param {?} parentIntl
             * @return {?}
             */
            function MAT_STEPPER_INTL_PROVIDER_FACTORY(parentIntl) {
                return parentIntl || new MatStepperIntl();
            }
            /**
             * \@docs-private
             * @type {?}
             */
            var MAT_STEPPER_INTL_PROVIDER = {
                provide: MatStepperIntl,
                deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"](), new _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"](), MatStepperIntl]],
                useFactory: MAT_STEPPER_INTL_PROVIDER_FACTORY
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepHeader = /** @class */ (function (_super) {
                __extends(MatStepHeader, _super);
                /**
                 * @param {?} _intl
                 * @param {?} _focusMonitor
                 * @param {?} _elementRef
                 * @param {?} changeDetectorRef
                 */
                function MatStepHeader(_intl, _focusMonitor, _elementRef, changeDetectorRef) {
                    var _this = _super.call(this, _elementRef) || this;
                    _this._intl = _intl;
                    _this._focusMonitor = _focusMonitor;
                    _focusMonitor.monitor(_elementRef, true);
                    _this._intlSubscription = _intl.changes.subscribe(( /**
                     * @return {?}
                     */function () { return changeDetectorRef.markForCheck(); }));
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatStepHeader.prototype.ngOnDestroy = function () {
                    this._intlSubscription.unsubscribe();
                    this._focusMonitor.stopMonitoring(this._elementRef);
                };
                /**
                 * Focuses the step header.
                 * @return {?}
                 */
                MatStepHeader.prototype.focus = function () {
                    this._focusMonitor.focusVia(this._elementRef, 'program');
                };
                /**
                 * Returns string label of given step if it is a text label.
                 * @return {?}
                 */
                MatStepHeader.prototype._stringLabel = function () {
                    return this.label instanceof MatStepLabel ? null : this.label;
                };
                /**
                 * Returns MatStepLabel if the label of given step is a template label.
                 * @return {?}
                 */
                MatStepHeader.prototype._templateLabel = function () {
                    return this.label instanceof MatStepLabel ? this.label : null;
                };
                /**
                 * Returns the host HTML element.
                 * @return {?}
                 */
                MatStepHeader.prototype._getHostElement = function () {
                    return this._elementRef.nativeElement;
                };
                /**
                 * Template context variables that are exposed to the `matStepperIcon` instances.
                 * @return {?}
                 */
                MatStepHeader.prototype._getIconContext = function () {
                    return {
                        index: this.index,
                        active: this.active,
                        optional: this.optional
                    };
                };
                /**
                 * @param {?} state
                 * @return {?}
                 */
                MatStepHeader.prototype._getDefaultTextForState = function (state$$1) {
                    if (state$$1 == 'number') {
                        return "" + (this.index + 1);
                    }
                    if (state$$1 == 'edit') {
                        return 'create';
                    }
                    if (state$$1 == 'error') {
                        return 'warning';
                    }
                    return state$$1;
                };
                return MatStepHeader;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepHeader"]));
            MatStepHeader.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-step-header',
                            template: "<div class=\"mat-step-header-ripple\" matRipple [matRippleTrigger]=\"_getHostElement()\" [matRippleDisabled]=\"disableRipple\"></div><div class=\"mat-step-icon-state-{{state}} mat-step-icon\" [class.mat-step-icon-selected]=\"selected\"><div class=\"mat-step-icon-content\" [ngSwitch]=\"!!(iconOverrides && iconOverrides[state])\"><ng-container *ngSwitchCase=\"true\" [ngTemplateOutlet]=\"iconOverrides[state]\" [ngTemplateOutletContext]=\"_getIconContext()\"></ng-container><ng-container *ngSwitchDefault [ngSwitch]=\"state\"><span *ngSwitchCase=\"'number'\">{{_getDefaultTextForState(state)}}</span><mat-icon *ngSwitchDefault>{{_getDefaultTextForState(state)}}</mat-icon></ng-container></div></div><div class=\"mat-step-label\" [class.mat-step-label-active]=\"active\" [class.mat-step-label-selected]=\"selected\" [class.mat-step-label-error]=\"state == 'error'\"><ng-container *ngIf=\"_templateLabel()\" [ngTemplateOutlet]=\"_templateLabel()!.template\"></ng-container><div class=\"mat-step-text-label\" *ngIf=\"_stringLabel()\">{{label}}</div><div class=\"mat-step-optional\" *ngIf=\"optional && state != 'error'\">{{_intl.optionalLabel}}</div><div class=\"mat-step-sub-label-error\" *ngIf=\"state == 'error'\">{{errorMessage}}</div></div>",
                            styles: [".mat-step-header{overflow:hidden;outline:0;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:transparent}.mat-step-optional,.mat-step-sub-label-error{font-size:12px}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative}.mat-step-icon .mat-icon,.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}"],
                            host: {
                                'class': 'mat-step-header',
                                'role': 'tab',
                            },
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatStepHeader.ctorParameters = function () { return [
                { type: MatStepperIntl },
                { type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_3__["FocusMonitor"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] }
            ]; };
            MatStepHeader.propDecorators = {
                state: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                label: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                errorMessage: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                iconOverrides: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                index: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                selected: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                active: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                optional: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Animations used by the Material steppers.
             * \@docs-private
             * @type {?}
             */
            var matStepperAnimations = {
                /**
                 * Animation that transitions the step along the X axis in a horizontal stepper.
                 */
                horizontalStepTransition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('stepTransition', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('previous', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translate3d(-100%, 0, 0)', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'none', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ transform: 'translate3d(100%, 0, 0)', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* => *', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('500ms cubic-bezier(0.35, 0, 0.25, 1)'))
                ]),
                /**
                 * Animation that transitions the step along the Y axis in a vertical stepper.
                 */
                verticalStepTransition: Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["trigger"])('stepTransition', [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('previous', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('next', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '0px', visibility: 'hidden' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["state"])('current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["style"])({ height: '*', visibility: 'visible' })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["transition"])('* <=> current', Object(_angular_animations__WEBPACK_IMPORTED_MODULE_4__["animate"])('225ms cubic-bezier(0.4, 0.0, 0.2, 1)'))
                ])
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Template to be used to override the icons inside the step header.
             */
            var MatStepperIcon = /** @class */ (function () {
                /**
                 * @param {?} templateRef
                 */
                function MatStepperIcon(templateRef) {
                    this.templateRef = templateRef;
                }
                return MatStepperIcon;
            }());
            MatStepperIcon.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'ng-template[matStepperIcon]',
                        },] },
            ];
            /** @nocollapse */
            MatStepperIcon.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["TemplateRef"] }
            ]; };
            MatStepperIcon.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"], args: ['matStepperIcon',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStep = /** @class */ (function (_super) {
                __extends(MatStep, _super);
                /**
                 * \@breaking-change 8.0.0 remove the `?` after `stepperOptions`
                 * @param {?} stepper
                 * @param {?} _errorStateMatcher
                 * @param {?=} stepperOptions
                 */
                function MatStep(stepper, _errorStateMatcher, stepperOptions) {
                    var _this = _super.call(this, stepper, stepperOptions) || this;
                    _this._errorStateMatcher = _errorStateMatcher;
                    return _this;
                }
                /**
                 * Custom error state matcher that additionally checks for validity of interacted form.
                 * @param {?} control
                 * @param {?} form
                 * @return {?}
                 */
                MatStep.prototype.isErrorState = function (control, form) {
                    /** @type {?} */
                    var originalErrorState = this._errorStateMatcher.isErrorState(control, form);
                    // Custom error state checks for the validity of form that is not submitted or touched
                    // since user can trigger a form change by calling for another step without directly
                    // interacting with the current form.
                    /** @type {?} */
                    var customErrorState = !!(control && control.invalid && this.interacted);
                    return originalErrorState || customErrorState;
                };
                return MatStep;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStep"]));
            MatStep.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-step',
                            template: "<ng-template><ng-content></ng-content></ng-template>",
                            providers: [{ provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"], useExisting: MatStep }],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            exportAs: 'matStep',
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatStep.ctorParameters = function () { return [
                { type: MatStepper, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["forwardRef"])(( /**
                                                 * @return {?}
                                                 */function () { return MatStepper; })),] }] },
                { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"] }] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["STEPPER_GLOBAL_OPTIONS"],] }] }
            ]; };
            MatStep.propDecorators = {
                stepLabel: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChild"], args: [MatStepLabel, { static: false },] }]
            };
            var MatStepper = /** @class */ (function (_super) {
                __extends(MatStepper, _super);
                function MatStepper() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    /**
                     * Event emitted when the current step is done transitioning in.
                     */
                    _this.animationDone = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
                    /**
                     * Consumer-specified template-refs to be used to override the header icons.
                     */
                    _this._iconOverrides = {};
                    /**
                     * Stream of animation `done` events when the body expands/collapses.
                     */
                    _this._animationDone = new rxjs__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatStepper.prototype.ngAfterContentInit = function () {
                    var _this = this;
                    this._icons.forEach(( /**
                     * @param {?} __0
                     * @return {?}
                     */function (_a) {
                        var name = _a.name, templateRef = _a.templateRef;
                        return _this._iconOverrides[name] = templateRef;
                    }));
                    // Mark the component for change detection whenever the content children query changes
                    this._steps.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @return {?}
                     */function () { return _this._stateChanged(); }));
                    this._animationDone.pipe(
                    // This needs a `distinctUntilChanged` in order to avoid emitting the same event twice due
                    // to a bug in animations where the `.done` callback gets invoked twice on some browsers.
                    // See https://github.com/angular/angular/issues/24084
                    Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["distinctUntilChanged"])(( /**
                     * @param {?} x
                     * @param {?} y
                     * @return {?}
                     */function (x, y) { return x.fromState === y.fromState && x.toState === y.toState; })), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__["takeUntil"])(this._destroyed)).subscribe(( /**
                     * @param {?} event
                     * @return {?}
                     */function (/**
                     * @param {?} event
                     * @return {?}
                     */ event) {
                        if ((( /** @type {?} */(event.toState))) === 'current') {
                            _this.animationDone.emit();
                        }
                    }));
                };
                return MatStepper;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"]));
            MatStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{ selector: '[matStepper]', providers: [{ provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatStepper }] },] },
            ];
            MatStepper.propDecorators = {
                _stepHeader: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChildren"], args: [MatStepHeader,] }],
                _steps: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatStep,] }],
                _icons: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ContentChildren"], args: [MatStepperIcon,] }],
                animationDone: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"] }],
                disableRipple: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatHorizontalStepper = /** @class */ (function (_super) {
                __extends(MatHorizontalStepper, _super);
                function MatHorizontalStepper() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    /**
                     * Whether the label should display in bottom or end position.
                     */
                    _this.labelPosition = 'end';
                    return _this;
                }
                return MatHorizontalStepper;
            }(MatStepper));
            MatHorizontalStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-horizontal-stepper',
                            exportAs: 'matHorizontalStepper',
                            template: "<div class=\"mat-horizontal-stepper-header-container\"><ng-container *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-horizontal-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() === i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex == i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\" [disableRipple]=\"disableRipple\"></mat-step-header><div *ngIf=\"!isLast\" class=\"mat-stepper-horizontal-line\"></div></ng-container></div><div class=\"mat-horizontal-content-container\"><div *ngFor=\"let step of steps; let i = index\" [attr.tabindex]=\"selectedIndex === i ? 0 : null\" class=\"mat-horizontal-stepper-content\" role=\"tabpanel\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div>",
                            styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                            inputs: ['selectedIndex'],
                            host: {
                                'class': 'mat-stepper-horizontal',
                                '[class.mat-stepper-label-position-end]': 'labelPosition == "end"',
                                '[class.mat-stepper-label-position-bottom]': 'labelPosition == "bottom"',
                                'aria-orientation': 'horizontal',
                                'role': 'tablist',
                            },
                            animations: [matStepperAnimations.horizontalStepTransition],
                            providers: [
                                { provide: MatStepper, useExisting: MatHorizontalStepper },
                                { provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatHorizontalStepper }
                            ],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            MatHorizontalStepper.propDecorators = {
                labelPosition: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"] }]
            };
            var MatVerticalStepper = /** @class */ (function (_super) {
                __extends(MatVerticalStepper, _super);
                /**
                 * @param {?} dir
                 * @param {?} changeDetectorRef
                 * @param {?=} elementRef
                 * @param {?=} _document
                 */
                function MatVerticalStepper(dir, changeDetectorRef, 
                // @breaking-change 8.0.0 `elementRef` and `_document` parameters to become required.
                elementRef, _document) {
                    var _this = _super.call(this, dir, changeDetectorRef, elementRef, _document) || this;
                    _this._orientation = 'vertical';
                    return _this;
                }
                return MatVerticalStepper;
            }(MatStepper));
            MatVerticalStepper.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"], args: [{ selector: 'mat-vertical-stepper',
                            exportAs: 'matVerticalStepper',
                            template: "<div class=\"mat-step\" *ngFor=\"let step of steps; let i = index; let isLast = last\"><mat-step-header class=\"mat-vertical-stepper-header\" (click)=\"step.select()\" (keydown)=\"_onKeydown($event)\" [tabIndex]=\"_getFocusIndex() == i ? 0 : -1\" [id]=\"_getStepLabelId(i)\" [attr.aria-posinset]=\"i + 1\" [attr.aria-setsize]=\"steps.length\" [attr.aria-controls]=\"_getStepContentId(i)\" [attr.aria-selected]=\"selectedIndex === i\" [attr.aria-label]=\"step.ariaLabel || null\" [attr.aria-labelledby]=\"(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null\" [index]=\"i\" [state]=\"_getIndicatorType(i, step.state)\" [label]=\"step.stepLabel || step.label\" [selected]=\"selectedIndex === i\" [active]=\"step.completed || selectedIndex === i || !linear\" [optional]=\"step.optional\" [errorMessage]=\"step.errorMessage\" [iconOverrides]=\"_iconOverrides\" [disableRipple]=\"disableRipple\"></mat-step-header><div class=\"mat-vertical-content-container\" [class.mat-stepper-vertical-line]=\"!isLast\"><div class=\"mat-vertical-stepper-content\" role=\"tabpanel\" [attr.tabindex]=\"selectedIndex === i ? 0 : null\" [@stepTransition]=\"_getAnimationDirection(i)\" (@stepTransition.done)=\"_animationDone.next($event)\" [id]=\"_getStepContentId(i)\" [attr.aria-labelledby]=\"_getStepLabelId(i)\" [attr.aria-expanded]=\"selectedIndex === i\"><div class=\"mat-vertical-content\"><ng-container [ngTemplateOutlet]=\"step.content\"></ng-container></div></div></div></div>",
                            styles: [".mat-stepper-horizontal,.mat-stepper-vertical{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative;top:36px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{border-top-width:1px;border-top-style:solid;content:'';display:inline-block;height:0;position:absolute;top:36px;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto;padding:24px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;padding:24px;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:'';position:absolute;top:-16px;bottom:-16px;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}"],
                            inputs: ['selectedIndex'],
                            host: {
                                'class': 'mat-stepper-vertical',
                                'aria-orientation': 'vertical',
                                'role': 'tablist',
                            },
                            animations: [matStepperAnimations.verticalStepTransition],
                            providers: [
                                { provide: MatStepper, useExisting: MatVerticalStepper },
                                { provide: _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepper"], useExisting: MatVerticalStepper }
                            ],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewEncapsulation"].None,
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectionStrategy"].OnPush,
                        },] },
            ];
            /** @nocollapse */
            MatVerticalStepper.ctorParameters = function () { return [
                { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_5__["Directionality"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"] }] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__["DOCUMENT"],] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Button that moves to the next step in a stepper workflow.
             */
            var MatStepperNext = /** @class */ (function (_super) {
                __extends(MatStepperNext, _super);
                function MatStepperNext() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepperNext;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperNext"]));
            MatStepperNext.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[matStepperNext]',
                            host: {
                                '[type]': 'type',
                            },
                            inputs: ['type']
                        },] },
            ];
            /**
             * Button that moves to the previous step in a stepper workflow.
             */
            var MatStepperPrevious = /** @class */ (function (_super) {
                __extends(MatStepperPrevious, _super);
                function MatStepperPrevious() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatStepperPrevious;
            }(_angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperPrevious"]));
            MatStepperPrevious.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"], args: [{
                            selector: 'button[matStepperPrevious]',
                            host: {
                                '[type]': 'type',
                            },
                            inputs: ['type']
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatStepperModule = /** @class */ (function () {
                function MatStepperModule() {
                }
                return MatStepperModule;
            }());
            MatStepperModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"], args: [{
                            imports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_6__["CommonModule"],
                                _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_9__["PortalModule"],
                                _angular_material_button__WEBPACK_IMPORTED_MODULE_10__["MatButtonModule"],
                                _angular_cdk_stepper__WEBPACK_IMPORTED_MODULE_1__["CdkStepperModule"],
                                _angular_material_icon__WEBPACK_IMPORTED_MODULE_11__["MatIconModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatRippleModule"],
                            ],
                            exports: [
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["MatCommonModule"],
                                MatHorizontalStepper,
                                MatVerticalStepper,
                                MatStep,
                                MatStepLabel,
                                MatStepper,
                                MatStepperNext,
                                MatStepperPrevious,
                                MatStepHeader,
                                MatStepperIcon,
                            ],
                            declarations: [
                                MatHorizontalStepper,
                                MatVerticalStepper,
                                MatStep,
                                MatStepLabel,
                                MatStepper,
                                MatStepperNext,
                                MatStepperPrevious,
                                MatStepHeader,
                                MatStepperIcon,
                            ],
                            providers: [MAT_STEPPER_INTL_PROVIDER, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__["ErrorStateMatcher"]],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=stepper.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/table.js": 
        /*!*********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/table.js ***!
          \*********************************************************/
        /*! exports provided: MatTableModule, MatCellDef, MatHeaderCellDef, MatFooterCellDef, MatColumnDef, MatHeaderCell, MatFooterCell, MatCell, MatTable, MatHeaderRowDef, MatFooterRowDef, MatRowDef, MatHeaderRow, MatFooterRow, MatRow, MatTableDataSource, MatTextColumn */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTableModule", function () { return MatTableModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCellDef", function () { return MatCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderCellDef", function () { return MatHeaderCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterCellDef", function () { return MatFooterCellDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatColumnDef", function () { return MatColumnDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderCell", function () { return MatHeaderCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterCell", function () { return MatFooterCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatCell", function () { return MatCell; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTable", function () { return MatTable; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderRowDef", function () { return MatHeaderRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterRowDef", function () { return MatFooterRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRowDef", function () { return MatRowDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatHeaderRow", function () { return MatHeaderRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatFooterRow", function () { return MatFooterRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatRow", function () { return MatRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTableDataSource", function () { return MatTableDataSource; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTextColumn", function () { return MatTextColumn; });
            /* harmony import */ var _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/table */ "./node_modules/@angular/cdk/esm2015/table.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Wrapper for the CdkTable with Material design styles.
             * @template T
             */
            var MatTable = /** @class */ (function (_super) {
                __extends(MatTable, _super);
                function MatTable() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    /**
                     * Overrides the sticky CSS class set by the `CdkTable`.
                     */
                    _this.stickyCssClass = 'mat-table-sticky';
                    return _this;
                }
                return MatTable;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTable"]));
            MatTable.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-table, table[mat-table]',
                            exportAs: 'matTable',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_TABLE_TEMPLATE"],
                            styles: ["mat-table{display:block}mat-header-row{min-height:56px}mat-footer-row,mat-row{min-height:48px}mat-footer-row,mat-header-row,mat-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-footer-row::after,mat-header-row::after,mat-row::after{display:inline-block;min-height:inherit;content:''}mat-cell:first-of-type,mat-footer-cell:first-of-type,mat-header-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type,[dir=rtl] mat-footer-cell:first-of-type,[dir=rtl] mat-header-cell:first-of-type{padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-footer-cell:last-of-type,mat-header-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type,[dir=rtl] mat-footer-cell:last-of-type,[dir=rtl] mat-header-cell:last-of-type{padding-right:0;padding-left:24px}mat-cell,mat-footer-cell,mat-header-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-footer-row,tr.mat-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}td.mat-cell,td.mat-footer-cell,th.mat-header-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type,th.mat-header-cell:first-of-type{padding-left:24px}[dir=rtl] td.mat-cell:first-of-type,[dir=rtl] td.mat-footer-cell:first-of-type,[dir=rtl] th.mat-header-cell:first-of-type{padding-left:0;padding-right:24px}td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type,th.mat-header-cell:last-of-type{padding-right:24px}[dir=rtl] td.mat-cell:last-of-type,[dir=rtl] td.mat-footer-cell:last-of-type,[dir=rtl] th.mat-header-cell:last-of-type{padding-right:0;padding-left:24px}"],
                            host: {
                                'class': 'mat-table',
                            },
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTable"], useExisting: MatTable }],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Cell definition for the mat-table.
             * Captures the template of a column's data row cell as well as cell-specific properties.
             */
            var MatCellDef = /** @class */ (function (_super) {
                __extends(MatCellDef, _super);
                function MatCellDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatCellDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkCellDef"]));
            MatCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matCellDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkCellDef"], useExisting: MatCellDef }]
                        },] },
            ];
            /**
             * Header cell definition for the mat-table.
             * Captures the template of a column's header cell and as well as cell-specific properties.
             */
            var MatHeaderCellDef = /** @class */ (function (_super) {
                __extends(MatHeaderCellDef, _super);
                function MatHeaderCellDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatHeaderCellDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderCellDef"]));
            MatHeaderCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matHeaderCellDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderCellDef"], useExisting: MatHeaderCellDef }]
                        },] },
            ];
            /**
             * Footer cell definition for the mat-table.
             * Captures the template of a column's footer cell and as well as cell-specific properties.
             */
            var MatFooterCellDef = /** @class */ (function (_super) {
                __extends(MatFooterCellDef, _super);
                function MatFooterCellDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatFooterCellDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterCellDef"]));
            MatFooterCellDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matFooterCellDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterCellDef"], useExisting: MatFooterCellDef }]
                        },] },
            ];
            /**
             * Column definition for the mat-table.
             * Defines a set of cells available for a table column.
             */
            var MatColumnDef = /** @class */ (function (_super) {
                __extends(MatColumnDef, _super);
                function MatColumnDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatColumnDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"]));
            MatColumnDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matColumnDef]',
                            providers: [
                                { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"], useExisting: MatColumnDef },
                                { provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: MatColumnDef }
                            ],
                        },] },
            ];
            MatColumnDef.propDecorators = {
                name: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matColumnDef',] }],
                sticky: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                stickyEnd: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * Header cell template container that adds the right classes and role.
             */
            var MatHeaderCell = /** @class */ (function (_super) {
                __extends(MatHeaderCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function MatHeaderCell(columnDef, elementRef) {
                    var _this = _super.call(this, columnDef, elementRef) || this;
                    elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
                    return _this;
                }
                return MatHeaderCell;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderCell"]));
            MatHeaderCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-header-cell, th[mat-header-cell]',
                            host: {
                                'class': 'mat-header-cell',
                                'role': 'columnheader',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatHeaderCell.ctorParameters = function () { return [
                { type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Footer cell template container that adds the right classes and role.
             */
            var MatFooterCell = /** @class */ (function (_super) {
                __extends(MatFooterCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function MatFooterCell(columnDef, elementRef) {
                    var _this = _super.call(this, columnDef, elementRef) || this;
                    elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
                    return _this;
                }
                return MatFooterCell;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterCell"]));
            MatFooterCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-footer-cell, td[mat-footer-cell]',
                            host: {
                                'class': 'mat-footer-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatFooterCell.ctorParameters = function () { return [
                { type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * Cell template container that adds the right classes and role.
             */
            var MatCell = /** @class */ (function (_super) {
                __extends(MatCell, _super);
                /**
                 * @param {?} columnDef
                 * @param {?} elementRef
                 */
                function MatCell(columnDef, elementRef) {
                    var _this = _super.call(this, columnDef, elementRef) || this;
                    elementRef.nativeElement.classList.add("mat-column-" + columnDef.cssClassFriendlyName);
                    return _this;
                }
                return MatCell;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkCell"]));
            MatCell.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-cell, td[mat-cell]',
                            host: {
                                'class': 'mat-cell',
                                'role': 'gridcell',
                            },
                        },] },
            ];
            /** @nocollapse */
            MatCell.ctorParameters = function () { return [
                { type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkColumnDef"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Header row definition for the mat-table.
             * Captures the header row's template and other header properties such as the columns to display.
             */
            var MatHeaderRowDef = /** @class */ (function (_super) {
                __extends(MatHeaderRowDef, _super);
                function MatHeaderRowDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatHeaderRowDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRowDef"]));
            MatHeaderRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matHeaderRowDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRowDef"], useExisting: MatHeaderRowDef }],
                            inputs: ['columns: matHeaderRowDef', 'sticky: matHeaderRowDefSticky'],
                        },] },
            ];
            /**
             * Footer row definition for the mat-table.
             * Captures the footer row's template and other footer properties such as the columns to display.
             */
            var MatFooterRowDef = /** @class */ (function (_super) {
                __extends(MatFooterRowDef, _super);
                function MatFooterRowDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatFooterRowDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRowDef"]));
            MatFooterRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matFooterRowDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRowDef"], useExisting: MatFooterRowDef }],
                            inputs: ['columns: matFooterRowDef', 'sticky: matFooterRowDefSticky'],
                        },] },
            ];
            /**
             * Data row definition for the mat-table.
             * Captures the data row's template and other properties such as the columns to display and
             * a when predicate that describes when this row should be used.
             * @template T
             */
            var MatRowDef = /** @class */ (function (_super) {
                __extends(MatRowDef, _super);
                function MatRowDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatRowDef;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRowDef"]));
            MatRowDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matRowDef]',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRowDef"], useExisting: MatRowDef }],
                            inputs: ['columns: matRowDefColumns', 'when: matRowDefWhen'],
                        },] },
            ];
            /**
             * Footer template container that contains the cell outlet. Adds the right class and role.
             */
            var MatHeaderRow = /** @class */ (function (_super) {
                __extends(MatHeaderRow, _super);
                function MatHeaderRow() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatHeaderRow;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRow"]));
            MatHeaderRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-header-row, tr[mat-header-row]',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_ROW_TEMPLATE"],
                            host: {
                                'class': 'mat-header-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            exportAs: 'matHeaderRow',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkHeaderRow"], useExisting: MatHeaderRow }],
                        },] },
            ];
            /**
             * Footer template container that contains the cell outlet. Adds the right class and role.
             */
            var MatFooterRow = /** @class */ (function (_super) {
                __extends(MatFooterRow, _super);
                function MatFooterRow() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatFooterRow;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRow"]));
            MatFooterRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-footer-row, tr[mat-footer-row]',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_ROW_TEMPLATE"],
                            host: {
                                'class': 'mat-footer-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            exportAs: 'matFooterRow',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkFooterRow"], useExisting: MatFooterRow }],
                        },] },
            ];
            /**
             * Data row template container that contains the cell outlet. Adds the right class and role.
             */
            var MatRow = /** @class */ (function (_super) {
                __extends(MatRow, _super);
                function MatRow() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatRow;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRow"]));
            MatRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-row, tr[mat-row]',
                            template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CDK_ROW_TEMPLATE"],
                            host: {
                                'class': 'mat-row',
                                'role': 'row',
                            },
                            // See note on CdkTable for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            exportAs: 'matRow',
                            providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkRow"], useExisting: MatRow }],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Column that simply shows text content for the header and row cells. Assumes that the table
             * is using the native table implementation (`<table>`).
             *
             * By default, the name of this column will be the header text and data property accessor.
             * The header text can be overridden with the `headerText` input. Cell values can be overridden with
             * the `dataAccessor` input. Change the text justification to the start or end using the `justify`
             * input.
             * @template T
             */
            var MatTextColumn = /** @class */ (function (_super) {
                __extends(MatTextColumn, _super);
                function MatTextColumn() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatTextColumn;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTextColumn"]));
            MatTextColumn.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-text-column',
                            template: "\n    <ng-container matColumnDef>\n      <th mat-header-cell *matHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td mat-cell *matCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  ",
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // Change detection is intentionally not set to OnPush. This component's template will be provided
                            // to the table to be inserted into its view. This is problematic when change detection runs since
                            // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
                            // mean's the template in the table's view will not have the updated value (and in fact will cause
                            // an ExpressionChangedAfterItHasBeenCheckedError).
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var EXPORTED_DECLARATIONS = [
                // Table
                MatTable,
                // Template defs
                MatHeaderCellDef,
                MatHeaderRowDef,
                MatColumnDef,
                MatCellDef,
                MatRowDef,
                MatFooterCellDef,
                MatFooterRowDef,
                // Cell directives
                MatHeaderCell,
                MatCell,
                MatFooterCell,
                // Row directives
                MatHeaderRow,
                MatRow,
                MatFooterRow,
                MatTextColumn,
            ];
            var MatTableModule = /** @class */ (function () {
                function MatTableModule() {
                }
                return MatTableModule;
            }());
            MatTableModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [
                                _angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["CdkTableModule"],
                                _angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"],
                                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"],
                            ],
                            exports: EXPORTED_DECLARATIONS,
                            declarations: EXPORTED_DECLARATIONS,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to
             * flaky browser support and the value not being defined in Closure's typings.
             * @type {?}
             */
            var MAX_SAFE_INTEGER = 9007199254740991;
            /**
             * Data source that accepts a client-side data array and includes native support of filtering,
             * sorting (using MatSort), and pagination (using MatPaginator).
             *
             * Allows for sort customization by overriding sortingDataAccessor, which defines how data
             * properties are accessed. Also allows for filter customization by overriding filterTermAccessor,
             * which defines how row data is converted to a string for filter matching.
             *
             * **Note:** This class is meant to be a simple data source to help you get started. As such
             * it isn't equipped to handle some more advanced cases like robust i18n support or server-side
             * interactions. If your app needs to support more advanced use cases, consider implementing your
             * own `DataSource`.
             * @template T
             */
            var MatTableDataSource = /** @class */ (function (_super) {
                __extends(MatTableDataSource, _super);
                /**
                 * @param {?=} initialData
                 */
                function MatTableDataSource(initialData) {
                    if (initialData === void 0) { initialData = []; }
                    var _this = _super.call(this) || this;
                    /**
                     * Stream emitting render data to the table (depends on ordered data changes).
                     */
                    _this._renderData = new rxjs__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"]([]);
                    /**
                     * Stream that emits when a new filter string is set on the data source.
                     */
                    _this._filter = new rxjs__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"]('');
                    /**
                     * Used to react to internal changes of the paginator that are made by the data source itself.
                     */
                    _this._internalPageChanges = new rxjs__WEBPACK_IMPORTED_MODULE_5__["Subject"]();
                    /**
                     * Subscription to the changes that should trigger an update to the table's rendered rows, such
                     * as filtering, sorting, pagination, or base data changes.
                     */
                    _this._renderChangesSubscription = rxjs__WEBPACK_IMPORTED_MODULE_5__["Subscription"].EMPTY;
                    /**
                     * Data accessor function that is used for accessing data properties for sorting through
                     * the default sortData function.
                     * This default function assumes that the sort header IDs (which defaults to the column name)
                     * matches the data's properties (e.g. column Xyz represents data['Xyz']).
                     * May be set to a custom function for different behavior.
                     * @param data Data object that is being accessed.
                     * @param sortHeaderId The name of the column that represents the data.
                     */
                    _this.sortingDataAccessor = ( /**
                     * @param {?} data
                     * @param {?} sortHeaderId
                     * @return {?}
                     */function (data, sortHeaderId) {
                        /** @type {?} */
                        var value = (( /** @type {?} */(data)))[sortHeaderId];
                        if (Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__["_isNumberValue"])(value)) {
                            /** @type {?} */
                            var numberValue = Number(value);
                            // Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we
                            // leave them as strings. For more info: https://goo.gl/y5vbSg
                            return numberValue < MAX_SAFE_INTEGER ? numberValue : value;
                        }
                        return value;
                    });
                    /**
                     * Gets a sorted copy of the data array based on the state of the MatSort. Called
                     * after changes are made to the filtered data or when sort changes are emitted from MatSort.
                     * By default, the function retrieves the active sort and its direction and compares data
                     * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation
                     * of data ordering.
                     * @param data The array of data that should be sorted.
                     * @param sort The connected MatSort that holds the current sort state.
                     */
                    _this.sortData = ( /**
                     * @param {?} data
                     * @param {?} sort
                     * @return {?}
                     */function (data, sort) {
                        /** @type {?} */
                        var active = sort.active;
                        /** @type {?} */
                        var direction = sort.direction;
                        if (!active || direction == '') {
                            return data;
                        }
                        return data.sort(( /**
                         * @param {?} a
                         * @param {?} b
                         * @return {?}
                         */function (a, b) {
                            /** @type {?} */
                            var valueA = _this.sortingDataAccessor(a, active);
                            /** @type {?} */
                            var valueB = _this.sortingDataAccessor(b, active);
                            // If both valueA and valueB exist (truthy), then compare the two. Otherwise, check if
                            // one value exists while the other doesn't. In this case, existing value should come last.
                            // This avoids inconsistent results when comparing values to undefined/null.
                            // If neither value exists, return 0 (equal).
                            /** @type {?} */
                            var comparatorResult = 0;
                            if (valueA != null && valueB != null) {
                                // Check if one value is greater than the other; if equal, comparatorResult should remain 0.
                                if (valueA > valueB) {
                                    comparatorResult = 1;
                                }
                                else if (valueA < valueB) {
                                    comparatorResult = -1;
                                }
                            }
                            else if (valueA != null) {
                                comparatorResult = 1;
                            }
                            else if (valueB != null) {
                                comparatorResult = -1;
                            }
                            return comparatorResult * (direction == 'asc' ? 1 : -1);
                        }));
                    });
                    /**
                     * Checks if a data object matches the data source's filter string. By default, each data object
                     * is converted to a string of its properties and returns true if the filter has
                     * at least one occurrence in that string. By default, the filter string has its whitespace
                     * trimmed and the match is case-insensitive. May be overridden for a custom implementation of
                     * filter matching.
                     * @param data Data object used to check against the filter.
                     * @param filter Filter string that has been set on the data source.
                     * @return Whether the filter matches against the data
                     */
                    _this.filterPredicate = ( /**
                     * @param {?} data
                     * @param {?} filter
                     * @return {?}
                     */function (data, filter) {
                        // Transform the data into a lowercase string of all property values.
                        /** @type {?} */
                        var dataStr = Object.keys(data).reduce(( /**
                         * @param {?} currentTerm
                         * @param {?} key
                         * @return {?}
                         */function (currentTerm, key) {
                            // Use an obscure Unicode character to delimit the words in the concatenated string.
                            // This avoids matches where the values of two columns combined will match the user's query
                            // (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something
                            // that has a very low chance of being typed in by somebody in a text field. This one in
                            // particular is "White up-pointing triangle with dot" from
                            // https://en.wikipedia.org/wiki/List_of_Unicode_characters
                            return currentTerm + (( /** @type {?} */(data)))[key] + '◬';
                        }), '').toLowerCase();
                        // Transform the filter by converting it to lowercase and removing whitespace.
                        /** @type {?} */
                        var transformedFilter = filter.trim().toLowerCase();
                        return dataStr.indexOf(transformedFilter) != -1;
                    });
                    _this._data = new rxjs__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"](initialData);
                    _this._updateChangeSubscription();
                    return _this;
                }
                Object.defineProperty(MatTableDataSource.prototype, "data", {
                    /**
                     * Array of data that should be rendered by the table, where each object represents one row.
                     * @return {?}
                     */
                    get: function () { return this._data.value; },
                    /**
                     * @param {?} data
                     * @return {?}
                     */
                    set: function (data) { this._data.next(data); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTableDataSource.prototype, "filter", {
                    /**
                     * Filter term that should be used to filter out objects from the data array. To override how
                     * data objects match to this filter string, provide a custom function for filterPredicate.
                     * @return {?}
                     */
                    get: function () { return this._filter.value; },
                    /**
                     * @param {?} filter
                     * @return {?}
                     */
                    set: function (filter) { this._filter.next(filter); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTableDataSource.prototype, "sort", {
                    /**
                     * Instance of the MatSort directive used by the table to control its sorting. Sort changes
                     * emitted by the MatSort will trigger an update to the table's rendered data.
                     * @return {?}
                     */
                    get: function () { return this._sort; },
                    /**
                     * @param {?} sort
                     * @return {?}
                     */
                    set: function (sort) {
                        this._sort = sort;
                        this._updateChangeSubscription();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatTableDataSource.prototype, "paginator", {
                    /**
                     * Instance of the MatPaginator component used by the table to control what page of the data is
                     * displayed. Page changes emitted by the MatPaginator will trigger an update to the
                     * table's rendered data.
                     *
                     * Note that the data source uses the paginator's properties to calculate which page of data
                     * should be displayed. If the paginator receives its properties as template inputs,
                     * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
                     * initialized before assigning it to this data source.
                     * @return {?}
                     */
                    get: function () { return this._paginator; },
                    /**
                     * @param {?} paginator
                     * @return {?}
                     */
                    set: function (paginator) {
                        this._paginator = paginator;
                        this._updateChangeSubscription();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Subscribe to changes that should trigger an update to the table's rendered rows. When the
                 * changes occur, process the current state of the filter, sort, and pagination along with
                 * the provided base data and send it to the table for rendering.
                 * @return {?}
                 */
                MatTableDataSource.prototype._updateChangeSubscription = function () {
                    var _this = this;
                    // Sorting and/or pagination should be watched if MatSort and/or MatPaginator are provided.
                    // The events should emit whenever the component emits a change or initializes, or if no
                    // component is provided, a stream with just a null event should be provided.
                    // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the
                    // pipeline can progress to the next step. Note that the value from these streams are not used,
                    // they purely act as a signal to progress in the pipeline.
                    /** @type {?} */
                    var sortChange = this._sort ?
                        ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"])(this._sort.sortChange, this._sort.initialized))) :
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["of"])(null);
                    /** @type {?} */
                    var pageChange = this._paginator ?
                        ( /** @type {?} */(Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["merge"])(this._paginator.page, this._internalPageChanges, this._paginator.initialized))) :
                        Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["of"])(null);
                    /** @type {?} */
                    var dataStream = this._data;
                    // Watch for base data or filter changes to provide a filtered set of data.
                    /** @type {?} */
                    var filteredData = Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["combineLatest"])([dataStream, this._filter])
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(( /**
                 * @param {?} __0
                 * @return {?}
                 */function (_a) {
                        var _b = __read(_a, 1), data = _b[0];
                        return _this._filterData(data);
                    })));
                    // Watch for filtered data or sort changes to provide an ordered set of data.
                    /** @type {?} */
                    var orderedData = Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["combineLatest"])([filteredData, sortChange])
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(( /**
                 * @param {?} __0
                 * @return {?}
                 */function (_a) {
                        var _b = __read(_a, 1), data = _b[0];
                        return _this._orderData(data);
                    })));
                    // Watch for ordered data or page changes to provide a paged set of data.
                    /** @type {?} */
                    var paginatedData = Object(rxjs__WEBPACK_IMPORTED_MODULE_5__["combineLatest"])([orderedData, pageChange])
                        .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__["map"])(( /**
                 * @param {?} __0
                 * @return {?}
                 */function (_a) {
                        var _b = __read(_a, 1), data = _b[0];
                        return _this._pageData(data);
                    })));
                    // Watched for paged data changes and send the result to the table to render.
                    this._renderChangesSubscription.unsubscribe();
                    this._renderChangesSubscription = paginatedData.subscribe(( /**
                     * @param {?} data
                     * @return {?}
                     */function (/**
                     * @param {?} data
                     * @return {?}
                     */ data) { return _this._renderData.next(data); }));
                };
                /**
                 * Returns a filtered data array where each filter object contains the filter string within
                 * the result of the filterTermAccessor function. If no filter is set, returns the data array
                 * as provided.
                 * @param {?} data
                 * @return {?}
                 */
                MatTableDataSource.prototype._filterData = function (data) {
                    var _this = this;
                    // If there is a filter string, filter out data that does not contain it.
                    // Each data object is converted to a string using the function defined by filterTermAccessor.
                    // May be overridden for customization.
                    this.filteredData =
                        !this.filter ? data : data.filter(( /**
                         * @param {?} obj
                         * @return {?}
                         */function (/**
                         * @param {?} obj
                         * @return {?}
                         */ obj) { return _this.filterPredicate(obj, _this.filter); }));
                    if (this.paginator) {
                        this._updatePaginator(this.filteredData.length);
                    }
                    return this.filteredData;
                };
                /**
                 * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the
                 * data array as provided. Uses the default data accessor for data lookup, unless a
                 * sortDataAccessor function is defined.
                 * @param {?} data
                 * @return {?}
                 */
                MatTableDataSource.prototype._orderData = function (data) {
                    // If there is no active sort or direction, return the data without trying to sort.
                    if (!this.sort) {
                        return data;
                    }
                    return this.sortData(data.slice(), this.sort);
                };
                /**
                 * Returns a paged slice of the provided data array according to the provided MatPaginator's page
                 * index and length. If there is no paginator provided, returns the data array as provided.
                 * @param {?} data
                 * @return {?}
                 */
                MatTableDataSource.prototype._pageData = function (data) {
                    if (!this.paginator) {
                        return data;
                    }
                    /** @type {?} */
                    var startIndex = this.paginator.pageIndex * this.paginator.pageSize;
                    return data.slice(startIndex, startIndex + this.paginator.pageSize);
                };
                /**
                 * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
                 * index does not exceed the paginator's last page. Values are changed in a resolved promise to
                 * guard against making property changes within a round of change detection.
                 * @param {?} filteredDataLength
                 * @return {?}
                 */
                MatTableDataSource.prototype._updatePaginator = function (filteredDataLength) {
                    var _this = this;
                    Promise.resolve().then(( /**
                     * @return {?}
                     */function () {
                        /** @type {?} */
                        var paginator = _this.paginator;
                        if (!paginator) {
                            return;
                        }
                        paginator.length = filteredDataLength;
                        // If the page index is set beyond the page, reduce it to the last page.
                        if (paginator.pageIndex > 0) {
                            /** @type {?} */
                            var lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;
                            /** @type {?} */
                            var newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);
                            if (newPageIndex !== paginator.pageIndex) {
                                paginator.pageIndex = newPageIndex;
                                // Since the paginator only emits after user-generated changes,
                                // we need our own stream so we know to should re-render the data.
                                _this._internalPageChanges.next();
                            }
                        }
                    }));
                };
                /**
                 * Used by the MatTable. Called when it connects to the data source.
                 * \@docs-private
                 * @return {?}
                 */
                MatTableDataSource.prototype.connect = function () { return this._renderData; };
                /**
                 * Used by the MatTable. Called when it is destroyed. No-op.
                 * \@docs-private
                 * @return {?}
                 */
                MatTableDataSource.prototype.disconnect = function () { };
                return MatTableDataSource;
            }(_angular_cdk_table__WEBPACK_IMPORTED_MODULE_0__["DataSource"]));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=table.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/toolbar.js": 
        /*!***********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/toolbar.js ***!
          \***********************************************************/
        /*! exports provided: MatToolbarModule, throwToolbarMixedModesError, MatToolbarRow, MatToolbar */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatToolbarModule", function () { return MatToolbarModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwToolbarMixedModesError", function () { return throwToolbarMixedModesError; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatToolbarRow", function () { return MatToolbarRow; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatToolbar", function () { return MatToolbar; });
            /* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/platform */ "./node_modules/@angular/cdk/esm2015/platform.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            // Boilerplate for applying mixins to MatToolbar.
            /**
             * \@docs-private
             */
            var MatToolbarBase = /** @class */ (function () {
                /**
                 * @param {?} _elementRef
                 */
                function MatToolbarBase(_elementRef) {
                    this._elementRef = _elementRef;
                }
                return MatToolbarBase;
            }());
            /** @type {?} */
            var _MatToolbarMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["mixinColor"])(MatToolbarBase);
            var MatToolbarRow = /** @class */ (function () {
                function MatToolbarRow() {
                }
                return MatToolbarRow;
            }());
            MatToolbarRow.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Directive"], args: [{
                            selector: 'mat-toolbar-row',
                            exportAs: 'matToolbarRow',
                            host: { 'class': 'mat-toolbar-row' },
                        },] },
            ];
            var MatToolbar = /** @class */ (function (_super) {
                __extends(MatToolbar, _super);
                /**
                 * @param {?} elementRef
                 * @param {?} _platform
                 * @param {?=} document
                 */
                function MatToolbar(elementRef, _platform, document) {
                    var _this = _super.call(this, elementRef) || this;
                    _this._platform = _platform;
                    // TODO: make the document a required param when doing breaking changes.
                    _this._document = document;
                    return _this;
                }
                /**
                 * @return {?}
                 */
                MatToolbar.prototype.ngAfterViewInit = function () {
                    var _this = this;
                    if (!Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["isDevMode"])() || !this._platform.isBrowser) {
                        return;
                    }
                    this._checkToolbarMixedModes();
                    this._toolbarRows.changes.subscribe(( /**
                     * @return {?}
                     */function () { return _this._checkToolbarMixedModes(); }));
                };
                /**
                 * Throws an exception when developers are attempting to combine the different toolbar row modes.
                 * @private
                 * @return {?}
                 */
                MatToolbar.prototype._checkToolbarMixedModes = function () {
                    var _this = this;
                    if (!this._toolbarRows.length) {
                        return;
                    }
                    // Check if there are any other DOM nodes that can display content but aren't inside of
                    // a <mat-toolbar-row> element.
                    /** @type {?} */
                    var isCombinedUsage = Array.from(this._elementRef.nativeElement.childNodes)
                        .filter(( /**
                 * @param {?} node
                 * @return {?}
                 */function (/**
                 * @param {?} node
                 * @return {?}
                 */ node) { return !(node.classList && node.classList.contains('mat-toolbar-row')); }))
                        .filter(( /**
                 * @param {?} node
                 * @return {?}
                 */function (/**
                 * @param {?} node
                 * @return {?}
                 */ node) { return node.nodeType !== (_this._document ? _this._document.COMMENT_NODE : 8); }))
                        .some(( /**
                 * @param {?} node
                 * @return {?}
                 */function (/**
                 * @param {?} node
                 * @return {?}
                 */ node) { return !!(node.textContent && node.textContent.trim()); }));
                    if (isCombinedUsage) {
                        throwToolbarMixedModesError();
                    }
                };
                return MatToolbar;
            }(_MatToolbarMixinBase));
            MatToolbar.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"], args: [{ selector: 'mat-toolbar',
                            exportAs: 'matToolbar',
                            template: "<ng-content></ng-content><ng-content select=\"mat-toolbar-row\"></ng-content>",
                            styles: ["@media (-ms-high-contrast:active){.mat-toolbar{outline:solid 1px}}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media (max-width:599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}"],
                            inputs: ['color'],
                            host: {
                                'class': 'mat-toolbar',
                                '[class.mat-toolbar-multiple-rows]': '_toolbarRows.length > 0',
                                '[class.mat-toolbar-single-row]': '_toolbarRows.length === 0',
                            },
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ChangeDetectionStrategy"].OnPush,
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ViewEncapsulation"].None,
                        },] },
            ];
            /** @nocollapse */
            MatToolbar.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"] },
                { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__["Platform"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Inject"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["DOCUMENT"],] }] }
            ]; };
            MatToolbar.propDecorators = {
                _toolbarRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ContentChildren"], args: [MatToolbarRow,] }]
            };
            /**
             * Throws an exception when attempting to combine the different toolbar row modes.
             * \@docs-private
             * @return {?}
             */
            function throwToolbarMixedModesError() {
                throw Error('MatToolbar: Attempting to combine different toolbar modes. ' +
                    'Either specify multiple `<mat-toolbar-row>` elements explicitly or just place content ' +
                    'inside of a `<mat-toolbar>` for a single row.');
            }
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            var MatToolbarModule = /** @class */ (function () {
                function MatToolbarModule() {
                }
                return MatToolbarModule;
            }());
            MatToolbarModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"], args: [{
                            imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]],
                            exports: [MatToolbar, MatToolbarRow, _angular_material_core__WEBPACK_IMPORTED_MODULE_3__["MatCommonModule"]],
                            declarations: [MatToolbar, MatToolbarRow],
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=toolbar.js.map
            /***/ 
        }),
        /***/ "./node_modules/@angular/material/esm2015/tree.js": 
        /*!********************************************************!*\
          !*** ./node_modules/@angular/material/esm2015/tree.js ***!
          \********************************************************/
        /*! exports provided: MatTreeNode, MatTreeNodeDef, MatNestedTreeNode, MatTreeNodePadding, MatTree, MatTreeModule, MatTreeNodeToggle, MatTreeNodeOutlet, MatTreeFlattener, MatTreeFlatDataSource, MatTreeNestedDataSource */
        /***/ (function (module, __webpack_exports__, __webpack_require__) {
            "use strict";
            __webpack_require__.r(__webpack_exports__);
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeNode", function () { return MatTreeNode; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodeDef", function () { return MatTreeNodeDef; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatNestedTreeNode", function () { return MatNestedTreeNode; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodePadding", function () { return MatTreeNodePadding; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTree", function () { return MatTree; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeModule", function () { return MatTreeModule; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodeToggle", function () { return MatTreeNodeToggle; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeNodeOutlet", function () { return MatTreeNodeOutlet; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeFlattener", function () { return MatTreeFlattener; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeFlatDataSource", function () { return MatTreeFlatDataSource; });
            /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatTreeNestedDataSource", function () { return MatTreeNestedDataSource; });
            /* harmony import */ var _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/tree */ "./node_modules/@angular/cdk/esm2015/tree.js");
            /* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm2015/core.js");
            /* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/material/core */ "./node_modules/@angular/material/esm2015/core.js");
            /* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ "./node_modules/@angular/cdk/esm2015/coercion.js");
            /* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm2015/common.js");
            /* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/collections */ "./node_modules/@angular/cdk/esm2015/collections.js");
            /* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm2015/index.js");
            /* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm2015/operators/index.js");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var _MatTreeNodeMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinTabIndex"])(Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_2__["mixinDisabled"])(_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNode"]));
            /**
             * Wrapper for the CdkTree node with Material design styles.
             * @template T
             */
            var MatTreeNode = /** @class */ (function (_super) {
                __extends(MatTreeNode, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _tree
                 * @param {?} tabIndex
                 */
                function MatTreeNode(_elementRef, _tree, tabIndex) {
                    var _this = _super.call(this, _elementRef, _tree) || this;
                    _this._elementRef = _elementRef;
                    _this._tree = _tree;
                    _this.role = 'treeitem';
                    _this.tabIndex = Number(tabIndex) || 0;
                    return _this;
                }
                return MatTreeNode;
            }(_MatTreeNodeMixinBase));
            MatTreeNode.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-tree-node',
                            exportAs: 'matTreeNode',
                            inputs: ['disabled', 'tabIndex'],
                            host: {
                                '[attr.aria-expanded]': 'isExpanded',
                                '[attr.aria-level]': 'role === "treeitem" ? level : null',
                                '[attr.role]': 'role',
                                'class': 'mat-tree-node'
                            },
                            providers: [{ provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNode"], useExisting: MatTreeNode }]
                        },] },
            ];
            /** @nocollapse */
            MatTreeNode.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTree"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"], args: ['tabindex',] }] }
            ]; };
            MatTreeNode.propDecorators = {
                role: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * Wrapper for the CdkTree node definition with Material design styles.
             * @template T
             */
            var MatTreeNodeDef = /** @class */ (function (_super) {
                __extends(MatTreeNodeDef, _super);
                function MatTreeNodeDef() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatTreeNodeDef;
            }(_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNodeDef"]));
            MatTreeNodeDef.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matTreeNodeDef]',
                            inputs: [
                                'when: matTreeNodeDefWhen'
                            ],
                            providers: [{ provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNodeDef"], useExisting: MatTreeNodeDef }]
                        },] },
            ];
            MatTreeNodeDef.propDecorators = {
                data: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matTreeNode',] }]
            };
            /**
             * Wrapper for the CdkTree nested node with Material design styles.
             * @template T
             */
            var MatNestedTreeNode = /** @class */ (function (_super) {
                __extends(MatNestedTreeNode, _super);
                /**
                 * @param {?} _elementRef
                 * @param {?} _tree
                 * @param {?} _differs
                 * @param {?} tabIndex
                 */
                function MatNestedTreeNode(_elementRef, _tree, _differs, tabIndex) {
                    var _this = _super.call(this, _elementRef, _tree, _differs) || this;
                    _this._elementRef = _elementRef;
                    _this._tree = _tree;
                    _this._differs = _differs;
                    _this._disabled = false;
                    _this.tabIndex = Number(tabIndex) || 0;
                    return _this;
                }
                Object.defineProperty(MatNestedTreeNode.prototype, "disabled", {
                    /**
                     * Whether the node is disabled.
                     * @return {?}
                     */
                    get: function () { return this._disabled; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__["coerceBooleanProperty"])(value); },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(MatNestedTreeNode.prototype, "tabIndex", {
                    /**
                     * Tabindex for the node.
                     * @return {?}
                     */
                    get: function () { return this.disabled ? -1 : this._tabIndex; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        // If the specified tabIndex value is null or undefined, fall back to the default value.
                        this._tabIndex = value != null ? value : 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                // This is a workaround for https://github.com/angular/angular/issues/23091
                // In aot mode, the lifecycle hooks from parent class are not called.
                // TODO(tinayuangao): Remove when the angular issue #23091 is fixed
                /**
                 * @return {?}
                 */
                MatNestedTreeNode.prototype.ngAfterContentInit = function () {
                    _super.prototype.ngAfterContentInit.call(this);
                };
                /**
                 * @return {?}
                 */
                MatNestedTreeNode.prototype.ngOnDestroy = function () {
                    _super.prototype.ngOnDestroy.call(this);
                };
                return MatNestedTreeNode;
            }(_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkNestedTreeNode"]));
            MatNestedTreeNode.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: 'mat-nested-tree-node',
                            exportAs: 'matNestedTreeNode',
                            host: {
                                '[attr.aria-expanded]': 'isExpanded',
                                '[attr.role]': 'role',
                                'class': 'mat-nested-tree-node',
                            },
                            providers: [
                                { provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkNestedTreeNode"], useExisting: MatNestedTreeNode },
                                { provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNode"], useExisting: MatNestedTreeNode },
                                { provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CDK_TREE_NODE_OUTLET_NODE"], useExisting: MatNestedTreeNode }
                            ]
                        },] },
            ];
            /** @nocollapse */
            MatNestedTreeNode.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
                { type: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTree"] },
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["IterableDiffers"] },
                { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Attribute"], args: ['tabindex',] }] }
            ]; };
            MatNestedTreeNode.propDecorators = {
                node: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matNestedTreeNode',] }],
                disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }],
                tabIndex: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Wrapper for the CdkTree padding with Material design styles.
             * @template T
             */
            var MatTreeNodePadding = /** @class */ (function (_super) {
                __extends(MatTreeNodePadding, _super);
                function MatTreeNodePadding() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatTreeNodePadding;
            }(_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNodePadding"]));
            MatTreeNodePadding.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matTreeNodePadding]',
                            providers: [{ provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNodePadding"], useExisting: MatTreeNodePadding }]
                        },] },
            ];
            MatTreeNodePadding.propDecorators = {
                level: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matTreeNodePadding',] }],
                indent: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matTreeNodePaddingIndent',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Outlet for nested CdkNode. Put `[matTreeNodeOutlet]` on a tag to place children dataNodes
             * inside the outlet.
             */
            var MatTreeNodeOutlet = /** @class */ (function () {
                /**
                 * @param {?} viewContainer
                 * @param {?=} _node
                 */
                function MatTreeNodeOutlet(viewContainer, _node) {
                    this.viewContainer = viewContainer;
                    this._node = _node;
                }
                return MatTreeNodeOutlet;
            }());
            MatTreeNodeOutlet.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matTreeNodeOutlet]',
                            providers: [{
                                    provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNodeOutlet"],
                                    useExisting: MatTreeNodeOutlet
                                }]
                        },] },
            ];
            /** @nocollapse */
            MatTreeNodeOutlet.ctorParameters = function () { return [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewContainerRef"] },
                { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Inject"], args: [_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CDK_TREE_NODE_OUTLET_NODE"],] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Optional"] }] }
            ]; };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Wrapper for the CdkTable with Material design styles.
             * @template T
             */
            var MatTree = /** @class */ (function (_super) {
                __extends(MatTree, _super);
                function MatTree() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return MatTree;
            }(_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTree"]));
            MatTree.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"], args: [{ selector: 'mat-tree',
                            exportAs: 'matTree',
                            template: "<ng-container matTreeNodeOutlet></ng-container>",
                            host: {
                                'class': 'mat-tree',
                                'role': 'tree',
                            },
                            styles: [".mat-tree{display:block}.mat-tree-node{display:flex;align-items:center;min-height:48px;flex:1;overflow:hidden;word-wrap:break-word}.mat-nested-tree-ndoe{border-bottom-width:0}"],
                            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
                            // See note on CdkTree for explanation on why this uses the default change detection strategy.
                            // tslint:disable-next-line:validate-decorators
                            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ChangeDetectionStrategy"].Default,
                            providers: [{ provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTree"], useExisting: MatTree }]
                        },] },
            ];
            MatTree.propDecorators = {
                _nodeOutlet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewChild"], args: [MatTreeNodeOutlet, { static: true },] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Wrapper for the CdkTree's toggle with Material design styles.
             * @template T
             */
            var MatTreeNodeToggle = /** @class */ (function (_super) {
                __extends(MatTreeNodeToggle, _super);
                function MatTreeNodeToggle() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    _this.recursive = false;
                    return _this;
                }
                return MatTreeNodeToggle;
            }(_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNodeToggle"]));
            MatTreeNodeToggle.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"], args: [{
                            selector: '[matTreeNodeToggle]',
                            providers: [{ provide: _angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeNodeToggle"], useExisting: MatTreeNodeToggle }]
                        },] },
            ];
            MatTreeNodeToggle.propDecorators = {
                recursive: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"], args: ['matTreeNodeToggleRecursive',] }]
            };
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /** @type {?} */
            var MAT_TREE_DIRECTIVES = [
                MatNestedTreeNode,
                MatTreeNodeDef,
                MatTreeNodePadding,
                MatTreeNodeToggle,
                MatTree,
                MatTreeNode,
                MatTreeNodeOutlet
            ];
            var MatTreeModule = /** @class */ (function () {
                function MatTreeModule() {
                }
                return MatTreeModule;
            }());
            MatTreeModule.decorators = [
                { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"], args: [{
                            imports: [_angular_cdk_tree__WEBPACK_IMPORTED_MODULE_0__["CdkTreeModule"], _angular_common__WEBPACK_IMPORTED_MODULE_4__["CommonModule"], _angular_material_core__WEBPACK_IMPORTED_MODULE_2__["MatCommonModule"]],
                            exports: MAT_TREE_DIRECTIVES,
                            declarations: MAT_TREE_DIRECTIVES,
                        },] },
            ];
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Tree flattener to convert a normal type of node to node with children & level information.
             * Transform nested nodes of type `T` to flattened nodes of type `F`.
             *
             * For example, the input data of type `T` is nested, and contains its children data:
             *   SomeNode: {
             *     key: 'Fruits',
             *     children: [
             *       NodeOne: {
             *         key: 'Apple',
             *       },
             *       NodeTwo: {
             *        key: 'Pear',
             *      }
             *    ]
             *  }
             *  After flattener flatten the tree, the structure will become
             *  SomeNode: {
             *    key: 'Fruits',
             *    expandable: true,
             *    level: 1
             *  },
             *  NodeOne: {
             *    key: 'Apple',
             *    expandable: false,
             *    level: 2
             *  },
             *  NodeTwo: {
             *   key: 'Pear',
             *   expandable: false,
             *   level: 2
             * }
             * and the output flattened type is `F` with additional information.
             * @template T, F
             */
            var MatTreeFlattener = /** @class */ (function () {
                /**
                 * @param {?} transformFunction
                 * @param {?} getLevel
                 * @param {?} isExpandable
                 * @param {?} getChildren
                 */
                function MatTreeFlattener(transformFunction, getLevel, isExpandable, getChildren) {
                    this.transformFunction = transformFunction;
                    this.getLevel = getLevel;
                    this.isExpandable = isExpandable;
                    this.getChildren = getChildren;
                }
                /**
                 * @param {?} node
                 * @param {?} level
                 * @param {?} resultNodes
                 * @param {?} parentMap
                 * @return {?}
                 */
                MatTreeFlattener.prototype._flattenNode = function (node, level, resultNodes, parentMap) {
                    var _this = this;
                    /** @type {?} */
                    var flatNode = this.transformFunction(node, level);
                    resultNodes.push(flatNode);
                    if (this.isExpandable(flatNode)) {
                        /** @type {?} */
                        var childrenNodes = this.getChildren(node);
                        if (childrenNodes) {
                            if (Array.isArray(childrenNodes)) {
                                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
                            }
                            else {
                                childrenNodes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["take"])(1)).subscribe(( /**
                                 * @param {?} children
                                 * @return {?}
                                 */function (/**
                                 * @param {?} children
                                 * @return {?}
                                 */ children) {
                                    _this._flattenChildren(children, level, resultNodes, parentMap);
                                }));
                            }
                        }
                    }
                    return resultNodes;
                };
                /**
                 * @param {?} children
                 * @param {?} level
                 * @param {?} resultNodes
                 * @param {?} parentMap
                 * @return {?}
                 */
                MatTreeFlattener.prototype._flattenChildren = function (children, level, resultNodes, parentMap) {
                    var _this = this;
                    children.forEach(( /**
                     * @param {?} child
                     * @param {?} index
                     * @return {?}
                     */function (child, index) {
                        /** @type {?} */
                        var childParentMap = parentMap.slice();
                        childParentMap.push(index != children.length - 1);
                        _this._flattenNode(child, level + 1, resultNodes, childParentMap);
                    }));
                };
                /**
                 * Flatten a list of node type T to flattened version of node F.
                 * Please note that type T may be nested, and the length of `structuredData` may be different
                 * from that of returned list `F[]`.
                 * @param {?} structuredData
                 * @return {?}
                 */
                MatTreeFlattener.prototype.flattenNodes = function (structuredData) {
                    var _this = this;
                    /** @type {?} */
                    var resultNodes = [];
                    structuredData.forEach(( /**
                     * @param {?} node
                     * @return {?}
                     */function (/**
                     * @param {?} node
                     * @return {?}
                     */ node) { return _this._flattenNode(node, 0, resultNodes, []); }));
                    return resultNodes;
                };
                /**
                 * Expand flattened node with current expansion status.
                 * The returned list may have different length.
                 * @param {?} nodes
                 * @param {?} treeControl
                 * @return {?}
                 */
                MatTreeFlattener.prototype.expandFlattenedNodes = function (nodes, treeControl) {
                    var _this = this;
                    /** @type {?} */
                    var results = [];
                    /** @type {?} */
                    var currentExpand = [];
                    currentExpand[0] = true;
                    nodes.forEach(( /**
                     * @param {?} node
                     * @return {?}
                     */function (/**
                     * @param {?} node
                     * @return {?}
                     */ node) {
                        /** @type {?} */
                        var expand = true;
                        for (var i = 0; i <= _this.getLevel(node); i++) {
                            expand = expand && currentExpand[i];
                        }
                        if (expand) {
                            results.push(node);
                        }
                        if (_this.isExpandable(node)) {
                            currentExpand[_this.getLevel(node) + 1] = treeControl.isExpanded(node);
                        }
                    }));
                    return results;
                };
                return MatTreeFlattener;
            }());
            /**
             * Data source for flat tree.
             * The data source need to handle expansion/collapsion of the tree node and change the data feed
             * to `MatTree`.
             * The nested tree nodes of type `T` are flattened through `MatTreeFlattener`, and converted
             * to type `F` for `MatTree` to consume.
             * @template T, F
             */
            var MatTreeFlatDataSource = /** @class */ (function (_super) {
                __extends(MatTreeFlatDataSource, _super);
                /**
                 * @param {?} _treeControl
                 * @param {?} _treeFlattener
                 * @param {?=} initialData
                 */
                function MatTreeFlatDataSource(_treeControl, _treeFlattener, initialData) {
                    if (initialData === void 0) { initialData = []; }
                    var _this = _super.call(this) || this;
                    _this._treeControl = _treeControl;
                    _this._treeFlattener = _treeFlattener;
                    _this._flattenedData = new rxjs__WEBPACK_IMPORTED_MODULE_6__["BehaviorSubject"]([]);
                    _this._expandedData = new rxjs__WEBPACK_IMPORTED_MODULE_6__["BehaviorSubject"]([]);
                    _this._data = new rxjs__WEBPACK_IMPORTED_MODULE_6__["BehaviorSubject"](initialData);
                    return _this;
                }
                Object.defineProperty(MatTreeFlatDataSource.prototype, "data", {
                    /**
                     * @return {?}
                     */
                    get: function () { return this._data.value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) {
                        this._data.next(value);
                        this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
                        this._treeControl.dataNodes = this._flattenedData.value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} collectionViewer
                 * @return {?}
                 */
                MatTreeFlatDataSource.prototype.connect = function (collectionViewer) {
                    var _this = this;
                    /** @type {?} */
                    var changes = [
                        collectionViewer.viewChange,
                        this._treeControl.expansionModel.onChange,
                        this._flattenedData
                    ];
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["merge"]).apply(void 0, __spread(changes)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["map"])(( /**
                     * @return {?}
                     */function () {
                        _this._expandedData.next(_this._treeFlattener.expandFlattenedNodes(_this._flattenedData.value, _this._treeControl));
                        return _this._expandedData.value;
                    })));
                };
                /**
                 * @return {?}
                 */
                MatTreeFlatDataSource.prototype.disconnect = function () {
                    // no op
                };
                return MatTreeFlatDataSource;
            }(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_5__["DataSource"]));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * Data source for nested tree.
             *
             * The data source for nested tree doesn't have to consider node flattener, or the way to expand
             * or collapse. The expansion/collapsion will be handled by TreeControl and each non-leaf node.
             * @template T
             */
            var MatTreeNestedDataSource = /** @class */ (function (_super) {
                __extends(MatTreeNestedDataSource, _super);
                function MatTreeNestedDataSource() {
                    var _this = _super.apply(this, __spread(arguments)) || this;
                    _this._data = new rxjs__WEBPACK_IMPORTED_MODULE_6__["BehaviorSubject"]([]);
                    return _this;
                }
                Object.defineProperty(MatTreeNestedDataSource.prototype, "data", {
                    /**
                     * Data for the nested tree
                     * @return {?}
                     */
                    get: function () { return this._data.value; },
                    /**
                     * @param {?} value
                     * @return {?}
                     */
                    set: function (value) { this._data.next(value); },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @param {?} collectionViewer
                 * @return {?}
                 */
                MatTreeNestedDataSource.prototype.connect = function (collectionViewer) {
                    var _this = this;
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_6__["merge"]).apply(void 0, __spread([collectionViewer.viewChange, this._data])).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__["map"])(( /**
                 * @return {?}
                 */function () {
                        return _this.data;
                    })));
                };
                /**
                 * @return {?}
                 */
                MatTreeNestedDataSource.prototype.disconnect = function () {
                    // no op
                };
                return MatTreeNestedDataSource;
            }(_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_5__["DataSource"]));
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            /**
             * @fileoverview added by tsickle
             * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
             */
            //# sourceMappingURL=tree.js.map
            /***/ 
        })
    }]);
//# sourceMappingURL=default~components-genre-list-genre-list-module~components-movie-details-movie-details-module~compon~08bc50d6-es2015.js.map
//# sourceMappingURL=default~components-genre-list-genre-list-module~components-movie-details-movie-details-module~compon~08bc50d6-es5.js.map
//# sourceMappingURL=default~components-genre-list-genre-list-module~components-movie-details-movie-details-module~compon~08bc50d6-es5.js.map