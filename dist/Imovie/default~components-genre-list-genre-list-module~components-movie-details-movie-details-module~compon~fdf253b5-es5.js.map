{"version":3,"sources":["default~components-genre-list-genre-list-module~components-movie-details-movie-details-module~compon~fdf253b5-es5.js","webpack:///node_modules/@angular/cdk/esm2015/text-field.js","webpack:///node_modules/@angular/material/esm2015/icon.js","webpack:///node_modules/@angular/material/esm2015/input.js"],"names":[],"mappings":"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","file":"x","sourcesContent":["(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[\"default~components-genre-list-genre-list-module~components-movie-details-movie-details-module~compon~fdf253b5\"],{\n\n/***/ \"./node_modules/@angular/cdk/esm2015/text-field.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/@angular/cdk/esm2015/text-field.js ***!\n  \\*********************************************************/\n/*! exports provided: AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AutofillMonitor\", function() { return AutofillMonitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkAutofill\", function() { return CdkAutofill; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CdkTextareaAutosize\", function() { return CdkTextareaAutosize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextFieldModule\", function() { return TextFieldModule; });\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/esm2015/platform.js\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/esm2015/coercion.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm2015/index.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm2015/operators/index.js\");\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Options to pass to the animationstart listener.\n * @type {?}\n */\nconst listenerOptions = Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"normalizePassiveListenerOptions\"])({ passive: true });\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/\\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nclass AutofillMonitor {\n    /**\n     * @param {?} _platform\n     * @param {?} _ngZone\n     */\n    constructor(_platform, _ngZone) {\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._monitoredElements = new Map();\n    }\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    monitor(elementOrRef) {\n        if (!this._platform.isBrowser) {\n            return rxjs__WEBPACK_IMPORTED_MODULE_3__[\"EMPTY\"];\n        }\n        /** @type {?} */\n        const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__[\"coerceElement\"])(elementOrRef);\n        /** @type {?} */\n        const info = this._monitoredElements.get(element);\n        if (info) {\n            return info.subject.asObservable();\n        }\n        /** @type {?} */\n        const result = new rxjs__WEBPACK_IMPORTED_MODULE_3__[\"Subject\"]();\n        /** @type {?} */\n        const cssClass = 'cdk-text-field-autofilled';\n        /** @type {?} */\n        const listener = (/** @type {?} */ (((/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            // Animation events fire on initial element render, we check for the presence of the autofill\n            // CSS class to make sure this is a real change in state, not just the initial render before\n            // we fire off events.\n            if (event.animationName === 'cdk-text-field-autofill-start' &&\n                !element.classList.contains(cssClass)) {\n                element.classList.add(cssClass);\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => result.next({ target: (/** @type {?} */ (event.target)), isAutofilled: true })));\n            }\n            else if (event.animationName === 'cdk-text-field-autofill-end' &&\n                element.classList.contains(cssClass)) {\n                element.classList.remove(cssClass);\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => result.next({ target: (/** @type {?} */ (event.target)), isAutofilled: false })));\n            }\n        }))));\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            element.addEventListener('animationstart', listener, listenerOptions);\n            element.classList.add('cdk-text-field-autofill-monitored');\n        }));\n        this._monitoredElements.set(element, {\n            subject: result,\n            unlisten: (/**\n             * @return {?}\n             */\n            () => {\n                element.removeEventListener('animationstart', listener, listenerOptions);\n            })\n        });\n        return result.asObservable();\n    }\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    stopMonitoring(elementOrRef) {\n        /** @type {?} */\n        const element = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__[\"coerceElement\"])(elementOrRef);\n        /** @type {?} */\n        const info = this._monitoredElements.get(element);\n        if (info) {\n            info.unlisten();\n            info.subject.complete();\n            element.classList.remove('cdk-text-field-autofill-monitored');\n            element.classList.remove('cdk-text-field-autofilled');\n            this._monitoredElements.delete(element);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._monitoredElements.forEach((/**\n         * @param {?} _info\n         * @param {?} element\n         * @return {?}\n         */\n        (_info, element) => this.stopMonitoring(element)));\n    }\n}\nAutofillMonitor.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Injectable\"], args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nAutofillMonitor.ctorParameters = () => [\n    { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"Platform\"] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgZone\"] }\n];\n/** @nocollapse */ AutofillMonitor.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵdefineInjectable\"])({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵinject\"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"Platform\"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵinject\"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgZone\"])); }, token: AutofillMonitor, providedIn: \"root\" });\n/**\n * A directive that can be used to monitor the autofill state of an input.\n */\nclass CdkAutofill {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _autofillMonitor\n     */\n    constructor(_elementRef, _autofillMonitor) {\n        this._elementRef = _elementRef;\n        this._autofillMonitor = _autofillMonitor;\n        /**\n         * Emits when the autofill state of the element changes.\n         */\n        this.cdkAutofill = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"EventEmitter\"]();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this._autofillMonitor\n            .monitor(this._elementRef)\n            .subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => this.cdkAutofill.emit(event)));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._autofillMonitor.stopMonitoring(this._elementRef);\n    }\n}\nCdkAutofill.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Directive\"], args: [{\n                selector: '[cdkAutofill]',\n            },] },\n];\n/** @nocollapse */\nCdkAutofill.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ElementRef\"] },\n    { type: AutofillMonitor }\n];\nCdkAutofill.propDecorators = {\n    cdkAutofill: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Output\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n */\nclass CdkTextareaAutosize {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _platform\n     * @param {?} _ngZone\n     */\n    constructor(_elementRef, _platform, _ngZone) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_3__[\"Subject\"]();\n        this._enabled = true;\n        /**\n         * Value of minRows as of last resize. If the minRows has decreased, the\n         * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n         * does not have the same problem because it does not affect the textarea's scrollHeight.\n         */\n        this._previousMinRows = -1;\n        this._textareaElement = (/** @type {?} */ (this._elementRef.nativeElement));\n    }\n    /**\n     * Minimum amount of rows in the textarea.\n     * @return {?}\n     */\n    get minRows() { return this._minRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set minRows(value) {\n        this._minRows = value;\n        this._setMinHeight();\n    }\n    /**\n     * Maximum amount of rows in the textarea.\n     * @return {?}\n     */\n    get maxRows() { return this._maxRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set maxRows(value) {\n        this._maxRows = value;\n        this._setMaxHeight();\n    }\n    /**\n     * Whether autosizing is enabled or not\n     * @return {?}\n     */\n    get enabled() { return this._enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set enabled(value) {\n        value = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__[\"coerceBooleanProperty\"])(value);\n        // Only act if the actual value changed. This specifically helps to not run\n        // resizeToFitContent too early (i.e. before ngAfterViewInit)\n        if (this._enabled !== value) {\n            (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n        }\n    }\n    /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n    _setMinHeight() {\n        /** @type {?} */\n        const minHeight = this.minRows && this._cachedLineHeight ?\n            `${this.minRows * this._cachedLineHeight}px` : null;\n        if (minHeight) {\n            this._textareaElement.style.minHeight = minHeight;\n        }\n    }\n    /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n    _setMaxHeight() {\n        /** @type {?} */\n        const maxHeight = this.maxRows && this._cachedLineHeight ?\n            `${this.maxRows * this._cachedLineHeight}px` : null;\n        if (maxHeight) {\n            this._textareaElement.style.maxHeight = maxHeight;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (this._platform.isBrowser) {\n            // Remember the height which we started with in case autosizing is disabled\n            this._initialHeight = this._textareaElement.style.height;\n            this.resizeToFitContent();\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                Object(rxjs__WEBPACK_IMPORTED_MODULE_3__[\"fromEvent\"])(window, 'resize')\n                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\"auditTime\"])(16), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[\"takeUntil\"])(this._destroyed))\n                    .subscribe((/**\n                 * @return {?}\n                 */\n                () => this.resizeToFitContent(true)));\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @private\n     * @return {?}\n     */\n    _cacheTextareaLineHeight() {\n        if (this._cachedLineHeight) {\n            return;\n        }\n        // Use a clone element because we have to override some styles.\n        /** @type {?} */\n        let textareaClone = (/** @type {?} */ (this._textareaElement.cloneNode(false)));\n        textareaClone.rows = 1;\n        // Use `position: absolute` so that this doesn't cause a browser layout and use\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n        // would affect the height.\n        textareaClone.style.position = 'absolute';\n        textareaClone.style.visibility = 'hidden';\n        textareaClone.style.border = 'none';\n        textareaClone.style.padding = '0';\n        textareaClone.style.height = '';\n        textareaClone.style.minHeight = '';\n        textareaClone.style.maxHeight = '';\n        // In Firefox it happens that textarea elements are always bigger than the specified amount\n        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n        // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n        // to hidden. This ensures that there is no invalid calculation of the line height.\n        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n        textareaClone.style.overflow = 'hidden';\n        (/** @type {?} */ (this._textareaElement.parentNode)).appendChild(textareaClone);\n        this._cachedLineHeight = textareaClone.clientHeight;\n        (/** @type {?} */ (this._textareaElement.parentNode)).removeChild(textareaClone);\n        // Min and max heights have to be re-calculated if the cached line height changes\n        this._setMinHeight();\n        this._setMaxHeight();\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        if (this._platform.isBrowser) {\n            this.resizeToFitContent();\n        }\n    }\n    /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n    resizeToFitContent(force = false) {\n        // If autosizing is disabled, just skip everything else\n        if (!this._enabled) {\n            return;\n        }\n        this._cacheTextareaLineHeight();\n        // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n        // in checking the height of the textarea.\n        if (!this._cachedLineHeight) {\n            return;\n        }\n        /** @type {?} */\n        const textarea = (/** @type {?} */ (this._elementRef.nativeElement));\n        /** @type {?} */\n        const value = textarea.value;\n        // Only resize if the value or minRows have changed since these calculations can be expensive.\n        if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n            return;\n        }\n        /** @type {?} */\n        const placeholderText = textarea.placeholder;\n        // Reset the textarea height to auto in order to shrink back to its default size.\n        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n        // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n        // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n        // need to be removed temporarily.\n        textarea.classList.add('cdk-textarea-autosize-measuring');\n        textarea.placeholder = '';\n        // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with\n        // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n        /** @type {?} */\n        const height = textarea.scrollHeight - 4;\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n        textarea.style.height = `${height}px`;\n        textarea.classList.remove('cdk-textarea-autosize-measuring');\n        textarea.placeholder = placeholderText;\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            if (typeof requestAnimationFrame !== 'undefined') {\n                requestAnimationFrame((/**\n                 * @return {?}\n                 */\n                () => this._scrollToCaretPosition(textarea)));\n            }\n            else {\n                setTimeout((/**\n                 * @return {?}\n                 */\n                () => this._scrollToCaretPosition(textarea)));\n            }\n        }));\n        this._previousValue = value;\n        this._previousMinRows = this._minRows;\n    }\n    /**\n     * Resets the textarea to its original size\n     * @return {?}\n     */\n    reset() {\n        // Do not try to change the textarea, if the initialHeight has not been determined yet\n        // This might potentially remove styles when reset() is called before ngAfterViewInit\n        if (this._initialHeight === undefined) {\n            return;\n        }\n        this._textareaElement.style.height = this._initialHeight;\n    }\n    /**\n     * @return {?}\n     */\n    _noopInputHandler() {\n        // no-op handler that ensures we're running change detection on input events.\n    }\n    /**\n     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n     * prevent it from scrolling to the caret position. We need to re-set the selection\n     * in order for it to scroll to the proper position.\n     * @private\n     * @param {?} textarea\n     * @return {?}\n     */\n    _scrollToCaretPosition(textarea) {\n        const { selectionStart, selectionEnd } = textarea;\n        // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n        // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n        // between the time we requested the animation frame and when it was executed.\n        // Also note that we have to assert that the textarea is focused before we set the\n        // selection range. Setting the selection range on a non-focused textarea will cause\n        // it to receive focus on IE and Edge.\n        if (!this._destroyed.isStopped && document.activeElement === textarea) {\n            textarea.setSelectionRange(selectionStart, selectionEnd);\n        }\n    }\n}\nCdkTextareaAutosize.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Directive\"], args: [{\n                selector: 'textarea[cdkTextareaAutosize]',\n                exportAs: 'cdkTextareaAutosize',\n                host: {\n                    'class': 'cdk-textarea-autosize',\n                    // Textarea elements that have the directive applied should have a single row by default.\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                    'rows': '1',\n                    '(input)': '_noopInputHandler()',\n                },\n            },] },\n];\n/** @nocollapse */\nCdkTextareaAutosize.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ElementRef\"] },\n    { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"Platform\"] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgZone\"] }\n];\nCdkTextareaAutosize.propDecorators = {\n    minRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"], args: ['cdkAutosizeMinRows',] }],\n    maxRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"], args: ['cdkAutosizeMaxRows',] }],\n    enabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"], args: ['cdkTextareaAutosize',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TextFieldModule {\n}\nTextFieldModule.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgModule\"], args: [{\n                declarations: [CdkAutofill, CdkTextareaAutosize],\n                imports: [_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__[\"PlatformModule\"]],\n                exports: [CdkAutofill, CdkTextareaAutosize],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n//# sourceMappingURL=text-field.js.map\n\n\n/***/ }),\n\n/***/ \"./node_modules/@angular/material/esm2015/icon.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/@angular/material/esm2015/icon.js ***!\n  \\********************************************************/\n/*! exports provided: MatIconModule, MAT_ICON_LOCATION_FACTORY, MAT_ICON_LOCATION, MatIcon, getMatIconNameNotFoundError, getMatIconNoHttpProviderError, getMatIconFailedToSanitizeUrlError, getMatIconFailedToSanitizeLiteralError, ICON_REGISTRY_PROVIDER_FACTORY, MatIconRegistry, ICON_REGISTRY_PROVIDER */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatIconModule\", function() { return MatIconModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAT_ICON_LOCATION_FACTORY\", function() { return MAT_ICON_LOCATION_FACTORY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAT_ICON_LOCATION\", function() { return MAT_ICON_LOCATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatIcon\", function() { return MatIcon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatIconNameNotFoundError\", function() { return getMatIconNameNotFoundError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatIconNoHttpProviderError\", function() { return getMatIconNoHttpProviderError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatIconFailedToSanitizeUrlError\", function() { return getMatIconFailedToSanitizeUrlError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatIconFailedToSanitizeLiteralError\", function() { return getMatIconFailedToSanitizeLiteralError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICON_REGISTRY_PROVIDER_FACTORY\", function() { return ICON_REGISTRY_PROVIDER_FACTORY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatIconRegistry\", function() { return MatIconRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ICON_REGISTRY_PROVIDER\", function() { return ICON_REGISTRY_PROVIDER; });\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ \"./node_modules/@angular/common/fesm2015/common.js\");\n/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common/http */ \"./node_modules/@angular/common/fesm2015/http.js\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/platform-browser */ \"./node_modules/@angular/platform-browser/fesm2015/platform-browser.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm2015/index.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs/operators */ \"./node_modules/rxjs/_esm2015/operators/index.js\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/esm2015/coercion.js\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/core */ \"./node_modules/@angular/material/esm2015/core.js\");\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns an exception to be thrown in the case when attempting to\n * load an icon with a name that cannot be found.\n * \\@docs-private\n * @param {?} iconName\n * @return {?}\n */\nfunction getMatIconNameNotFoundError(iconName) {\n    return Error(`Unable to find icon with the name \"${iconName}\"`);\n}\n/**\n * Returns an exception to be thrown when the consumer attempts to use\n * `<mat-icon>` without including \\@angular/common/http.\n * \\@docs-private\n * @return {?}\n */\nfunction getMatIconNoHttpProviderError() {\n    return Error('Could not find HttpClient provider for use with Angular Material icons. ' +\n        'Please include the HttpClientModule from @angular/common/http in your ' +\n        'app imports.');\n}\n/**\n * Returns an exception to be thrown when a URL couldn't be sanitized.\n * \\@docs-private\n * @param {?} url URL that was attempted to be sanitized.\n * @return {?}\n */\nfunction getMatIconFailedToSanitizeUrlError(url) {\n    return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL ` +\n        `via Angular's DomSanitizer. Attempted URL was \"${url}\".`);\n}\n/**\n * Returns an exception to be thrown when a HTML string couldn't be sanitized.\n * \\@docs-private\n * @param {?} literal HTML that was attempted to be sanitized.\n * @return {?}\n */\nfunction getMatIconFailedToSanitizeLiteralError(literal) {\n    return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by ` +\n        `Angular's DomSanitizer. Attempted literal was \"${literal}\".`);\n}\n/**\n * Configuration for an icon, including the URL and possibly the cached SVG element.\n * \\@docs-private\n */\nclass SvgIconConfig {\n    /**\n     * @param {?} data\n     * @param {?=} options\n     */\n    constructor(data, options) {\n        this.options = options;\n        // Note that we can't use `instanceof SVGElement` here,\n        // because it'll break during server-side rendering.\n        if (!!((/** @type {?} */ (data))).nodeName) {\n            this.svgElement = (/** @type {?} */ (data));\n        }\n        else {\n            this.url = (/** @type {?} */ (data));\n        }\n    }\n}\n/**\n * Service to register and display icons used by the `<mat-icon>` component.\n * - Registers icon URLs by namespace and name.\n * - Registers icon set URLs by namespace.\n * - Registers aliases for CSS classes, for use with icon fonts.\n * - Loads icons from URLs and extracts individual icons from icon sets.\n */\nclass MatIconRegistry {\n    /**\n     * @param {?} _httpClient\n     * @param {?} _sanitizer\n     * @param {?} document\n     * @param {?=} _errorHandler\n     */\n    constructor(_httpClient, _sanitizer, document, _errorHandler) {\n        this._httpClient = _httpClient;\n        this._sanitizer = _sanitizer;\n        this._errorHandler = _errorHandler;\n        /**\n         * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\n         */\n        this._svgIconConfigs = new Map();\n        /**\n         * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\n         * Multiple icon sets can be registered under the same namespace.\n         */\n        this._iconSetConfigs = new Map();\n        /**\n         * Cache for icons loaded by direct URLs.\n         */\n        this._cachedIconsByUrl = new Map();\n        /**\n         * In-progress icon fetches. Used to coalesce multiple requests to the same URL.\n         */\n        this._inProgressUrlFetches = new Map();\n        /**\n         * Map from font identifiers to their CSS class names. Used for icon fonts.\n         */\n        this._fontCssClassesByAlias = new Map();\n        /**\n         * The CSS class to apply when an `<mat-icon>` component has no icon name, url, or font specified.\n         * The default 'material-icons' value assumes that the material icon font has been loaded as\n         * described at http://google.github.io/material-design-icons/#icon-font-for-the-web\n         */\n        this._defaultFontSetClass = 'material-icons';\n        this._document = document;\n    }\n    /**\n     * Registers an icon by URL in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIcon(iconName, url, options) {\n        return (/** @type {?} */ (this)).addSvgIconInNamespace('', iconName, url, options);\n    }\n    /**\n     * Registers an icon using an HTML string in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} literal SVG source of the icon.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconLiteral(iconName, literal, options) {\n        return (/** @type {?} */ (this)).addSvgIconLiteralInNamespace('', iconName, literal, options);\n    }\n    /**\n     * Registers an icon by URL in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which the icon should be registered.\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconInNamespace(namespace, iconName, url, options) {\n        return (/** @type {?} */ (this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url, options));\n    }\n    /**\n     * Registers an icon using an HTML string in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which the icon should be registered.\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} literal SVG source of the icon.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconLiteralInNamespace(namespace, iconName, literal, options) {\n        /** @type {?} */\n        const sanitizedLiteral = (/** @type {?} */ (this))._sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"SecurityContext\"].HTML, literal);\n        if (!sanitizedLiteral) {\n            throw getMatIconFailedToSanitizeLiteralError(literal);\n        }\n        /** @type {?} */\n        const svgElement = (/** @type {?} */ (this))._createSvgElementForSingleIcon(sanitizedLiteral, options);\n        return (/** @type {?} */ (this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement, options));\n    }\n    /**\n     * Registers an icon set by URL in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSet(url, options) {\n        return (/** @type {?} */ (this)).addSvgIconSetInNamespace('', url, options);\n    }\n    /**\n     * Registers an icon set using an HTML string in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} literal SVG source of the icon set.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSetLiteral(literal, options) {\n        return (/** @type {?} */ (this)).addSvgIconSetLiteralInNamespace('', literal, options);\n    }\n    /**\n     * Registers an icon set by URL in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon set.\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSetInNamespace(namespace, url, options) {\n        return (/** @type {?} */ (this))._addSvgIconSetConfig(namespace, new SvgIconConfig(url, options));\n    }\n    /**\n     * Registers an icon set using an HTML string in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon set.\n     * @param {?} literal SVG source of the icon set.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSetLiteralInNamespace(namespace, literal, options) {\n        /** @type {?} */\n        const sanitizedLiteral = (/** @type {?} */ (this))._sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"SecurityContext\"].HTML, literal);\n        if (!sanitizedLiteral) {\n            throw getMatIconFailedToSanitizeLiteralError(literal);\n        }\n        /** @type {?} */\n        const svgElement = (/** @type {?} */ (this))._svgElementFromString(sanitizedLiteral);\n        return (/** @type {?} */ (this))._addSvgIconSetConfig(namespace, new SvgIconConfig(svgElement, options));\n    }\n    /**\n     * Defines an alias for a CSS class name to be used for icon fonts. Creating an matIcon\n     * component with the alias as the fontSet input will cause the class name to be applied\n     * to the `<mat-icon>` element.\n     *\n     * @template THIS\n     * @this {THIS}\n     * @param {?} alias Alias for the font.\n     * @param {?=} className Class name override to be used instead of the alias.\n     * @return {THIS}\n     */\n    registerFontClassAlias(alias, className = alias) {\n        (/** @type {?} */ (this))._fontCssClassesByAlias.set(alias, className);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Returns the CSS class name associated with the alias by a previous call to\n     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\n     * @param {?} alias\n     * @return {?}\n     */\n    classNameForFontAlias(alias) {\n        return this._fontCssClassesByAlias.get(alias) || alias;\n    }\n    /**\n     * Sets the CSS class name to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     *\n     * @template THIS\n     * @this {THIS}\n     * @param {?} className\n     * @return {THIS}\n     */\n    setDefaultFontSetClass(className) {\n        (/** @type {?} */ (this))._defaultFontSetClass = className;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Returns the CSS class name to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     * @return {?}\n     */\n    getDefaultFontSetClass() {\n        return this._defaultFontSetClass;\n    }\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\n     * it will not contain any modifications made to elements previously returned).\n     *\n     * @param {?} safeUrl URL from which to fetch the SVG icon.\n     * @return {?}\n     */\n    getSvgIconFromUrl(safeUrl) {\n        /** @type {?} */\n        const url = this._sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"SecurityContext\"].RESOURCE_URL, safeUrl);\n        if (!url) {\n            throw getMatIconFailedToSanitizeUrlError(safeUrl);\n        }\n        /** @type {?} */\n        const cachedIcon = this._cachedIconsByUrl.get(url);\n        if (cachedIcon) {\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[\"of\"])(cloneSvg(cachedIcon));\n        }\n        return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"tap\"])((/**\n         * @param {?} svg\n         * @return {?}\n         */\n        svg => this._cachedIconsByUrl.set((/** @type {?} */ (url)), svg))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"map\"])((/**\n         * @param {?} svg\n         * @return {?}\n         */\n        svg => cloneSvg(svg))));\n    }\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name\n     * and namespace. The icon must have been previously registered with addIcon or addIconSet;\n     * if not, the Observable will throw an error.\n     *\n     * @param {?} name Name of the icon to be retrieved.\n     * @param {?=} namespace Namespace in which to look for the icon.\n     * @return {?}\n     */\n    getNamedSvgIcon(name, namespace = '') {\n        // Return (copy of) cached icon if possible.\n        /** @type {?} */\n        const key = iconKey(namespace, name);\n        /** @type {?} */\n        const config = this._svgIconConfigs.get(key);\n        if (config) {\n            return this._getSvgFromConfig(config);\n        }\n        // See if we have any icon sets registered for the namespace.\n        /** @type {?} */\n        const iconSetConfigs = this._iconSetConfigs.get(namespace);\n        if (iconSetConfigs) {\n            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\n        }\n        return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[\"throwError\"])(getMatIconNameNotFoundError(key));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._svgIconConfigs.clear();\n        this._iconSetConfigs.clear();\n        this._cachedIconsByUrl.clear();\n    }\n    /**\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    _getSvgFromConfig(config) {\n        if (config.svgElement) {\n            // We already have the SVG element for this icon, return a copy.\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[\"of\"])(cloneSvg(config.svgElement));\n        }\n        else {\n            // Fetch the icon from the config's URL, cache it, and return a copy.\n            return this._loadSvgIconFromConfig(config).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"tap\"])((/**\n             * @param {?} svg\n             * @return {?}\n             */\n            svg => config.svgElement = svg)), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"map\"])((/**\n             * @param {?} svg\n             * @return {?}\n             */\n            svg => cloneSvg(svg))));\n        }\n    }\n    /**\n     * Attempts to find an icon with the specified name in any of the SVG icon sets.\n     * First searches the available cached icons for a nested element with a matching name, and\n     * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets\n     * that have not been cached, and searches again after all fetches are completed.\n     * The returned Observable produces the SVG element if possible, and throws\n     * an error if no icon with the specified name can be found.\n     * @private\n     * @param {?} name\n     * @param {?} iconSetConfigs\n     * @return {?}\n     */\n    _getSvgFromIconSetConfigs(name, iconSetConfigs) {\n        // For all the icon set SVG elements we've fetched, see if any contain an icon with the\n        // requested name.\n        /** @type {?} */\n        const namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n        if (namedIcon) {\n            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\n            // time anyway, there's probably not much advantage compared to just always extracting\n            // it from the icon set.\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[\"of\"])(namedIcon);\n        }\n        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't\n        // fetched, fetch them now and look for iconName in the results.\n        /** @type {?} */\n        const iconSetFetchRequests = iconSetConfigs\n            .filter((/**\n         * @param {?} iconSetConfig\n         * @return {?}\n         */\n        iconSetConfig => !iconSetConfig.svgElement))\n            .map((/**\n         * @param {?} iconSetConfig\n         * @return {?}\n         */\n        iconSetConfig => {\n            return this._loadSvgIconSetFromConfig(iconSetConfig).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"catchError\"])((/**\n             * @param {?} err\n             * @return {?}\n             */\n            (err) => {\n                /** @type {?} */\n                const url = this._sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"SecurityContext\"].RESOURCE_URL, iconSetConfig.url);\n                // Swallow errors fetching individual URLs so the\n                // combined Observable won't necessarily fail.\n                /** @type {?} */\n                const errorMessage = `Loading icon set URL: ${url} failed: ${err.message}`;\n                // @breaking-change 9.0.0 _errorHandler parameter to be made required\n                if (this._errorHandler) {\n                    this._errorHandler.handleError(new Error(errorMessage));\n                }\n                else {\n                    console.error(errorMessage);\n                }\n                return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[\"of\"])(null);\n            })));\n        }));\n        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\n        // cached SVG element (unless the request failed), and we can check again for the icon.\n        return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[\"forkJoin\"])(iconSetFetchRequests).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"map\"])((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const foundIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n            if (!foundIcon) {\n                throw getMatIconNameNotFoundError(name);\n            }\n            return foundIcon;\n        })));\n    }\n    /**\n     * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     * @private\n     * @param {?} iconName\n     * @param {?} iconSetConfigs\n     * @return {?}\n     */\n    _extractIconWithNameFromAnySet(iconName, iconSetConfigs) {\n        // Iterate backwards, so icon sets added later have precedence.\n        for (let i = iconSetConfigs.length - 1; i >= 0; i--) {\n            /** @type {?} */\n            const config = iconSetConfigs[i];\n            if (config.svgElement) {\n                /** @type {?} */\n                const foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName, config.options);\n                if (foundIcon) {\n                    return foundIcon;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    _loadSvgIconFromConfig(config) {\n        return this._fetchUrl(config.url)\n            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"map\"])((/**\n         * @param {?} svgText\n         * @return {?}\n         */\n        svgText => this._createSvgElementForSingleIcon(svgText, config.options))));\n    }\n    /**\n     * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    _loadSvgIconSetFromConfig(config) {\n        // If the SVG for this icon set has already been parsed, do nothing.\n        if (config.svgElement) {\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_4__[\"of\"])(config.svgElement);\n        }\n        return this._fetchUrl(config.url).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"map\"])((/**\n         * @param {?} svgText\n         * @return {?}\n         */\n        svgText => {\n            // It is possible that the icon set was parsed and cached by an earlier request, so parsing\n            // only needs to occur if the cache is yet unset.\n            if (!config.svgElement) {\n                config.svgElement = this._svgElementFromString(svgText);\n            }\n            return config.svgElement;\n        })));\n    }\n    /**\n     * Creates a DOM element from the given SVG string, and adds default attributes.\n     * @private\n     * @param {?} responseText\n     * @param {?=} options\n     * @return {?}\n     */\n    _createSvgElementForSingleIcon(responseText, options) {\n        /** @type {?} */\n        const svg = this._svgElementFromString(responseText);\n        this._setSvgAttributes(svg, options);\n        return svg;\n    }\n    /**\n     * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     * @private\n     * @param {?} iconSet\n     * @param {?} iconName\n     * @param {?=} options\n     * @return {?}\n     */\n    _extractSvgIconFromSet(iconSet, iconName, options) {\n        // Use the `id=\"iconName\"` syntax in order to escape special\n        // characters in the ID (versus using the #iconName syntax).\n        /** @type {?} */\n        const iconSource = iconSet.querySelector(`[id=\"${iconName}\"]`);\n        if (!iconSource) {\n            return null;\n        }\n        // Clone the element and remove the ID to prevent multiple elements from being added\n        // to the page with the same ID.\n        /** @type {?} */\n        const iconElement = (/** @type {?} */ (iconSource.cloneNode(true)));\n        iconElement.removeAttribute('id');\n        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\n        // the content of a new <svg> node.\n        if (iconElement.nodeName.toLowerCase() === 'svg') {\n            return this._setSvgAttributes((/** @type {?} */ (iconElement)), options);\n        }\n        // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note\n        // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\n        // tag is problematic on Firefox, because it needs to include the current page path.\n        if (iconElement.nodeName.toLowerCase() === 'symbol') {\n            return this._setSvgAttributes(this._toSvgElement(iconElement), options);\n        }\n        // createElement('SVG') doesn't work as expected; the DOM ends up with\n        // the correct nodes, but the SVG content doesn't render. Instead we\n        // have to create an empty SVG node using innerHTML and append its content.\n        // Elements created using DOMParser.parseFromString have the same problem.\n        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\n        /** @type {?} */\n        const svg = this._svgElementFromString('<svg></svg>');\n        // Clone the node so we don't remove it from the parent icon set element.\n        svg.appendChild(iconElement);\n        return this._setSvgAttributes(svg, options);\n    }\n    /**\n     * Creates a DOM element from the given SVG string.\n     * @private\n     * @param {?} str\n     * @return {?}\n     */\n    _svgElementFromString(str) {\n        /** @type {?} */\n        const div = this._document.createElement('DIV');\n        div.innerHTML = str;\n        /** @type {?} */\n        const svg = (/** @type {?} */ (div.querySelector('svg')));\n        if (!svg) {\n            throw Error('<svg> tag not found');\n        }\n        return svg;\n    }\n    /**\n     * Converts an element into an SVG node by cloning all of its children.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _toSvgElement(element) {\n        /** @type {?} */\n        const svg = this._svgElementFromString('<svg></svg>');\n        /** @type {?} */\n        const attributes = element.attributes;\n        // Copy over all the attributes from the `symbol` to the new SVG, except the id.\n        for (let i = 0; i < attributes.length; i++) {\n            const { name, value } = attributes[i];\n            if (name !== 'id') {\n                svg.setAttribute(name, value);\n            }\n        }\n        for (let i = 0; i < element.childNodes.length; i++) {\n            if (element.childNodes[i].nodeType === this._document.ELEMENT_NODE) {\n                svg.appendChild(element.childNodes[i].cloneNode(true));\n            }\n        }\n        return svg;\n    }\n    /**\n     * Sets the default attributes for an SVG element to be used as an icon.\n     * @private\n     * @param {?} svg\n     * @param {?=} options\n     * @return {?}\n     */\n    _setSvgAttributes(svg, options) {\n        svg.setAttribute('fit', '');\n        svg.setAttribute('height', '100%');\n        svg.setAttribute('width', '100%');\n        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n        if (options && options.viewBox) {\n            svg.setAttribute('viewBox', options.viewBox);\n        }\n        return svg;\n    }\n    /**\n     * Returns an Observable which produces the string contents of the given URL. Results may be\n     * cached, so future calls with the same URL may not cause another HTTP request.\n     * @private\n     * @param {?} safeUrl\n     * @return {?}\n     */\n    _fetchUrl(safeUrl) {\n        if (!this._httpClient) {\n            throw getMatIconNoHttpProviderError();\n        }\n        if (safeUrl == null) {\n            throw Error(`Cannot fetch icon from URL \"${safeUrl}\".`);\n        }\n        /** @type {?} */\n        const url = this._sanitizer.sanitize(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"SecurityContext\"].RESOURCE_URL, safeUrl);\n        if (!url) {\n            throw getMatIconFailedToSanitizeUrlError(safeUrl);\n        }\n        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n        // already a request in progress for that URL. It's necessary to call share() on the\n        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n        /** @type {?} */\n        const inProgressFetch = this._inProgressUrlFetches.get(url);\n        if (inProgressFetch) {\n            return inProgressFetch;\n        }\n        // TODO(jelbourn): for some reason, the `finalize` operator \"loses\" the generic type on the\n        // Observable. Figure out why and fix it.\n        /** @type {?} */\n        const req = this._httpClient.get(url, { responseType: 'text' }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"finalize\"])((/**\n         * @return {?}\n         */\n        () => this._inProgressUrlFetches.delete(url))), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"share\"])());\n        this._inProgressUrlFetches.set(url, req);\n        return req;\n    }\n    /**\n     * Registers an icon config by name in the specified namespace.\n     * @private\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon config.\n     * @param {?} iconName Name under which to register the config.\n     * @param {?} config Config to be registered.\n     * @return {THIS}\n     */\n    _addSvgIconConfig(namespace, iconName, config) {\n        (/** @type {?} */ (this))._svgIconConfigs.set(iconKey(namespace, iconName), config);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers an icon set config in the specified namespace.\n     * @private\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon config.\n     * @param {?} config Config to be registered.\n     * @return {THIS}\n     */\n    _addSvgIconSetConfig(namespace, config) {\n        /** @type {?} */\n        const configNamespace = (/** @type {?} */ (this))._iconSetConfigs.get(namespace);\n        if (configNamespace) {\n            configNamespace.push(config);\n        }\n        else {\n            (/** @type {?} */ (this))._iconSetConfigs.set(namespace, [config]);\n        }\n        return (/** @type {?} */ (this));\n    }\n}\nMatIconRegistry.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Injectable\"], args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nMatIconRegistry.ctorParameters = () => [\n    { type: _angular_common_http__WEBPACK_IMPORTED_MODULE_1__[\"HttpClient\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"] }] },\n    { type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__[\"DomSanitizer\"] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Inject\"], args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"DOCUMENT\"],] }] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ErrorHandler\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"] }] }\n];\n/** @nocollapse */ MatIconRegistry.ngInjectableDef = Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵdefineInjectable\"])({ factory: function MatIconRegistry_Factory() { return new MatIconRegistry(Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"])(_angular_common_http__WEBPACK_IMPORTED_MODULE_1__[\"HttpClient\"], 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"])(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__[\"DomSanitizer\"]), Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"DOCUMENT\"], 8), Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵinject\"])(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ErrorHandler\"], 8)); }, token: MatIconRegistry, providedIn: \"root\" });\n/**\n * \\@docs-private\n * @param {?} parentRegistry\n * @param {?} httpClient\n * @param {?} sanitizer\n * @param {?=} document\n * @param {?=} errorHandler\n * @return {?}\n */\nfunction ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, document, errorHandler) {\n    return parentRegistry || new MatIconRegistry(httpClient, sanitizer, document, errorHandler);\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nconst ICON_REGISTRY_PROVIDER = {\n    // If there is already an MatIconRegistry available, use that. Otherwise, provide a new one.\n    provide: MatIconRegistry,\n    deps: [\n        [new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"](), new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"SkipSelf\"](), MatIconRegistry],\n        [new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"](), _angular_common_http__WEBPACK_IMPORTED_MODULE_1__[\"HttpClient\"]],\n        _angular_platform_browser__WEBPACK_IMPORTED_MODULE_3__[\"DomSanitizer\"],\n        [new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"](), _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ErrorHandler\"]],\n        [new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"](), (/** @type {?} */ (_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"DOCUMENT\"]))],\n    ],\n    useFactory: ICON_REGISTRY_PROVIDER_FACTORY,\n};\n/**\n * Clones an SVGElement while preserving type information.\n * @param {?} svg\n * @return {?}\n */\nfunction cloneSvg(svg) {\n    return (/** @type {?} */ (svg.cloneNode(true)));\n}\n/**\n * Returns the cache key to use for an icon namespace and name.\n * @param {?} namespace\n * @param {?} name\n * @return {?}\n */\nfunction iconKey(namespace, name) {\n    return namespace + ':' + name;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatIcon.\n/**\n * \\@docs-private\n */\nclass MatIconBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\n/** @type {?} */\nconst _MatIconMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_7__[\"mixinColor\"])(MatIconBase);\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_ICON_LOCATION = new _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"InjectionToken\"]('mat-icon-location', {\n    providedIn: 'root',\n    factory: MAT_ICON_LOCATION_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_ICON_LOCATION_FACTORY() {\n    /** @type {?} */\n    const _document = Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"inject\"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"DOCUMENT\"]);\n    /** @type {?} */\n    const _location = _document ? _document.location : null;\n    return {\n        // Note that this needs to be a function, rather than a property, because Angular\n        // will only resolve it once, but we want the current path on each call.\n        getPathname: (/**\n         * @return {?}\n         */\n        () => _location ? (_location.pathname + _location.search) : '')\n    };\n}\n/**\n * SVG attributes that accept a FuncIRI (e.g. `url(<something>)`).\n * @type {?}\n */\nconst funcIriAttributes = [\n    'clip-path',\n    'color-profile',\n    'src',\n    'cursor',\n    'fill',\n    'filter',\n    'marker',\n    'marker-start',\n    'marker-mid',\n    'marker-end',\n    'mask',\n    'stroke'\n];\nconst ɵ0 = /**\n * @param {?} attr\n * @return {?}\n */\nattr => `[${attr}]`;\n/**\n * Selector that can be used to find all elements that are using a `FuncIRI`.\n * @type {?}\n */\nconst funcIriAttributeSelector = funcIriAttributes.map((ɵ0)).join(', ');\n/**\n * Regex that can be used to extract the id out of a FuncIRI.\n * @type {?}\n */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the content of the `<mat-icon>`\n *   component. By default the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fortawesome.github.io/Font-Awesome/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\nclass MatIcon extends _MatIconMixinBase {\n    /**\n     * @param {?} elementRef\n     * @param {?} _iconRegistry\n     * @param {?} ariaHidden\n     * @param {?=} _location\n     * @param {?=} _errorHandler\n     */\n    constructor(elementRef, _iconRegistry, ariaHidden, _location, _errorHandler) {\n        super(elementRef);\n        this._iconRegistry = _iconRegistry;\n        this._location = _location;\n        this._errorHandler = _errorHandler;\n        this._inline = false;\n        // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n        // the right thing to do for the majority of icon use-cases.\n        if (!ariaHidden) {\n            elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n        }\n    }\n    /**\n     * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n     * the element the icon is contained in.\n     * @return {?}\n     */\n    get inline() {\n        return this._inline;\n    }\n    /**\n     * @param {?} inline\n     * @return {?}\n     */\n    set inline(inline) {\n        this._inline = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__[\"coerceBooleanProperty\"])(inline);\n    }\n    /**\n     * Font set that the icon is a part of.\n     * @return {?}\n     */\n    get fontSet() { return this._fontSet; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set fontSet(value) {\n        this._fontSet = this._cleanupFontValue(value);\n    }\n    /**\n     * Name of an icon within a font set.\n     * @return {?}\n     */\n    get fontIcon() { return this._fontIcon; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set fontIcon(value) {\n        this._fontIcon = this._cleanupFontValue(value);\n    }\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws an error if the name contains two or more ':' separators.\n     * Examples:\n     *   `'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws Error)`\n     * @private\n     * @param {?} iconName\n     * @return {?}\n     */\n    _splitIconName(iconName) {\n        if (!iconName) {\n            return ['', ''];\n        }\n        /** @type {?} */\n        const parts = iconName.split(':');\n        switch (parts.length) {\n            case 1: return ['', parts[0]]; // Use default namespace.\n            case 2: return (/** @type {?} */ (parts));\n            default: throw Error(`Invalid icon name: \"${iconName}\"`);\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.\n        /** @type {?} */\n        const svgIconChanges = changes['svgIcon'];\n        if (svgIconChanges) {\n            if (this.svgIcon) {\n                const [namespace, iconName] = this._splitIconName(this.svgIcon);\n                this._iconRegistry.getNamedSvgIcon(iconName, namespace)\n                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[\"take\"])(1))\n                    .subscribe((/**\n                 * @param {?} svg\n                 * @return {?}\n                 */\n                svg => this._setSvgElement(svg)), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                (err) => {\n                    /** @type {?} */\n                    const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n                    // @breaking-change 9.0.0 _errorHandler parameter to be made required.\n                    if (this._errorHandler) {\n                        this._errorHandler.handleError(new Error(errorMessage));\n                    }\n                    else {\n                        console.error(errorMessage);\n                    }\n                }));\n            }\n            else if (svgIconChanges.previousValue) {\n                this._clearSvgElement();\n            }\n        }\n        if (this._usingFontIcon()) {\n            this._updateFontIconClasses();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n        // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n        if (this._usingFontIcon()) {\n            this._updateFontIconClasses();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewChecked() {\n        /** @type {?} */\n        const cachedElements = this._elementsWithExternalReferences;\n        if (cachedElements && this._location && cachedElements.size) {\n            /** @type {?} */\n            const newPath = this._location.getPathname();\n            // We need to check whether the URL has changed on each change detection since\n            // the browser doesn't have an API that will let us react on link clicks and\n            // we can't depend on the Angular router. The references need to be updated,\n            // because while most browsers don't care whether the URL is correct after\n            // the first render, Safari will break if the user navigates to a different\n            // page and the SVG isn't re-rendered.\n            if (newPath !== this._previousPath) {\n                this._previousPath = newPath;\n                this._prependPathToReferences(newPath);\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _usingFontIcon() {\n        return !this.svgIcon;\n    }\n    /**\n     * @private\n     * @param {?} svg\n     * @return {?}\n     */\n    _setSvgElement(svg) {\n        this._clearSvgElement();\n        // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.\n        // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/\n        // Do this before inserting the element into the DOM, in order to avoid a style recalculation.\n        /** @type {?} */\n        const styleTags = (/** @type {?} */ (svg.querySelectorAll('style')));\n        for (let i = 0; i < styleTags.length; i++) {\n            styleTags[i].textContent += ' ';\n        }\n        // Note: we do this fix here, rather than the icon registry, because the\n        // references have to point to the URL at the time that the icon was created.\n        if (this._location) {\n            /** @type {?} */\n            const path = this._location.getPathname();\n            this._previousPath = path;\n            this._cacheChildrenWithExternalReferences(svg);\n            this._prependPathToReferences(path);\n        }\n        this._elementRef.nativeElement.appendChild(svg);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _clearSvgElement() {\n        /** @type {?} */\n        const layoutElement = this._elementRef.nativeElement;\n        /** @type {?} */\n        let childCount = layoutElement.childNodes.length;\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n        // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n        // we can't use innerHTML, because IE will throw if the element has a data binding.\n        while (childCount--) {\n            /** @type {?} */\n            const child = layoutElement.childNodes[childCount];\n            // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n            // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n                layoutElement.removeChild(child);\n            }\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _updateFontIconClasses() {\n        if (!this._usingFontIcon()) {\n            return;\n        }\n        /** @type {?} */\n        const elem = this._elementRef.nativeElement;\n        /** @type {?} */\n        const fontSetClass = this.fontSet ?\n            this._iconRegistry.classNameForFontAlias(this.fontSet) :\n            this._iconRegistry.getDefaultFontSetClass();\n        if (fontSetClass != this._previousFontSetClass) {\n            if (this._previousFontSetClass) {\n                elem.classList.remove(this._previousFontSetClass);\n            }\n            if (fontSetClass) {\n                elem.classList.add(fontSetClass);\n            }\n            this._previousFontSetClass = fontSetClass;\n        }\n        if (this.fontIcon != this._previousFontIconClass) {\n            if (this._previousFontIconClass) {\n                elem.classList.remove(this._previousFontIconClass);\n            }\n            if (this.fontIcon) {\n                elem.classList.add(this.fontIcon);\n            }\n            this._previousFontIconClass = this.fontIcon;\n        }\n    }\n    /**\n     * Cleans up a value to be used as a fontIcon or fontSet.\n     * Since the value ends up being assigned as a CSS class, we\n     * have to trim the value and omit space-separated values.\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    _cleanupFontValue(value) {\n        return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n    }\n    /**\n     * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n     * reference. This is required because WebKit browsers require references to be prefixed with\n     * the current path, if the page has a `base` tag.\n     * @private\n     * @param {?} path\n     * @return {?}\n     */\n    _prependPathToReferences(path) {\n        /** @type {?} */\n        const elements = this._elementsWithExternalReferences;\n        if (elements) {\n            elements.forEach((/**\n             * @param {?} attrs\n             * @param {?} element\n             * @return {?}\n             */\n            (attrs, element) => {\n                attrs.forEach((/**\n                 * @param {?} attr\n                 * @return {?}\n                 */\n                attr => {\n                    element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n                }));\n            }));\n        }\n    }\n    /**\n     * Caches the children of an SVG element that have `url()`\n     * references that we need to prefix with the current path.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _cacheChildrenWithExternalReferences(element) {\n        /** @type {?} */\n        const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n        /** @type {?} */\n        const elements = this._elementsWithExternalReferences =\n            this._elementsWithExternalReferences || new Map();\n        for (let i = 0; i < elementsWithFuncIri.length; i++) {\n            funcIriAttributes.forEach((/**\n             * @param {?} attr\n             * @return {?}\n             */\n            attr => {\n                /** @type {?} */\n                const elementWithReference = elementsWithFuncIri[i];\n                /** @type {?} */\n                const value = elementWithReference.getAttribute(attr);\n                /** @type {?} */\n                const match = value ? value.match(funcIriPattern) : null;\n                if (match) {\n                    /** @type {?} */\n                    let attributes = elements.get(elementWithReference);\n                    if (!attributes) {\n                        attributes = [];\n                        elements.set(elementWithReference, attributes);\n                    }\n                    (/** @type {?} */ (attributes)).push({ name: attr, value: match[1] });\n                }\n            }));\n        }\n    }\n}\nMatIcon.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Component\"], args: [{template: '<ng-content></ng-content>',\n                selector: 'mat-icon',\n                exportAs: 'matIcon',\n                styles: [\".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1,1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\"],\n                inputs: ['color'],\n                host: {\n                    'role': 'img',\n                    'class': 'mat-icon notranslate',\n                    '[class.mat-icon-inline]': 'inline',\n                    '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n                },\n                encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ViewEncapsulation\"].None,\n                changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ChangeDetectionStrategy\"].OnPush,\n            },] },\n];\n/** @nocollapse */\nMatIcon.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ElementRef\"] },\n    { type: MatIconRegistry },\n    { type: String, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Attribute\"], args: ['aria-hidden',] }] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Inject\"], args: [MAT_ICON_LOCATION,] }] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ErrorHandler\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Optional\"] }] }\n];\nMatIcon.propDecorators = {\n    inline: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Input\"] }],\n    svgIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Input\"] }],\n    fontSet: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Input\"] }],\n    fontIcon: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"Input\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatIconModule {\n}\nMatIconModule.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"NgModule\"], args: [{\n                imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_7__[\"MatCommonModule\"]],\n                exports: [MatIcon, _angular_material_core__WEBPACK_IMPORTED_MODULE_7__[\"MatCommonModule\"]],\n                declarations: [MatIcon],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n//# sourceMappingURL=icon.js.map\n\n\n/***/ }),\n\n/***/ \"./node_modules/@angular/material/esm2015/input.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/@angular/material/esm2015/input.js ***!\n  \\*********************************************************/\n/*! exports provided: MatTextareaAutosize, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatTextareaAutosize\", function() { return MatTextareaAutosize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatInput\", function() { return MatInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMatInputUnsupportedTypeError\", function() { return getMatInputUnsupportedTypeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MatInputModule\", function() { return MatInputModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAT_INPUT_VALUE_ACCESSOR\", function() { return MAT_INPUT_VALUE_ACCESSOR; });\n/* harmony import */ var _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/text-field */ \"./node_modules/@angular/cdk/esm2015/text-field.js\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"./node_modules/@angular/core/fesm2015/core.js\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/esm2015/coercion.js\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/esm2015/platform.js\");\n/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/forms */ \"./node_modules/@angular/forms/fesm2015/forms.js\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ \"./node_modules/@angular/material/esm2015/core.js\");\n/* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/form-field */ \"./node_modules/@angular/material/esm2015/form-field.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rxjs */ \"./node_modules/rxjs/_esm2015/index.js\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/common */ \"./node_modules/@angular/common/fesm2015/common.js\");\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `\\@angular/cdk/text-field` instead.\n * \\@breaking-change 8.0.0\n */\nclass MatTextareaAutosize extends _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__[\"CdkTextareaAutosize\"] {\n    /**\n     * @return {?}\n     */\n    get matAutosizeMinRows() { return this.minRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosizeMinRows(value) { this.minRows = value; }\n    /**\n     * @return {?}\n     */\n    get matAutosizeMaxRows() { return this.maxRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosizeMaxRows(value) { this.maxRows = value; }\n    /**\n     * @return {?}\n     */\n    get matAutosize() { return this.enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosize(value) { this.enabled = value; }\n    /**\n     * @return {?}\n     */\n    get matTextareaAutosize() { return this.enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matTextareaAutosize(value) { this.enabled = value; }\n}\nMatTextareaAutosize.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Directive\"], args: [{\n                selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n                exportAs: 'matTextareaAutosize',\n                inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n                host: {\n                    'class': 'cdk-textarea-autosize mat-autosize',\n                    // Textarea elements that have the directive applied should have a single row by default.\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                    'rows': '1',\n                    '(input)': '_noopInputHandler()',\n                },\n            },] },\n];\nMatTextareaAutosize.propDecorators = {\n    matAutosizeMinRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    matAutosizeMaxRows: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    matAutosize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"], args: ['mat-autosize',] }],\n    matTextareaAutosize: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} type\n * @return {?}\n */\nfunction getMatInputUnsupportedTypeError(type) {\n    return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n * @type {?}\n */\nconst MAT_INPUT_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"InjectionToken\"]('MAT_INPUT_VALUE_ACCESSOR');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\n/** @type {?} */\nconst MAT_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit'\n];\n/** @type {?} */\nlet nextUniqueId = 0;\n// Boilerplate for applying mixins to MatInput.\n/**\n * \\@docs-private\n */\nclass MatInputBase {\n    /**\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} ngControl\n     */\n    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n}\n/** @type {?} */\nconst _MatInputMixinBase = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[\"mixinErrorState\"])(MatInputBase);\n/**\n * Directive that allows a native input to work inside a `MatFormField`.\n */\nclass MatInput extends _MatInputMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _platform\n     * @param {?} ngControl\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} inputValueAccessor\n     * @param {?} _autofillMonitor\n     * @param {?} ngZone\n     */\n    constructor(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this.ngControl = ngControl;\n        this._autofillMonitor = _autofillMonitor;\n        this._uid = `mat-input-${nextUniqueId++}`;\n        /**\n         * Whether the component is being rendered on the server.\n         */\n        this._isServer = false;\n        /**\n         * Whether the component is a native html select.\n         */\n        this._isNativeSelect = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.focused = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_7__[\"Subject\"]();\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.controlType = 'mat-input';\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.autofilled = false;\n        this._disabled = false;\n        this._required = false;\n        this._type = 'text';\n        this._readonly = false;\n        this._neverEmptyInputTypes = [\n            'date',\n            'datetime',\n            'datetime-local',\n            'month',\n            'time',\n            'week'\n        ].filter((/**\n         * @param {?} t\n         * @return {?}\n         */\n        t => Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__[\"getSupportedInputTypes\"])().has(t)));\n        /** @type {?} */\n        const element = this._elementRef.nativeElement;\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        this._inputValueAccessor = inputValueAccessor || element;\n        this._previousNativeValue = this.value;\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n        // exists on iOS, we only bother to install the listener on iOS.\n        if (_platform.IOS) {\n            ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                _elementRef.nativeElement.addEventListener('keyup', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    /** @type {?} */\n                    let el = (/** @type {?} */ (event.target));\n                    if (!el.value && !el.selectionStart && !el.selectionEnd) {\n                        // Note: Just setting `0, 0` doesn't fix the issue. Setting\n                        // `1, 1` fixes it for the first time that you type text and\n                        // then hold delete. Toggling to `1, 1` and then back to\n                        // `0, 0` seems to completely fix it.\n                        el.setSelectionRange(1, 1);\n                        el.setSelectionRange(0, 0);\n                    }\n                }));\n            }));\n        }\n        this._isServer = !this._platform.isBrowser;\n        this._isNativeSelect = element.nodeName.toLowerCase() === 'select';\n        if (this._isNativeSelect) {\n            this.controlType = ((/** @type {?} */ (element))).multiple ? 'mat-native-select-multiple' :\n                'mat-native-select';\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get disabled() {\n        if (this.ngControl && this.ngControl.disabled !== null) {\n            return this.ngControl.disabled;\n        }\n        return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__[\"coerceBooleanProperty\"])(value);\n        // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n        if (this.focused) {\n            this.focused = false;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get id() { return this._id; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set id(value) { this._id = value || this._uid; }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get required() { return this._required; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set required(value) { this._required = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__[\"coerceBooleanProperty\"])(value); }\n    /**\n     * Input type of the element.\n     * @return {?}\n     */\n    get type() { return this._type; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set type(value) {\n        this._type = value || 'text';\n        this._validateType();\n        // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n        if (!this._isTextarea() && Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__[\"getSupportedInputTypes\"])().has(this._type)) {\n            ((/** @type {?} */ (this._elementRef.nativeElement))).type = this._type;\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get value() { return this._inputValueAccessor.value; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set value(value) {\n        if (value !== this.value) {\n            this._inputValueAccessor.value = value;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Whether the element is readonly.\n     * @return {?}\n     */\n    get readonly() { return this._readonly; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set readonly(value) { this._readonly = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_2__[\"coerceBooleanProperty\"])(value); }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((/**\n             * @param {?} event\n             * @return {?}\n             */\n            event => {\n                this.autofilled = event.isAutofilled;\n                this.stateChanges.next();\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnChanges() {\n        this.stateChanges.next();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.stateChanges.complete();\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n        }\n        // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n        this._dirtyCheckNativeValue();\n    }\n    /**\n     * Focuses the input.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(options) {\n        this._elementRef.nativeElement.focus(options);\n    }\n    /**\n     * Callback for the cases where the focused state of the input changes.\n     * @param {?} isFocused\n     * @return {?}\n     */\n    _focusChanged(isFocused) {\n        if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n            this.focused = isFocused;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _onInput() {\n        // This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /**\n     * Does some manual dirty checking on the native input `value` property.\n     * @protected\n     * @return {?}\n     */\n    _dirtyCheckNativeValue() {\n        /** @type {?} */\n        const newValue = this._elementRef.nativeElement.value;\n        if (this._previousNativeValue !== newValue) {\n            this._previousNativeValue = newValue;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Make sure the input is a supported type.\n     * @protected\n     * @return {?}\n     */\n    _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n            throw getMatInputUnsupportedTypeError(this._type);\n        }\n    }\n    /**\n     * Checks whether the input type is one of the types that are never empty.\n     * @protected\n     * @return {?}\n     */\n    _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /**\n     * Checks whether the input is invalid based on the native validation.\n     * @protected\n     * @return {?}\n     */\n    _isBadInput() {\n        // The `validity` property won't be present on platform-server.\n        /** @type {?} */\n        let validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;\n        return validity && validity.badInput;\n    }\n    /**\n     * Determines if the component host is a textarea.\n     * @protected\n     * @return {?}\n     */\n    _isTextarea() {\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get empty() {\n        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n            !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get shouldLabelFloat() {\n        if (this._isNativeSelect) {\n            // For a single-selection `<select>`, the label should float when the selected option has\n            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n            // overlapping the label with the options.\n            /** @type {?} */\n            const selectElement = (/** @type {?} */ (this._elementRef.nativeElement));\n            /** @type {?} */\n            const firstOption = selectElement.options[0];\n            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n            return this.focused || selectElement.multiple || !this.empty ||\n                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n        }\n        else {\n            return this.focused || !this.empty;\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    setDescribedByIds(ids) {\n        this._ariaDescribedby = ids.join(' ');\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    onContainerClick() {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n        if (!this.focused) {\n            this.focus();\n        }\n    }\n}\nMatInput.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Directive\"], args: [{\n                selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n                exportAs: 'matInput',\n                host: {\n                    /**\n                     * \\@breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n                     */\n                    'class': 'mat-input-element mat-form-field-autofill-control',\n                    '[class.mat-input-server]': '_isServer',\n                    // Native input properties that are overwritten by Angular inputs need to be synced with\n                    // the native input element. Otherwise property bindings for those don't work.\n                    '[attr.id]': 'id',\n                    '[attr.placeholder]': 'placeholder',\n                    '[disabled]': 'disabled',\n                    '[required]': 'required',\n                    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n                    '[attr.aria-describedby]': '_ariaDescribedby || null',\n                    '[attr.aria-invalid]': 'errorState',\n                    '[attr.aria-required]': 'required.toString()',\n                    '(blur)': '_focusChanged(false)',\n                    '(focus)': '_focusChanged(true)',\n                    '(input)': '_onInput()',\n                },\n                providers: [{ provide: _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__[\"MatFormFieldControl\"], useExisting: MatInput }],\n            },] },\n];\n/** @nocollapse */\nMatInput.ctorParameters = () => [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ElementRef\"] },\n    { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__[\"Platform\"] },\n    { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__[\"NgControl\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Optional\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Self\"] }] },\n    { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__[\"NgForm\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Optional\"] }] },\n    { type: _angular_forms__WEBPACK_IMPORTED_MODULE_4__[\"FormGroupDirective\"], decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Optional\"] }] },\n    { type: _angular_material_core__WEBPACK_IMPORTED_MODULE_5__[\"ErrorStateMatcher\"] },\n    { type: undefined, decorators: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Optional\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Self\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Inject\"], args: [MAT_INPUT_VALUE_ACCESSOR,] }] },\n    { type: _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__[\"AutofillMonitor\"] },\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgZone\"] }\n];\nMatInput.propDecorators = {\n    disabled: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    id: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    placeholder: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    required: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    type: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    errorStateMatcher: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    value: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }],\n    readonly: [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"Input\"] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatInputModule {\n}\nMatInputModule.decorators = [\n    { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"NgModule\"], args: [{\n                declarations: [MatInput, MatTextareaAutosize],\n                imports: [\n                    _angular_common__WEBPACK_IMPORTED_MODULE_8__[\"CommonModule\"],\n                    _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__[\"TextFieldModule\"],\n                    _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__[\"MatFormFieldModule\"],\n                ],\n                exports: [\n                    _angular_cdk_text_field__WEBPACK_IMPORTED_MODULE_0__[\"TextFieldModule\"],\n                    // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n                    // be used together with `MatFormField`.\n                    _angular_material_form_field__WEBPACK_IMPORTED_MODULE_6__[\"MatFormFieldModule\"],\n                    MatInput,\n                    MatTextareaAutosize,\n                ],\n                providers: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__[\"ErrorStateMatcher\"]],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n//# sourceMappingURL=input.js.map\n\n\n/***/ })\n\n}]);\n//# sourceMappingURL=default~components-genre-list-genre-list-module~components-movie-details-movie-details-module~compon~fdf253b5-es2015.js.map","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { Platform, normalizePassiveListenerOptions, PlatformModule } from '@angular/cdk/platform';\nimport { Directive, ElementRef, EventEmitter, Injectable, NgZone, Output, Input, NgModule, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { coerceElement, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { EMPTY, Subject, fromEvent } from 'rxjs';\nimport { auditTime, takeUntil } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Options to pass to the animationstart listener.\n * @type {?}\n */\nconst listenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * An injectable service that can be used to monitor the autofill state of an input.\n * Based on the following blog post:\n * https://medium.com/\\@brunn/detecting-autofilled-fields-in-javascript-aed598d25da7\n */\nclass AutofillMonitor {\n    /**\n     * @param {?} _platform\n     * @param {?} _ngZone\n     */\n    constructor(_platform, _ngZone) {\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._monitoredElements = new Map();\n    }\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    monitor(elementOrRef) {\n        if (!this._platform.isBrowser) {\n            return EMPTY;\n        }\n        /** @type {?} */\n        const element = coerceElement(elementOrRef);\n        /** @type {?} */\n        const info = this._monitoredElements.get(element);\n        if (info) {\n            return info.subject.asObservable();\n        }\n        /** @type {?} */\n        const result = new Subject();\n        /** @type {?} */\n        const cssClass = 'cdk-text-field-autofilled';\n        /** @type {?} */\n        const listener = (/** @type {?} */ (((/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            // Animation events fire on initial element render, we check for the presence of the autofill\n            // CSS class to make sure this is a real change in state, not just the initial render before\n            // we fire off events.\n            if (event.animationName === 'cdk-text-field-autofill-start' &&\n                !element.classList.contains(cssClass)) {\n                element.classList.add(cssClass);\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => result.next({ target: (/** @type {?} */ (event.target)), isAutofilled: true })));\n            }\n            else if (event.animationName === 'cdk-text-field-autofill-end' &&\n                element.classList.contains(cssClass)) {\n                element.classList.remove(cssClass);\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => result.next({ target: (/** @type {?} */ (event.target)), isAutofilled: false })));\n            }\n        }))));\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            element.addEventListener('animationstart', listener, listenerOptions);\n            element.classList.add('cdk-text-field-autofill-monitored');\n        }));\n        this._monitoredElements.set(element, {\n            subject: result,\n            unlisten: (/**\n             * @return {?}\n             */\n            () => {\n                element.removeEventListener('animationstart', listener, listenerOptions);\n            })\n        });\n        return result.asObservable();\n    }\n    /**\n     * @param {?} elementOrRef\n     * @return {?}\n     */\n    stopMonitoring(elementOrRef) {\n        /** @type {?} */\n        const element = coerceElement(elementOrRef);\n        /** @type {?} */\n        const info = this._monitoredElements.get(element);\n        if (info) {\n            info.unlisten();\n            info.subject.complete();\n            element.classList.remove('cdk-text-field-autofill-monitored');\n            element.classList.remove('cdk-text-field-autofilled');\n            this._monitoredElements.delete(element);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._monitoredElements.forEach((/**\n         * @param {?} _info\n         * @param {?} element\n         * @return {?}\n         */\n        (_info, element) => this.stopMonitoring(element)));\n    }\n}\nAutofillMonitor.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nAutofillMonitor.ctorParameters = () => [\n    { type: Platform },\n    { type: NgZone }\n];\n/** @nocollapse */ AutofillMonitor.ngInjectableDef = ɵɵdefineInjectable({ factory: function AutofillMonitor_Factory() { return new AutofillMonitor(ɵɵinject(Platform), ɵɵinject(NgZone)); }, token: AutofillMonitor, providedIn: \"root\" });\n/**\n * A directive that can be used to monitor the autofill state of an input.\n */\nclass CdkAutofill {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _autofillMonitor\n     */\n    constructor(_elementRef, _autofillMonitor) {\n        this._elementRef = _elementRef;\n        this._autofillMonitor = _autofillMonitor;\n        /**\n         * Emits when the autofill state of the element changes.\n         */\n        this.cdkAutofill = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this._autofillMonitor\n            .monitor(this._elementRef)\n            .subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => this.cdkAutofill.emit(event)));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._autofillMonitor.stopMonitoring(this._elementRef);\n    }\n}\nCdkAutofill.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkAutofill]',\n            },] },\n];\n/** @nocollapse */\nCdkAutofill.ctorParameters = () => [\n    { type: ElementRef },\n    { type: AutofillMonitor }\n];\nCdkAutofill.propDecorators = {\n    cdkAutofill: [{ type: Output }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n */\nclass CdkTextareaAutosize {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _platform\n     * @param {?} _ngZone\n     */\n    constructor(_elementRef, _platform, _ngZone) {\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this._ngZone = _ngZone;\n        this._destroyed = new Subject();\n        this._enabled = true;\n        /**\n         * Value of minRows as of last resize. If the minRows has decreased, the\n         * height of the textarea needs to be recomputed to reflect the new minimum. The maxHeight\n         * does not have the same problem because it does not affect the textarea's scrollHeight.\n         */\n        this._previousMinRows = -1;\n        this._textareaElement = (/** @type {?} */ (this._elementRef.nativeElement));\n    }\n    /**\n     * Minimum amount of rows in the textarea.\n     * @return {?}\n     */\n    get minRows() { return this._minRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set minRows(value) {\n        this._minRows = value;\n        this._setMinHeight();\n    }\n    /**\n     * Maximum amount of rows in the textarea.\n     * @return {?}\n     */\n    get maxRows() { return this._maxRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set maxRows(value) {\n        this._maxRows = value;\n        this._setMaxHeight();\n    }\n    /**\n     * Whether autosizing is enabled or not\n     * @return {?}\n     */\n    get enabled() { return this._enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set enabled(value) {\n        value = coerceBooleanProperty(value);\n        // Only act if the actual value changed. This specifically helps to not run\n        // resizeToFitContent too early (i.e. before ngAfterViewInit)\n        if (this._enabled !== value) {\n            (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n        }\n    }\n    /**\n     * Sets the minimum height of the textarea as determined by minRows.\n     * @return {?}\n     */\n    _setMinHeight() {\n        /** @type {?} */\n        const minHeight = this.minRows && this._cachedLineHeight ?\n            `${this.minRows * this._cachedLineHeight}px` : null;\n        if (minHeight) {\n            this._textareaElement.style.minHeight = minHeight;\n        }\n    }\n    /**\n     * Sets the maximum height of the textarea as determined by maxRows.\n     * @return {?}\n     */\n    _setMaxHeight() {\n        /** @type {?} */\n        const maxHeight = this.maxRows && this._cachedLineHeight ?\n            `${this.maxRows * this._cachedLineHeight}px` : null;\n        if (maxHeight) {\n            this._textareaElement.style.maxHeight = maxHeight;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        if (this._platform.isBrowser) {\n            // Remember the height which we started with in case autosizing is disabled\n            this._initialHeight = this._textareaElement.style.height;\n            this.resizeToFitContent();\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                fromEvent(window, 'resize')\n                    .pipe(auditTime(16), takeUntil(this._destroyed))\n                    .subscribe((/**\n                 * @return {?}\n                 */\n                () => this.resizeToFitContent(true)));\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Cache the height of a single-row textarea if it has not already been cached.\n     *\n     * We need to know how large a single \"row\" of a textarea is in order to apply minRows and\n     * maxRows. For the initial version, we will assume that the height of a single line in the\n     * textarea does not ever change.\n     * @private\n     * @return {?}\n     */\n    _cacheTextareaLineHeight() {\n        if (this._cachedLineHeight) {\n            return;\n        }\n        // Use a clone element because we have to override some styles.\n        /** @type {?} */\n        let textareaClone = (/** @type {?} */ (this._textareaElement.cloneNode(false)));\n        textareaClone.rows = 1;\n        // Use `position: absolute` so that this doesn't cause a browser layout and use\n        // `visibility: hidden` so that nothing is rendered. Clear any other styles that\n        // would affect the height.\n        textareaClone.style.position = 'absolute';\n        textareaClone.style.visibility = 'hidden';\n        textareaClone.style.border = 'none';\n        textareaClone.style.padding = '0';\n        textareaClone.style.height = '';\n        textareaClone.style.minHeight = '';\n        textareaClone.style.maxHeight = '';\n        // In Firefox it happens that textarea elements are always bigger than the specified amount\n        // of rows. This is because Firefox tries to add extra space for the horizontal scrollbar.\n        // As a workaround that removes the extra space for the scrollbar, we can just set overflow\n        // to hidden. This ensures that there is no invalid calculation of the line height.\n        // See Firefox bug report: https://bugzilla.mozilla.org/show_bug.cgi?id=33654\n        textareaClone.style.overflow = 'hidden';\n        (/** @type {?} */ (this._textareaElement.parentNode)).appendChild(textareaClone);\n        this._cachedLineHeight = textareaClone.clientHeight;\n        (/** @type {?} */ (this._textareaElement.parentNode)).removeChild(textareaClone);\n        // Min and max heights have to be re-calculated if the cached line height changes\n        this._setMinHeight();\n        this._setMaxHeight();\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        if (this._platform.isBrowser) {\n            this.resizeToFitContent();\n        }\n    }\n    /**\n     * Resize the textarea to fit its content.\n     * @param {?=} force Whether to force a height recalculation. By default the height will be\n     *    recalculated only if the value changed since the last call.\n     * @return {?}\n     */\n    resizeToFitContent(force = false) {\n        // If autosizing is disabled, just skip everything else\n        if (!this._enabled) {\n            return;\n        }\n        this._cacheTextareaLineHeight();\n        // If we haven't determined the line-height yet, we know we're still hidden and there's no point\n        // in checking the height of the textarea.\n        if (!this._cachedLineHeight) {\n            return;\n        }\n        /** @type {?} */\n        const textarea = (/** @type {?} */ (this._elementRef.nativeElement));\n        /** @type {?} */\n        const value = textarea.value;\n        // Only resize if the value or minRows have changed since these calculations can be expensive.\n        if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n            return;\n        }\n        /** @type {?} */\n        const placeholderText = textarea.placeholder;\n        // Reset the textarea height to auto in order to shrink back to its default size.\n        // Also temporarily force overflow:hidden, so scroll bars do not interfere with calculations.\n        // Long placeholders that are wider than the textarea width may lead to a bigger scrollHeight\n        // value. To ensure that the scrollHeight is not bigger than the content, the placeholders\n        // need to be removed temporarily.\n        textarea.classList.add('cdk-textarea-autosize-measuring');\n        textarea.placeholder = '';\n        // The cdk-textarea-autosize-measuring class includes a 2px padding to workaround an issue with\n        // Chrome, so we account for that extra space here by subtracting 4 (2px top + 2px bottom).\n        /** @type {?} */\n        const height = textarea.scrollHeight - 4;\n        // Use the scrollHeight to know how large the textarea *would* be if fit its entire value.\n        textarea.style.height = `${height}px`;\n        textarea.classList.remove('cdk-textarea-autosize-measuring');\n        textarea.placeholder = placeholderText;\n        this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            if (typeof requestAnimationFrame !== 'undefined') {\n                requestAnimationFrame((/**\n                 * @return {?}\n                 */\n                () => this._scrollToCaretPosition(textarea)));\n            }\n            else {\n                setTimeout((/**\n                 * @return {?}\n                 */\n                () => this._scrollToCaretPosition(textarea)));\n            }\n        }));\n        this._previousValue = value;\n        this._previousMinRows = this._minRows;\n    }\n    /**\n     * Resets the textarea to its original size\n     * @return {?}\n     */\n    reset() {\n        // Do not try to change the textarea, if the initialHeight has not been determined yet\n        // This might potentially remove styles when reset() is called before ngAfterViewInit\n        if (this._initialHeight === undefined) {\n            return;\n        }\n        this._textareaElement.style.height = this._initialHeight;\n    }\n    /**\n     * @return {?}\n     */\n    _noopInputHandler() {\n        // no-op handler that ensures we're running change detection on input events.\n    }\n    /**\n     * Scrolls a textarea to the caret position. On Firefox resizing the textarea will\n     * prevent it from scrolling to the caret position. We need to re-set the selection\n     * in order for it to scroll to the proper position.\n     * @private\n     * @param {?} textarea\n     * @return {?}\n     */\n    _scrollToCaretPosition(textarea) {\n        const { selectionStart, selectionEnd } = textarea;\n        // IE will throw an \"Unspecified error\" if we try to set the selection range after the\n        // element has been removed from the DOM. Assert that the directive hasn't been destroyed\n        // between the time we requested the animation frame and when it was executed.\n        // Also note that we have to assert that the textarea is focused before we set the\n        // selection range. Setting the selection range on a non-focused textarea will cause\n        // it to receive focus on IE and Edge.\n        if (!this._destroyed.isStopped && document.activeElement === textarea) {\n            textarea.setSelectionRange(selectionStart, selectionEnd);\n        }\n    }\n}\nCdkTextareaAutosize.decorators = [\n    { type: Directive, args: [{\n                selector: 'textarea[cdkTextareaAutosize]',\n                exportAs: 'cdkTextareaAutosize',\n                host: {\n                    'class': 'cdk-textarea-autosize',\n                    // Textarea elements that have the directive applied should have a single row by default.\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                    'rows': '1',\n                    '(input)': '_noopInputHandler()',\n                },\n            },] },\n];\n/** @nocollapse */\nCdkTextareaAutosize.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Platform },\n    { type: NgZone }\n];\nCdkTextareaAutosize.propDecorators = {\n    minRows: [{ type: Input, args: ['cdkAutosizeMinRows',] }],\n    maxRows: [{ type: Input, args: ['cdkAutosizeMaxRows',] }],\n    enabled: [{ type: Input, args: ['cdkTextareaAutosize',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass TextFieldModule {\n}\nTextFieldModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [CdkAutofill, CdkTextareaAutosize],\n                imports: [PlatformModule],\n                exports: [CdkAutofill, CdkTextareaAutosize],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n//# sourceMappingURL=text-field.js.map\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { DOCUMENT } from '@angular/common';\nimport { HttpClient } from '@angular/common/http';\nimport { ErrorHandler, Inject, Injectable, Optional, SecurityContext, SkipSelf, NgModule, Attribute, ChangeDetectionStrategy, Component, ElementRef, inject, InjectionToken, Input, ViewEncapsulation, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { forkJoin, of, throwError } from 'rxjs';\nimport { catchError, finalize, map, share, tap, take } from 'rxjs/operators';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { mixinColor, MatCommonModule } from '@angular/material/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns an exception to be thrown in the case when attempting to\n * load an icon with a name that cannot be found.\n * \\@docs-private\n * @param {?} iconName\n * @return {?}\n */\nfunction getMatIconNameNotFoundError(iconName) {\n    return Error(`Unable to find icon with the name \"${iconName}\"`);\n}\n/**\n * Returns an exception to be thrown when the consumer attempts to use\n * `<mat-icon>` without including \\@angular/common/http.\n * \\@docs-private\n * @return {?}\n */\nfunction getMatIconNoHttpProviderError() {\n    return Error('Could not find HttpClient provider for use with Angular Material icons. ' +\n        'Please include the HttpClientModule from @angular/common/http in your ' +\n        'app imports.');\n}\n/**\n * Returns an exception to be thrown when a URL couldn't be sanitized.\n * \\@docs-private\n * @param {?} url URL that was attempted to be sanitized.\n * @return {?}\n */\nfunction getMatIconFailedToSanitizeUrlError(url) {\n    return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL ` +\n        `via Angular's DomSanitizer. Attempted URL was \"${url}\".`);\n}\n/**\n * Returns an exception to be thrown when a HTML string couldn't be sanitized.\n * \\@docs-private\n * @param {?} literal HTML that was attempted to be sanitized.\n * @return {?}\n */\nfunction getMatIconFailedToSanitizeLiteralError(literal) {\n    return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by ` +\n        `Angular's DomSanitizer. Attempted literal was \"${literal}\".`);\n}\n/**\n * Configuration for an icon, including the URL and possibly the cached SVG element.\n * \\@docs-private\n */\nclass SvgIconConfig {\n    /**\n     * @param {?} data\n     * @param {?=} options\n     */\n    constructor(data, options) {\n        this.options = options;\n        // Note that we can't use `instanceof SVGElement` here,\n        // because it'll break during server-side rendering.\n        if (!!((/** @type {?} */ (data))).nodeName) {\n            this.svgElement = (/** @type {?} */ (data));\n        }\n        else {\n            this.url = (/** @type {?} */ (data));\n        }\n    }\n}\n/**\n * Service to register and display icons used by the `<mat-icon>` component.\n * - Registers icon URLs by namespace and name.\n * - Registers icon set URLs by namespace.\n * - Registers aliases for CSS classes, for use with icon fonts.\n * - Loads icons from URLs and extracts individual icons from icon sets.\n */\nclass MatIconRegistry {\n    /**\n     * @param {?} _httpClient\n     * @param {?} _sanitizer\n     * @param {?} document\n     * @param {?=} _errorHandler\n     */\n    constructor(_httpClient, _sanitizer, document, _errorHandler) {\n        this._httpClient = _httpClient;\n        this._sanitizer = _sanitizer;\n        this._errorHandler = _errorHandler;\n        /**\n         * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\n         */\n        this._svgIconConfigs = new Map();\n        /**\n         * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\n         * Multiple icon sets can be registered under the same namespace.\n         */\n        this._iconSetConfigs = new Map();\n        /**\n         * Cache for icons loaded by direct URLs.\n         */\n        this._cachedIconsByUrl = new Map();\n        /**\n         * In-progress icon fetches. Used to coalesce multiple requests to the same URL.\n         */\n        this._inProgressUrlFetches = new Map();\n        /**\n         * Map from font identifiers to their CSS class names. Used for icon fonts.\n         */\n        this._fontCssClassesByAlias = new Map();\n        /**\n         * The CSS class to apply when an `<mat-icon>` component has no icon name, url, or font specified.\n         * The default 'material-icons' value assumes that the material icon font has been loaded as\n         * described at http://google.github.io/material-design-icons/#icon-font-for-the-web\n         */\n        this._defaultFontSetClass = 'material-icons';\n        this._document = document;\n    }\n    /**\n     * Registers an icon by URL in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIcon(iconName, url, options) {\n        return (/** @type {?} */ (this)).addSvgIconInNamespace('', iconName, url, options);\n    }\n    /**\n     * Registers an icon using an HTML string in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} literal SVG source of the icon.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconLiteral(iconName, literal, options) {\n        return (/** @type {?} */ (this)).addSvgIconLiteralInNamespace('', iconName, literal, options);\n    }\n    /**\n     * Registers an icon by URL in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which the icon should be registered.\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconInNamespace(namespace, iconName, url, options) {\n        return (/** @type {?} */ (this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url, options));\n    }\n    /**\n     * Registers an icon using an HTML string in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which the icon should be registered.\n     * @param {?} iconName Name under which the icon should be registered.\n     * @param {?} literal SVG source of the icon.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconLiteralInNamespace(namespace, iconName, literal, options) {\n        /** @type {?} */\n        const sanitizedLiteral = (/** @type {?} */ (this))._sanitizer.sanitize(SecurityContext.HTML, literal);\n        if (!sanitizedLiteral) {\n            throw getMatIconFailedToSanitizeLiteralError(literal);\n        }\n        /** @type {?} */\n        const svgElement = (/** @type {?} */ (this))._createSvgElementForSingleIcon(sanitizedLiteral, options);\n        return (/** @type {?} */ (this))._addSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement, options));\n    }\n    /**\n     * Registers an icon set by URL in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSet(url, options) {\n        return (/** @type {?} */ (this)).addSvgIconSetInNamespace('', url, options);\n    }\n    /**\n     * Registers an icon set using an HTML string in the default namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} literal SVG source of the icon set.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSetLiteral(literal, options) {\n        return (/** @type {?} */ (this)).addSvgIconSetLiteralInNamespace('', literal, options);\n    }\n    /**\n     * Registers an icon set by URL in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon set.\n     * @param {?} url\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSetInNamespace(namespace, url, options) {\n        return (/** @type {?} */ (this))._addSvgIconSetConfig(namespace, new SvgIconConfig(url, options));\n    }\n    /**\n     * Registers an icon set using an HTML string in the specified namespace.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon set.\n     * @param {?} literal SVG source of the icon set.\n     * @param {?=} options\n     * @return {THIS}\n     */\n    addSvgIconSetLiteralInNamespace(namespace, literal, options) {\n        /** @type {?} */\n        const sanitizedLiteral = (/** @type {?} */ (this))._sanitizer.sanitize(SecurityContext.HTML, literal);\n        if (!sanitizedLiteral) {\n            throw getMatIconFailedToSanitizeLiteralError(literal);\n        }\n        /** @type {?} */\n        const svgElement = (/** @type {?} */ (this))._svgElementFromString(sanitizedLiteral);\n        return (/** @type {?} */ (this))._addSvgIconSetConfig(namespace, new SvgIconConfig(svgElement, options));\n    }\n    /**\n     * Defines an alias for a CSS class name to be used for icon fonts. Creating an matIcon\n     * component with the alias as the fontSet input will cause the class name to be applied\n     * to the `<mat-icon>` element.\n     *\n     * @template THIS\n     * @this {THIS}\n     * @param {?} alias Alias for the font.\n     * @param {?=} className Class name override to be used instead of the alias.\n     * @return {THIS}\n     */\n    registerFontClassAlias(alias, className = alias) {\n        (/** @type {?} */ (this))._fontCssClassesByAlias.set(alias, className);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Returns the CSS class name associated with the alias by a previous call to\n     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\n     * @param {?} alias\n     * @return {?}\n     */\n    classNameForFontAlias(alias) {\n        return this._fontCssClassesByAlias.get(alias) || alias;\n    }\n    /**\n     * Sets the CSS class name to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     *\n     * @template THIS\n     * @this {THIS}\n     * @param {?} className\n     * @return {THIS}\n     */\n    setDefaultFontSetClass(className) {\n        (/** @type {?} */ (this))._defaultFontSetClass = className;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Returns the CSS class name to be used for icon fonts when an `<mat-icon>` component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     * @return {?}\n     */\n    getDefaultFontSetClass() {\n        return this._defaultFontSetClass;\n    }\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\n     * it will not contain any modifications made to elements previously returned).\n     *\n     * @param {?} safeUrl URL from which to fetch the SVG icon.\n     * @return {?}\n     */\n    getSvgIconFromUrl(safeUrl) {\n        /** @type {?} */\n        const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n        if (!url) {\n            throw getMatIconFailedToSanitizeUrlError(safeUrl);\n        }\n        /** @type {?} */\n        const cachedIcon = this._cachedIconsByUrl.get(url);\n        if (cachedIcon) {\n            return of(cloneSvg(cachedIcon));\n        }\n        return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(tap((/**\n         * @param {?} svg\n         * @return {?}\n         */\n        svg => this._cachedIconsByUrl.set((/** @type {?} */ (url)), svg))), map((/**\n         * @param {?} svg\n         * @return {?}\n         */\n        svg => cloneSvg(svg))));\n    }\n    /**\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name\n     * and namespace. The icon must have been previously registered with addIcon or addIconSet;\n     * if not, the Observable will throw an error.\n     *\n     * @param {?} name Name of the icon to be retrieved.\n     * @param {?=} namespace Namespace in which to look for the icon.\n     * @return {?}\n     */\n    getNamedSvgIcon(name, namespace = '') {\n        // Return (copy of) cached icon if possible.\n        /** @type {?} */\n        const key = iconKey(namespace, name);\n        /** @type {?} */\n        const config = this._svgIconConfigs.get(key);\n        if (config) {\n            return this._getSvgFromConfig(config);\n        }\n        // See if we have any icon sets registered for the namespace.\n        /** @type {?} */\n        const iconSetConfigs = this._iconSetConfigs.get(namespace);\n        if (iconSetConfigs) {\n            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\n        }\n        return throwError(getMatIconNameNotFoundError(key));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._svgIconConfigs.clear();\n        this._iconSetConfigs.clear();\n        this._cachedIconsByUrl.clear();\n    }\n    /**\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    _getSvgFromConfig(config) {\n        if (config.svgElement) {\n            // We already have the SVG element for this icon, return a copy.\n            return of(cloneSvg(config.svgElement));\n        }\n        else {\n            // Fetch the icon from the config's URL, cache it, and return a copy.\n            return this._loadSvgIconFromConfig(config).pipe(tap((/**\n             * @param {?} svg\n             * @return {?}\n             */\n            svg => config.svgElement = svg)), map((/**\n             * @param {?} svg\n             * @return {?}\n             */\n            svg => cloneSvg(svg))));\n        }\n    }\n    /**\n     * Attempts to find an icon with the specified name in any of the SVG icon sets.\n     * First searches the available cached icons for a nested element with a matching name, and\n     * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets\n     * that have not been cached, and searches again after all fetches are completed.\n     * The returned Observable produces the SVG element if possible, and throws\n     * an error if no icon with the specified name can be found.\n     * @private\n     * @param {?} name\n     * @param {?} iconSetConfigs\n     * @return {?}\n     */\n    _getSvgFromIconSetConfigs(name, iconSetConfigs) {\n        // For all the icon set SVG elements we've fetched, see if any contain an icon with the\n        // requested name.\n        /** @type {?} */\n        const namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n        if (namedIcon) {\n            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\n            // time anyway, there's probably not much advantage compared to just always extracting\n            // it from the icon set.\n            return of(namedIcon);\n        }\n        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't\n        // fetched, fetch them now and look for iconName in the results.\n        /** @type {?} */\n        const iconSetFetchRequests = iconSetConfigs\n            .filter((/**\n         * @param {?} iconSetConfig\n         * @return {?}\n         */\n        iconSetConfig => !iconSetConfig.svgElement))\n            .map((/**\n         * @param {?} iconSetConfig\n         * @return {?}\n         */\n        iconSetConfig => {\n            return this._loadSvgIconSetFromConfig(iconSetConfig).pipe(catchError((/**\n             * @param {?} err\n             * @return {?}\n             */\n            (err) => {\n                /** @type {?} */\n                const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);\n                // Swallow errors fetching individual URLs so the\n                // combined Observable won't necessarily fail.\n                /** @type {?} */\n                const errorMessage = `Loading icon set URL: ${url} failed: ${err.message}`;\n                // @breaking-change 9.0.0 _errorHandler parameter to be made required\n                if (this._errorHandler) {\n                    this._errorHandler.handleError(new Error(errorMessage));\n                }\n                else {\n                    console.error(errorMessage);\n                }\n                return of(null);\n            })));\n        }));\n        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\n        // cached SVG element (unless the request failed), and we can check again for the icon.\n        return forkJoin(iconSetFetchRequests).pipe(map((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const foundIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n            if (!foundIcon) {\n                throw getMatIconNameNotFoundError(name);\n            }\n            return foundIcon;\n        })));\n    }\n    /**\n     * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     * @private\n     * @param {?} iconName\n     * @param {?} iconSetConfigs\n     * @return {?}\n     */\n    _extractIconWithNameFromAnySet(iconName, iconSetConfigs) {\n        // Iterate backwards, so icon sets added later have precedence.\n        for (let i = iconSetConfigs.length - 1; i >= 0; i--) {\n            /** @type {?} */\n            const config = iconSetConfigs[i];\n            if (config.svgElement) {\n                /** @type {?} */\n                const foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName, config.options);\n                if (foundIcon) {\n                    return foundIcon;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    _loadSvgIconFromConfig(config) {\n        return this._fetchUrl(config.url)\n            .pipe(map((/**\n         * @param {?} svgText\n         * @return {?}\n         */\n        svgText => this._createSvgElementForSingleIcon(svgText, config.options))));\n    }\n    /**\n     * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    _loadSvgIconSetFromConfig(config) {\n        // If the SVG for this icon set has already been parsed, do nothing.\n        if (config.svgElement) {\n            return of(config.svgElement);\n        }\n        return this._fetchUrl(config.url).pipe(map((/**\n         * @param {?} svgText\n         * @return {?}\n         */\n        svgText => {\n            // It is possible that the icon set was parsed and cached by an earlier request, so parsing\n            // only needs to occur if the cache is yet unset.\n            if (!config.svgElement) {\n                config.svgElement = this._svgElementFromString(svgText);\n            }\n            return config.svgElement;\n        })));\n    }\n    /**\n     * Creates a DOM element from the given SVG string, and adds default attributes.\n     * @private\n     * @param {?} responseText\n     * @param {?=} options\n     * @return {?}\n     */\n    _createSvgElementForSingleIcon(responseText, options) {\n        /** @type {?} */\n        const svg = this._svgElementFromString(responseText);\n        this._setSvgAttributes(svg, options);\n        return svg;\n    }\n    /**\n     * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     * @private\n     * @param {?} iconSet\n     * @param {?} iconName\n     * @param {?=} options\n     * @return {?}\n     */\n    _extractSvgIconFromSet(iconSet, iconName, options) {\n        // Use the `id=\"iconName\"` syntax in order to escape special\n        // characters in the ID (versus using the #iconName syntax).\n        /** @type {?} */\n        const iconSource = iconSet.querySelector(`[id=\"${iconName}\"]`);\n        if (!iconSource) {\n            return null;\n        }\n        // Clone the element and remove the ID to prevent multiple elements from being added\n        // to the page with the same ID.\n        /** @type {?} */\n        const iconElement = (/** @type {?} */ (iconSource.cloneNode(true)));\n        iconElement.removeAttribute('id');\n        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\n        // the content of a new <svg> node.\n        if (iconElement.nodeName.toLowerCase() === 'svg') {\n            return this._setSvgAttributes((/** @type {?} */ (iconElement)), options);\n        }\n        // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>. Note\n        // that the same could be achieved by referring to it via <use href=\"#id\">, however the <use>\n        // tag is problematic on Firefox, because it needs to include the current page path.\n        if (iconElement.nodeName.toLowerCase() === 'symbol') {\n            return this._setSvgAttributes(this._toSvgElement(iconElement), options);\n        }\n        // createElement('SVG') doesn't work as expected; the DOM ends up with\n        // the correct nodes, but the SVG content doesn't render. Instead we\n        // have to create an empty SVG node using innerHTML and append its content.\n        // Elements created using DOMParser.parseFromString have the same problem.\n        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\n        /** @type {?} */\n        const svg = this._svgElementFromString('<svg></svg>');\n        // Clone the node so we don't remove it from the parent icon set element.\n        svg.appendChild(iconElement);\n        return this._setSvgAttributes(svg, options);\n    }\n    /**\n     * Creates a DOM element from the given SVG string.\n     * @private\n     * @param {?} str\n     * @return {?}\n     */\n    _svgElementFromString(str) {\n        /** @type {?} */\n        const div = this._document.createElement('DIV');\n        div.innerHTML = str;\n        /** @type {?} */\n        const svg = (/** @type {?} */ (div.querySelector('svg')));\n        if (!svg) {\n            throw Error('<svg> tag not found');\n        }\n        return svg;\n    }\n    /**\n     * Converts an element into an SVG node by cloning all of its children.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _toSvgElement(element) {\n        /** @type {?} */\n        const svg = this._svgElementFromString('<svg></svg>');\n        /** @type {?} */\n        const attributes = element.attributes;\n        // Copy over all the attributes from the `symbol` to the new SVG, except the id.\n        for (let i = 0; i < attributes.length; i++) {\n            const { name, value } = attributes[i];\n            if (name !== 'id') {\n                svg.setAttribute(name, value);\n            }\n        }\n        for (let i = 0; i < element.childNodes.length; i++) {\n            if (element.childNodes[i].nodeType === this._document.ELEMENT_NODE) {\n                svg.appendChild(element.childNodes[i].cloneNode(true));\n            }\n        }\n        return svg;\n    }\n    /**\n     * Sets the default attributes for an SVG element to be used as an icon.\n     * @private\n     * @param {?} svg\n     * @param {?=} options\n     * @return {?}\n     */\n    _setSvgAttributes(svg, options) {\n        svg.setAttribute('fit', '');\n        svg.setAttribute('height', '100%');\n        svg.setAttribute('width', '100%');\n        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n        if (options && options.viewBox) {\n            svg.setAttribute('viewBox', options.viewBox);\n        }\n        return svg;\n    }\n    /**\n     * Returns an Observable which produces the string contents of the given URL. Results may be\n     * cached, so future calls with the same URL may not cause another HTTP request.\n     * @private\n     * @param {?} safeUrl\n     * @return {?}\n     */\n    _fetchUrl(safeUrl) {\n        if (!this._httpClient) {\n            throw getMatIconNoHttpProviderError();\n        }\n        if (safeUrl == null) {\n            throw Error(`Cannot fetch icon from URL \"${safeUrl}\".`);\n        }\n        /** @type {?} */\n        const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n        if (!url) {\n            throw getMatIconFailedToSanitizeUrlError(safeUrl);\n        }\n        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n        // already a request in progress for that URL. It's necessary to call share() on the\n        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n        /** @type {?} */\n        const inProgressFetch = this._inProgressUrlFetches.get(url);\n        if (inProgressFetch) {\n            return inProgressFetch;\n        }\n        // TODO(jelbourn): for some reason, the `finalize` operator \"loses\" the generic type on the\n        // Observable. Figure out why and fix it.\n        /** @type {?} */\n        const req = this._httpClient.get(url, { responseType: 'text' }).pipe(finalize((/**\n         * @return {?}\n         */\n        () => this._inProgressUrlFetches.delete(url))), share());\n        this._inProgressUrlFetches.set(url, req);\n        return req;\n    }\n    /**\n     * Registers an icon config by name in the specified namespace.\n     * @private\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon config.\n     * @param {?} iconName Name under which to register the config.\n     * @param {?} config Config to be registered.\n     * @return {THIS}\n     */\n    _addSvgIconConfig(namespace, iconName, config) {\n        (/** @type {?} */ (this))._svgIconConfigs.set(iconKey(namespace, iconName), config);\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers an icon set config in the specified namespace.\n     * @private\n     * @template THIS\n     * @this {THIS}\n     * @param {?} namespace Namespace in which to register the icon config.\n     * @param {?} config Config to be registered.\n     * @return {THIS}\n     */\n    _addSvgIconSetConfig(namespace, config) {\n        /** @type {?} */\n        const configNamespace = (/** @type {?} */ (this))._iconSetConfigs.get(namespace);\n        if (configNamespace) {\n            configNamespace.push(config);\n        }\n        else {\n            (/** @type {?} */ (this))._iconSetConfigs.set(namespace, [config]);\n        }\n        return (/** @type {?} */ (this));\n    }\n}\nMatIconRegistry.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nMatIconRegistry.ctorParameters = () => [\n    { type: HttpClient, decorators: [{ type: Optional }] },\n    { type: DomSanitizer },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\n    { type: ErrorHandler, decorators: [{ type: Optional }] }\n];\n/** @nocollapse */ MatIconRegistry.ngInjectableDef = ɵɵdefineInjectable({ factory: function MatIconRegistry_Factory() { return new MatIconRegistry(ɵɵinject(HttpClient, 8), ɵɵinject(DomSanitizer), ɵɵinject(DOCUMENT, 8), ɵɵinject(ErrorHandler, 8)); }, token: MatIconRegistry, providedIn: \"root\" });\n/**\n * \\@docs-private\n * @param {?} parentRegistry\n * @param {?} httpClient\n * @param {?} sanitizer\n * @param {?=} document\n * @param {?=} errorHandler\n * @return {?}\n */\nfunction ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, document, errorHandler) {\n    return parentRegistry || new MatIconRegistry(httpClient, sanitizer, document, errorHandler);\n}\n/**\n * \\@docs-private\n * @type {?}\n */\nconst ICON_REGISTRY_PROVIDER = {\n    // If there is already an MatIconRegistry available, use that. Otherwise, provide a new one.\n    provide: MatIconRegistry,\n    deps: [\n        [new Optional(), new SkipSelf(), MatIconRegistry],\n        [new Optional(), HttpClient],\n        DomSanitizer,\n        [new Optional(), ErrorHandler],\n        [new Optional(), (/** @type {?} */ (DOCUMENT))],\n    ],\n    useFactory: ICON_REGISTRY_PROVIDER_FACTORY,\n};\n/**\n * Clones an SVGElement while preserving type information.\n * @param {?} svg\n * @return {?}\n */\nfunction cloneSvg(svg) {\n    return (/** @type {?} */ (svg.cloneNode(true)));\n}\n/**\n * Returns the cache key to use for an icon namespace and name.\n * @param {?} namespace\n * @param {?} name\n * @return {?}\n */\nfunction iconKey(namespace, name) {\n    return namespace + ':' + name;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Boilerplate for applying mixins to MatIcon.\n/**\n * \\@docs-private\n */\nclass MatIconBase {\n    /**\n     * @param {?} _elementRef\n     */\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\n/** @type {?} */\nconst _MatIconMixinBase = mixinColor(MatIconBase);\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * \\@docs-private\n * @type {?}\n */\nconst MAT_ICON_LOCATION = new InjectionToken('mat-icon-location', {\n    providedIn: 'root',\n    factory: MAT_ICON_LOCATION_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction MAT_ICON_LOCATION_FACTORY() {\n    /** @type {?} */\n    const _document = inject(DOCUMENT);\n    /** @type {?} */\n    const _location = _document ? _document.location : null;\n    return {\n        // Note that this needs to be a function, rather than a property, because Angular\n        // will only resolve it once, but we want the current path on each call.\n        getPathname: (/**\n         * @return {?}\n         */\n        () => _location ? (_location.pathname + _location.search) : '')\n    };\n}\n/**\n * SVG attributes that accept a FuncIRI (e.g. `url(<something>)`).\n * @type {?}\n */\nconst funcIriAttributes = [\n    'clip-path',\n    'color-profile',\n    'src',\n    'cursor',\n    'fill',\n    'filter',\n    'marker',\n    'marker-start',\n    'marker-mid',\n    'marker-end',\n    'mask',\n    'stroke'\n];\nconst ɵ0 = /**\n * @param {?} attr\n * @return {?}\n */\nattr => `[${attr}]`;\n/**\n * Selector that can be used to find all elements that are using a `FuncIRI`.\n * @type {?}\n */\nconst funcIriAttributeSelector = funcIriAttributes.map((ɵ0)).join(', ');\n/**\n * Regex that can be used to extract the id out of a FuncIRI.\n * @type {?}\n */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the content of the `<mat-icon>`\n *   component. By default the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fortawesome.github.io/Font-Awesome/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\nclass MatIcon extends _MatIconMixinBase {\n    /**\n     * @param {?} elementRef\n     * @param {?} _iconRegistry\n     * @param {?} ariaHidden\n     * @param {?=} _location\n     * @param {?=} _errorHandler\n     */\n    constructor(elementRef, _iconRegistry, ariaHidden, _location, _errorHandler) {\n        super(elementRef);\n        this._iconRegistry = _iconRegistry;\n        this._location = _location;\n        this._errorHandler = _errorHandler;\n        this._inline = false;\n        // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n        // the right thing to do for the majority of icon use-cases.\n        if (!ariaHidden) {\n            elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n        }\n    }\n    /**\n     * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n     * the element the icon is contained in.\n     * @return {?}\n     */\n    get inline() {\n        return this._inline;\n    }\n    /**\n     * @param {?} inline\n     * @return {?}\n     */\n    set inline(inline) {\n        this._inline = coerceBooleanProperty(inline);\n    }\n    /**\n     * Font set that the icon is a part of.\n     * @return {?}\n     */\n    get fontSet() { return this._fontSet; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set fontSet(value) {\n        this._fontSet = this._cleanupFontValue(value);\n    }\n    /**\n     * Name of an icon within a font set.\n     * @return {?}\n     */\n    get fontIcon() { return this._fontIcon; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set fontIcon(value) {\n        this._fontIcon = this._cleanupFontValue(value);\n    }\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws an error if the name contains two or more ':' separators.\n     * Examples:\n     *   `'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws Error)`\n     * @private\n     * @param {?} iconName\n     * @return {?}\n     */\n    _splitIconName(iconName) {\n        if (!iconName) {\n            return ['', ''];\n        }\n        /** @type {?} */\n        const parts = iconName.split(':');\n        switch (parts.length) {\n            case 1: return ['', parts[0]]; // Use default namespace.\n            case 2: return (/** @type {?} */ (parts));\n            default: throw Error(`Invalid icon name: \"${iconName}\"`);\n        }\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.\n        /** @type {?} */\n        const svgIconChanges = changes['svgIcon'];\n        if (svgIconChanges) {\n            if (this.svgIcon) {\n                const [namespace, iconName] = this._splitIconName(this.svgIcon);\n                this._iconRegistry.getNamedSvgIcon(iconName, namespace)\n                    .pipe(take(1))\n                    .subscribe((/**\n                 * @param {?} svg\n                 * @return {?}\n                 */\n                svg => this._setSvgElement(svg)), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                (err) => {\n                    /** @type {?} */\n                    const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n                    // @breaking-change 9.0.0 _errorHandler parameter to be made required.\n                    if (this._errorHandler) {\n                        this._errorHandler.handleError(new Error(errorMessage));\n                    }\n                    else {\n                        console.error(errorMessage);\n                    }\n                }));\n            }\n            else if (svgIconChanges.previousValue) {\n                this._clearSvgElement();\n            }\n        }\n        if (this._usingFontIcon()) {\n            this._updateFontIconClasses();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n        // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n        if (this._usingFontIcon()) {\n            this._updateFontIconClasses();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewChecked() {\n        /** @type {?} */\n        const cachedElements = this._elementsWithExternalReferences;\n        if (cachedElements && this._location && cachedElements.size) {\n            /** @type {?} */\n            const newPath = this._location.getPathname();\n            // We need to check whether the URL has changed on each change detection since\n            // the browser doesn't have an API that will let us react on link clicks and\n            // we can't depend on the Angular router. The references need to be updated,\n            // because while most browsers don't care whether the URL is correct after\n            // the first render, Safari will break if the user navigates to a different\n            // page and the SVG isn't re-rendered.\n            if (newPath !== this._previousPath) {\n                this._previousPath = newPath;\n                this._prependPathToReferences(newPath);\n            }\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _usingFontIcon() {\n        return !this.svgIcon;\n    }\n    /**\n     * @private\n     * @param {?} svg\n     * @return {?}\n     */\n    _setSvgElement(svg) {\n        this._clearSvgElement();\n        // Workaround for IE11 and Edge ignoring `style` tags inside dynamically-created SVGs.\n        // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/\n        // Do this before inserting the element into the DOM, in order to avoid a style recalculation.\n        /** @type {?} */\n        const styleTags = (/** @type {?} */ (svg.querySelectorAll('style')));\n        for (let i = 0; i < styleTags.length; i++) {\n            styleTags[i].textContent += ' ';\n        }\n        // Note: we do this fix here, rather than the icon registry, because the\n        // references have to point to the URL at the time that the icon was created.\n        if (this._location) {\n            /** @type {?} */\n            const path = this._location.getPathname();\n            this._previousPath = path;\n            this._cacheChildrenWithExternalReferences(svg);\n            this._prependPathToReferences(path);\n        }\n        this._elementRef.nativeElement.appendChild(svg);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _clearSvgElement() {\n        /** @type {?} */\n        const layoutElement = this._elementRef.nativeElement;\n        /** @type {?} */\n        let childCount = layoutElement.childNodes.length;\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n        // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n        // we can't use innerHTML, because IE will throw if the element has a data binding.\n        while (childCount--) {\n            /** @type {?} */\n            const child = layoutElement.childNodes[childCount];\n            // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n            // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n                layoutElement.removeChild(child);\n            }\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _updateFontIconClasses() {\n        if (!this._usingFontIcon()) {\n            return;\n        }\n        /** @type {?} */\n        const elem = this._elementRef.nativeElement;\n        /** @type {?} */\n        const fontSetClass = this.fontSet ?\n            this._iconRegistry.classNameForFontAlias(this.fontSet) :\n            this._iconRegistry.getDefaultFontSetClass();\n        if (fontSetClass != this._previousFontSetClass) {\n            if (this._previousFontSetClass) {\n                elem.classList.remove(this._previousFontSetClass);\n            }\n            if (fontSetClass) {\n                elem.classList.add(fontSetClass);\n            }\n            this._previousFontSetClass = fontSetClass;\n        }\n        if (this.fontIcon != this._previousFontIconClass) {\n            if (this._previousFontIconClass) {\n                elem.classList.remove(this._previousFontIconClass);\n            }\n            if (this.fontIcon) {\n                elem.classList.add(this.fontIcon);\n            }\n            this._previousFontIconClass = this.fontIcon;\n        }\n    }\n    /**\n     * Cleans up a value to be used as a fontIcon or fontSet.\n     * Since the value ends up being assigned as a CSS class, we\n     * have to trim the value and omit space-separated values.\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    _cleanupFontValue(value) {\n        return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n    }\n    /**\n     * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n     * reference. This is required because WebKit browsers require references to be prefixed with\n     * the current path, if the page has a `base` tag.\n     * @private\n     * @param {?} path\n     * @return {?}\n     */\n    _prependPathToReferences(path) {\n        /** @type {?} */\n        const elements = this._elementsWithExternalReferences;\n        if (elements) {\n            elements.forEach((/**\n             * @param {?} attrs\n             * @param {?} element\n             * @return {?}\n             */\n            (attrs, element) => {\n                attrs.forEach((/**\n                 * @param {?} attr\n                 * @return {?}\n                 */\n                attr => {\n                    element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n                }));\n            }));\n        }\n    }\n    /**\n     * Caches the children of an SVG element that have `url()`\n     * references that we need to prefix with the current path.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _cacheChildrenWithExternalReferences(element) {\n        /** @type {?} */\n        const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n        /** @type {?} */\n        const elements = this._elementsWithExternalReferences =\n            this._elementsWithExternalReferences || new Map();\n        for (let i = 0; i < elementsWithFuncIri.length; i++) {\n            funcIriAttributes.forEach((/**\n             * @param {?} attr\n             * @return {?}\n             */\n            attr => {\n                /** @type {?} */\n                const elementWithReference = elementsWithFuncIri[i];\n                /** @type {?} */\n                const value = elementWithReference.getAttribute(attr);\n                /** @type {?} */\n                const match = value ? value.match(funcIriPattern) : null;\n                if (match) {\n                    /** @type {?} */\n                    let attributes = elements.get(elementWithReference);\n                    if (!attributes) {\n                        attributes = [];\n                        elements.set(elementWithReference, attributes);\n                    }\n                    (/** @type {?} */ (attributes)).push({ name: attr, value: match[1] });\n                }\n            }));\n        }\n    }\n}\nMatIcon.decorators = [\n    { type: Component, args: [{template: '<ng-content></ng-content>',\n                selector: 'mat-icon',\n                exportAs: 'matIcon',\n                styles: [\".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1,1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\"],\n                inputs: ['color'],\n                host: {\n                    'role': 'img',\n                    'class': 'mat-icon notranslate',\n                    '[class.mat-icon-inline]': 'inline',\n                    '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n                },\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n            },] },\n];\n/** @nocollapse */\nMatIcon.ctorParameters = () => [\n    { type: ElementRef },\n    { type: MatIconRegistry },\n    { type: String, decorators: [{ type: Attribute, args: ['aria-hidden',] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_ICON_LOCATION,] }] },\n    { type: ErrorHandler, decorators: [{ type: Optional }] }\n];\nMatIcon.propDecorators = {\n    inline: [{ type: Input }],\n    svgIcon: [{ type: Input }],\n    fontSet: [{ type: Input }],\n    fontIcon: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatIconModule {\n}\nMatIconModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [MatCommonModule],\n                exports: [MatIcon, MatCommonModule],\n                declarations: [MatIcon],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { MatIconModule, MAT_ICON_LOCATION_FACTORY, MAT_ICON_LOCATION, MatIcon, getMatIconNameNotFoundError, getMatIconNoHttpProviderError, getMatIconFailedToSanitizeUrlError, getMatIconFailedToSanitizeLiteralError, ICON_REGISTRY_PROVIDER_FACTORY, MatIconRegistry, ICON_REGISTRY_PROVIDER };\n//# sourceMappingURL=icon.js.map\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Inject, NgZone, Optional, Self, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { ErrorStateMatcher, mixinErrorState } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `\\@angular/cdk/text-field` instead.\n * \\@breaking-change 8.0.0\n */\nclass MatTextareaAutosize extends CdkTextareaAutosize {\n    /**\n     * @return {?}\n     */\n    get matAutosizeMinRows() { return this.minRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosizeMinRows(value) { this.minRows = value; }\n    /**\n     * @return {?}\n     */\n    get matAutosizeMaxRows() { return this.maxRows; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosizeMaxRows(value) { this.maxRows = value; }\n    /**\n     * @return {?}\n     */\n    get matAutosize() { return this.enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matAutosize(value) { this.enabled = value; }\n    /**\n     * @return {?}\n     */\n    get matTextareaAutosize() { return this.enabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set matTextareaAutosize(value) { this.enabled = value; }\n}\nMatTextareaAutosize.decorators = [\n    { type: Directive, args: [{\n                selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n                exportAs: 'matTextareaAutosize',\n                inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n                host: {\n                    'class': 'cdk-textarea-autosize mat-autosize',\n                    // Textarea elements that have the directive applied should have a single row by default.\n                    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n                    'rows': '1',\n                    '(input)': '_noopInputHandler()',\n                },\n            },] },\n];\nMatTextareaAutosize.propDecorators = {\n    matAutosizeMinRows: [{ type: Input }],\n    matAutosizeMaxRows: [{ type: Input }],\n    matAutosize: [{ type: Input, args: ['mat-autosize',] }],\n    matTextareaAutosize: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@docs-private\n * @param {?} type\n * @return {?}\n */\nfunction getMatInputUnsupportedTypeError(type) {\n    return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n * @type {?}\n */\nconst MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\n/** @type {?} */\nconst MAT_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit'\n];\n/** @type {?} */\nlet nextUniqueId = 0;\n// Boilerplate for applying mixins to MatInput.\n/**\n * \\@docs-private\n */\nclass MatInputBase {\n    /**\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} ngControl\n     */\n    constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n}\n/** @type {?} */\nconst _MatInputMixinBase = mixinErrorState(MatInputBase);\n/**\n * Directive that allows a native input to work inside a `MatFormField`.\n */\nclass MatInput extends _MatInputMixinBase {\n    /**\n     * @param {?} _elementRef\n     * @param {?} _platform\n     * @param {?} ngControl\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} _defaultErrorStateMatcher\n     * @param {?} inputValueAccessor\n     * @param {?} _autofillMonitor\n     * @param {?} ngZone\n     */\n    constructor(_elementRef, _platform, ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone) {\n        super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n        this._elementRef = _elementRef;\n        this._platform = _platform;\n        this.ngControl = ngControl;\n        this._autofillMonitor = _autofillMonitor;\n        this._uid = `mat-input-${nextUniqueId++}`;\n        /**\n         * Whether the component is being rendered on the server.\n         */\n        this._isServer = false;\n        /**\n         * Whether the component is a native html select.\n         */\n        this._isNativeSelect = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.focused = false;\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.stateChanges = new Subject();\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.controlType = 'mat-input';\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * \\@docs-private\n         */\n        this.autofilled = false;\n        this._disabled = false;\n        this._required = false;\n        this._type = 'text';\n        this._readonly = false;\n        this._neverEmptyInputTypes = [\n            'date',\n            'datetime',\n            'datetime-local',\n            'month',\n            'time',\n            'week'\n        ].filter((/**\n         * @param {?} t\n         * @return {?}\n         */\n        t => getSupportedInputTypes().has(t)));\n        /** @type {?} */\n        const element = this._elementRef.nativeElement;\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        this._inputValueAccessor = inputValueAccessor || element;\n        this._previousNativeValue = this.value;\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n        // exists on iOS, we only bother to install the listener on iOS.\n        if (_platform.IOS) {\n            ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                _elementRef.nativeElement.addEventListener('keyup', (/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    /** @type {?} */\n                    let el = (/** @type {?} */ (event.target));\n                    if (!el.value && !el.selectionStart && !el.selectionEnd) {\n                        // Note: Just setting `0, 0` doesn't fix the issue. Setting\n                        // `1, 1` fixes it for the first time that you type text and\n                        // then hold delete. Toggling to `1, 1` and then back to\n                        // `0, 0` seems to completely fix it.\n                        el.setSelectionRange(1, 1);\n                        el.setSelectionRange(0, 0);\n                    }\n                }));\n            }));\n        }\n        this._isServer = !this._platform.isBrowser;\n        this._isNativeSelect = element.nodeName.toLowerCase() === 'select';\n        if (this._isNativeSelect) {\n            this.controlType = ((/** @type {?} */ (element))).multiple ? 'mat-native-select-multiple' :\n                'mat-native-select';\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get disabled() {\n        if (this.ngControl && this.ngControl.disabled !== null) {\n            return this.ngControl.disabled;\n        }\n        return this._disabled;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n        if (this.focused) {\n            this.focused = false;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get id() { return this._id; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set id(value) { this._id = value || this._uid; }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get required() { return this._required; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set required(value) { this._required = coerceBooleanProperty(value); }\n    /**\n     * Input type of the element.\n     * @return {?}\n     */\n    get type() { return this._type; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set type(value) {\n        this._type = value || 'text';\n        this._validateType();\n        // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n        if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {\n            ((/** @type {?} */ (this._elementRef.nativeElement))).type = this._type;\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get value() { return this._inputValueAccessor.value; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set value(value) {\n        if (value !== this.value) {\n            this._inputValueAccessor.value = value;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Whether the element is readonly.\n     * @return {?}\n     */\n    get readonly() { return this._readonly; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set readonly(value) { this._readonly = coerceBooleanProperty(value); }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe((/**\n             * @param {?} event\n             * @return {?}\n             */\n            event => {\n                this.autofilled = event.isAutofilled;\n                this.stateChanges.next();\n            }));\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnChanges() {\n        this.stateChanges.next();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.stateChanges.complete();\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n        }\n        // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n        this._dirtyCheckNativeValue();\n    }\n    /**\n     * Focuses the input.\n     * @param {?=} options\n     * @return {?}\n     */\n    focus(options) {\n        this._elementRef.nativeElement.focus(options);\n    }\n    /**\n     * Callback for the cases where the focused state of the input changes.\n     * @param {?} isFocused\n     * @return {?}\n     */\n    _focusChanged(isFocused) {\n        if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n            this.focused = isFocused;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    _onInput() {\n        // This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /**\n     * Does some manual dirty checking on the native input `value` property.\n     * @protected\n     * @return {?}\n     */\n    _dirtyCheckNativeValue() {\n        /** @type {?} */\n        const newValue = this._elementRef.nativeElement.value;\n        if (this._previousNativeValue !== newValue) {\n            this._previousNativeValue = newValue;\n            this.stateChanges.next();\n        }\n    }\n    /**\n     * Make sure the input is a supported type.\n     * @protected\n     * @return {?}\n     */\n    _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1) {\n            throw getMatInputUnsupportedTypeError(this._type);\n        }\n    }\n    /**\n     * Checks whether the input type is one of the types that are never empty.\n     * @protected\n     * @return {?}\n     */\n    _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /**\n     * Checks whether the input is invalid based on the native validation.\n     * @protected\n     * @return {?}\n     */\n    _isBadInput() {\n        // The `validity` property won't be present on platform-server.\n        /** @type {?} */\n        let validity = ((/** @type {?} */ (this._elementRef.nativeElement))).validity;\n        return validity && validity.badInput;\n    }\n    /**\n     * Determines if the component host is a textarea.\n     * @protected\n     * @return {?}\n     */\n    _isTextarea() {\n        return this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea';\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get empty() {\n        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n            !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    get shouldLabelFloat() {\n        if (this._isNativeSelect) {\n            // For a single-selection `<select>`, the label should float when the selected option has\n            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n            // overlapping the label with the options.\n            /** @type {?} */\n            const selectElement = (/** @type {?} */ (this._elementRef.nativeElement));\n            /** @type {?} */\n            const firstOption = selectElement.options[0];\n            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n            return this.focused || selectElement.multiple || !this.empty ||\n                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n        }\n        else {\n            return this.focused || !this.empty;\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @param {?} ids\n     * @return {?}\n     */\n    setDescribedByIds(ids) {\n        this._ariaDescribedby = ids.join(' ');\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * \\@docs-private\n     * @return {?}\n     */\n    onContainerClick() {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n        if (!this.focused) {\n            this.focus();\n        }\n    }\n}\nMatInput.decorators = [\n    { type: Directive, args: [{\n                selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n                exportAs: 'matInput',\n                host: {\n                    /**\n                     * \\@breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n                     */\n                    'class': 'mat-input-element mat-form-field-autofill-control',\n                    '[class.mat-input-server]': '_isServer',\n                    // Native input properties that are overwritten by Angular inputs need to be synced with\n                    // the native input element. Otherwise property bindings for those don't work.\n                    '[attr.id]': 'id',\n                    '[attr.placeholder]': 'placeholder',\n                    '[disabled]': 'disabled',\n                    '[required]': 'required',\n                    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n                    '[attr.aria-describedby]': '_ariaDescribedby || null',\n                    '[attr.aria-invalid]': 'errorState',\n                    '[attr.aria-required]': 'required.toString()',\n                    '(blur)': '_focusChanged(false)',\n                    '(focus)': '_focusChanged(true)',\n                    '(input)': '_onInput()',\n                },\n                providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],\n            },] },\n];\n/** @nocollapse */\nMatInput.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Platform },\n    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },\n    { type: NgForm, decorators: [{ type: Optional }] },\n    { type: FormGroupDirective, decorators: [{ type: Optional }] },\n    { type: ErrorStateMatcher },\n    { type: undefined, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [MAT_INPUT_VALUE_ACCESSOR,] }] },\n    { type: AutofillMonitor },\n    { type: NgZone }\n];\nMatInput.propDecorators = {\n    disabled: [{ type: Input }],\n    id: [{ type: Input }],\n    placeholder: [{ type: Input }],\n    required: [{ type: Input }],\n    type: [{ type: Input }],\n    errorStateMatcher: [{ type: Input }],\n    value: [{ type: Input }],\n    readonly: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatInputModule {\n}\nMatInputModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [MatInput, MatTextareaAutosize],\n                imports: [\n                    CommonModule,\n                    TextFieldModule,\n                    MatFormFieldModule,\n                ],\n                exports: [\n                    TextFieldModule,\n                    // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n                    // be used together with `MatFormField`.\n                    MatFormFieldModule,\n                    MatInput,\n                    MatTextareaAutosize,\n                ],\n                providers: [ErrorStateMatcher],\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { MatTextareaAutosize, MatInput, getMatInputUnsupportedTypeError, MatInputModule, MAT_INPUT_VALUE_ACCESSOR };\n//# sourceMappingURL=input.js.map\n"]}